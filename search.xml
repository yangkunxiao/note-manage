<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浅谈JavaScript异步编程</title>
      <link href="/2019/12/07/JavaScript/JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/12/07/JavaScript/JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>JavaScript异步编程</p><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>Promise是异步编程的一种实现方式，它比传统的解决方案更加合适、强大。所谓Promise，就是一种容器，容器里面保存着未来才会发生的事情（一般是异步操作）的结果。</p><p>Promise是一个对象，它提供一系列的API可以将异步操作的事情以同步的形式表现出来，比起”回调地狱”，它看起来更加合适、强大。它具有以下几大特点：</p><ul><li><code>Promise</code>的状态不受任何外界的影响。Promise的异步操作有三种状态：    <code>pending</code>(执行中)、<code>fulfilled</code>(已成功)、<code>rejected</code>(已失败)。只有异步操作的结果才能够决定<code>Promise</code>状态的走向。</li><li><code>Promise</code>的状态一旦改变，变不可再次变动。它的状态变化只有两种情况：<code>pending</code> =&gt; <code>fulfilled</code>、<code>pengding</code> =&gt; <code>rejected</code>。状态一旦发生变化，就不再改变，称之为 <code>resolved</code>(已定型)。</li></ul><p>Promise一旦新建之后，就会立即执行。而then指定的回调函数只有同步操作执行完之后才会执行。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//成功回调</span>  <span class="token comment" spellcheck="true">//todo</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//失败回调</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//todo</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p><p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 <code>pending</code> 变为 <code>resolved</code>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 <code>pending</code> 变为 <code>rejected</code>），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。但是一般默认不指定<code>rejected</code>状态的回调函数，而是使用<code>catch</code>。</p><p><code>finally</code>不管<code>promise</code>最终的执行结果如何，都会执行。</p><p><code>all</code>：方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><p><code>Promise.all()</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例</p><p>举个🌰：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        msg<span class="token punctuation">:</span> <span class="token string">'p1'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        msg<span class="token punctuation">:</span> <span class="token string">'p2'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> p3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        msg<span class="token punctuation">:</span> <span class="token string">'p3'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">,</span>p3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">[</span>res1<span class="token punctuation">,</span>res2<span class="token punctuation">,</span>res3<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res1<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res2<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行结果：p1 p2 p3</span></code></pre><p><code>p</code>的状态由p1,p2,p3决定：</p><ul><li><p>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p></li><li><p>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p></li></ul><p><code>race</code>：该方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>只要只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p><p><code>allSettled</code>：该方法由<code>ES2020</code>引入。<code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束。</p><p><code>any</code>：<code>Promise.any()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。该方法目前是一个第三阶段的<a href="https://github.com/tc39/proposal-promise-any" target="_blank" rel="noopener">提案</a> 。</p><p><code>resolve</code>：<code>Promise.resolve()</code>将现有对象转为 Promise 对象。</p><ul><li><p>参数是一个<code>Promise</code>实例：那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p></li><li><p>参数是一个 <code>thenable</code> 实例：<code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> thenable <span class="token operator">=</span> <span class="token punctuation">{</span>  then<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><code>Promise.resolve</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then</code>方法。</p></li><li><p>参数不是具有<code>then</code>方法的对象，或根本就不是对象：如果参数是一个原始值，或者是一个不具有<code>then</code>方法的对象，则<code>Promise.resolve</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Hello</span></code></pre></li></ul><p><code>reject</code>：<code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p><h4 id="Generator-yield"><a href="#Generator-yield" class="headerlink" title="Generator/yield"></a>Generator/yield</h4><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p><p>Generator 函数有多种理解角度。语法上，Generator 函数是一个状态机，封装了多个内部状态。</p><p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个<code>遍历器对象生成函数</code>。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p><p>形式上，Generator 函数是一个普通函数，但是有两个特征:</p><p>1、<code>function</code>关键字与函数名之间有一个星号；</p><p>2、函数体内部使用<code>yield</code>表达式，定义不同的内部状态</p><blockquote><p> Generator 函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行。</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">helloWorldGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">yield</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>  <span class="token keyword">yield</span> <span class="token string">'world'</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token string">'ending'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">let</span> hwg <span class="token operator">=</span> <span class="token function">helloWorldGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>hwg<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//{ value:hello,done:false }</span>hwg<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//{ value:world,done:false }</span>hwg<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//{ value:ending,done:true }</span>hwg<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//{ value:undefined,done:true }</span></code></pre><p>总结：调用Generator函数，会返回一个遍历器对象，它是函数内部的指针，以后每调用一次next函数，就会返回一个带有value和done属性的对象。<code>next</code>方法可以带一个参数，该参数就会被当作上一个<code>yield</code>表达式的返回值。<code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</p><p>Generator 函数返回的遍历器对象，还有一个<code>return</code>方法，可以返回给定的值，并且终结遍历 Generator 函数。</p><h4 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h4><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。它是Generator的语法糖。<code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>。</p><p><code>async</code>函数对 Generator 函数的改进，体现在以下几点。</p><ul><li><p>内置执行器。</p><p>Generator 函数的执行必须靠执行器。而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。</p></li><li><p>返回值是 Promise</p><p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p></li></ul><p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p><p><code>async</code>函数返回一个 Promise 对象。<code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。</p><p><code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</p><p>举个🌰：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">timeFn</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//Promise 新建后就会立即执行。</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        msg<span class="token punctuation">:</span><span class="token string">'hello'</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fun</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//Promise的写法</span>  <span class="token comment" spellcheck="true">// timeFn(time).then(res => {</span>  <span class="token comment" spellcheck="true">//     console.log(res);</span>  <span class="token comment" spellcheck="true">// })</span>  <span class="token comment" spellcheck="true">//async await的写法</span>  <span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">timeFn</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span></code></pre><p>程序会在3s之后打印{msg:’hello’}</p><p><code>await</code>：正常情况下，<code>await</code>命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义<code>then</code>方法的对象），那么<code>await</code>会将其等同于 Promise 对象。</p><p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 Promise 对象被<code>reject</code>。</p><p><code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</p><p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 等同于</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//spawn 自动执行器</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器中的进程、线程和Event Loop</title>
      <link href="/2019/12/01/JavaScript/EventLoop/"/>
      <url>/2019/12/01/JavaScript/EventLoop/</url>
      
        <content type="html"><![CDATA[<p>#浏览器</p><p>浏览器是多进程的。每一个Tab页就是一个独立的进程。</p><ul><li>主进程：个人理解问“管家”的角色，它控制着浏览器的各个任务，页面展示、网络请求、历史回退、前进等等</li><li>第三方插件进程：管理第三方插件</li><li>GPU线程：用于3D绘制</li><li>渲染进程：对前端来说，最重要的进程。</li></ul><h1 id="浏览器内核（渲染进程）"><a href="#浏览器内核（渲染进程）" class="headerlink" title="浏览器内核（渲染进程）"></a>浏览器内核（渲染进程）</h1><p>渲染进程是多线程的。它包含一下几大线程：</p><ul><li>GUI线程<ul><li>它负责页面的渲染、布局。</li><li>当页面发生重绘或者回流的时候，就会触发该线程</li><li>它和JS引擎线程互斥</li></ul></li><li>JS引擎线程<ul><li>负责程序的解析和执行</li></ul></li><li>事件触发线程<ul><li>它控制事件循环，管理着一个事件任务队列TaskQueue</li><li>当异步任务满足条件时，会将该异步任务的回调函数放入到JS引擎线程所在的执行栈中执行</li></ul></li><li>定时触发器线程<ul><li>setTimeOut 和 setInterval 所在的线程</li><li>定时器任务的计时不是由JS引擎计时的，而是由该线程控制</li><li>当定时任务计时完成之后，会通知事件触发线程</li></ul></li><li>异步http请求线程<ul><li>一个独立的ajax请求线程</li><li>当请求完成之后，会通知事件触发线程</li></ul></li></ul><h4 id="为什么GUI线程和JS引擎线程互斥"><a href="#为什么GUI线程和JS引擎线程互斥" class="headerlink" title="为什么GUI线程和JS引擎线程互斥"></a>为什么GUI线程和JS引擎线程互斥</h4><p>因为JS是可以操作DOM的，如果使用JS操作DOM的同时，GUI线程也在渲染DOM，那么渲染完成之后的元素可能就不是之前的元素了</p><h4 id="为什么JS引擎是单线程"><a href="#为什么JS引擎是单线程" class="headerlink" title="为什么JS引擎是单线程"></a>为什么JS引擎是单线程</h4><ul><li>创建JavaScript语言的时候，多进程多线程的架构并不流行，硬件支持度不高</li><li>多进程多线程操作需要加锁，操作成本较高，较为复杂</li><li>如果多个线程同时操作一个DOM，那么结果会是不可预料的</li></ul><h1 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h1><ul><li>JS的任务分为同步任何和异步任务的</li><li>同步任务都在JS引擎的执行栈上执行</li><li>事件触发线程管理一个任务队列，TaskQueue，当异步任务满足条件时，事件触发线程会将其放到任务队列当中，当主线程（JS引擎线程）执行完执行栈中的任务之后，会读取任务队列中的任务，如果有，就将可执行的异步任务的回调函数推入到执行栈中，开始执行。如果没有，则再次向事件触发线程发起询问，直到有为止。</li></ul><p><img src="http://cdn.yangkunxiao.cn/EventLoop.png" alt="Event Loop"></p><p>代码解释：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> timerCallback <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timerCallback'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> httpCallback <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'httpCallback'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 同步任务</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'同步任务1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 同步任务</span><span class="token comment" spellcheck="true">// 通知定时器线程 1s 后将 timerCallback 交由事件触发线程处理</span><span class="token comment" spellcheck="true">// 1s 后事件触发线程将 timerCallback 加入到事件队列中</span><span class="token function">setTimeout</span><span class="token punctuation">(</span>timerCallback<span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 同步任务</span><span class="token comment" spellcheck="true">// 通知异步http请求线程发送网络请求，请求成功后将 httpCallback 交由事件触发线程处理</span><span class="token comment" spellcheck="true">// 请求成功后事件触发线程将 httpCallback 加入到事件队列中</span>$<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'www.xxxx.com'</span><span class="token punctuation">,</span>httpCallback<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 同步任务</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'同步任务2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//...</span><span class="token comment" spellcheck="true">// 所有同步任务执行完后</span><span class="token comment" spellcheck="true">// 询问事件触发线程在事件事件队列中是否有需要执行的回调函数</span><span class="token comment" spellcheck="true">// 如果没有，一直询问，直到有为止</span><span class="token comment" spellcheck="true">// 如果有，将回调事件加入执行栈中，开始执行回调代码</span></code></pre><p>总结：</p><ul><li>JS引擎线程只执行执行栈中的事件</li><li>执行栈中的代码执行完毕，就会读取事件队列中的事件</li><li>事件队列中的回调事件，是由各自线程插入到事件队列中的</li><li>如此循环</li></ul><h4 id="宏任务、微任务"><a href="#宏任务、微任务" class="headerlink" title="宏任务、微任务"></a>宏任务、微任务</h4><p>宏任务：可以理解为浏览器级别的任务。主代码块，setTimeout，setInterval等，都属于宏任务</p><p>微任务：JS引擎级别的任务。Promise，process.nextTick等，属于<code>微任务</code>。</p><p>执行顺序：</p><ul><li>当前代码块对应的宏任务</li><li>当前宏任务结束之后，下一个宏任务开始之前，执行当前对列的微任务</li><li>GUI引擎渲染</li><li>下一个宏任务</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解JS的for循环</title>
      <link href="/2019/12/01/JavaScript/for/"/>
      <url>/2019/12/01/JavaScript/for/</url>
      
        <content type="html"><![CDATA[<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr1<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'l'</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">=</span> arr1<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> arr1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>for循环可以使用<code>break</code>和<code>continue</code></p><h4 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h4><ul><li>for-in 只能遍历“可枚举的属性”  可以使用查看是否可枚举<code>Object.getOwnPropertyDescriptor(object,property)</code></li><li>它实际上遍历的是对象的属性，而不是“索引值”， 所以for in可以遍历对象</li><li>遍历原型上的属性(可以配合 Object.hasOwnProperty())</li><li>for in遍历的顺序并不确定</li><li>性能：每次迭代操作会同时搜索实例或者原型属性， for-in 循环的每次迭代都会产生更多开销，因此要比其他循环类型慢</li></ul><pre class=" language-javascript"><code class="language-javascript">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> arr1<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`arr1[</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">] = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>arr1<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr1<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'age'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><ul><li>forEach 方法为数组中含有有效值的每一项执行一次 callback 函数</li><li>那些已删除（使用 delete 方法等情况）或者从未赋值的项将被跳过（不包括那些值为 undefined 或 null 的项）</li><li>不能使用break 和 continue</li><li>forEach 的速度不如 for</li></ul><pre class=" language-javascript"><code class="language-javascript">arr1<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr1<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span>index<span class="token punctuation">,</span>arr1<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span>index<span class="token punctuation">,</span>arr1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>看🌰：mac电脑、chrome浏览器的执行环境下</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">'for'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> <span class="token number">100000</span> <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">'for'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//耗时约8.5s</span>arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">'foreach'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span>index<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">'foreach'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//耗时约10.34s</span></code></pre><h4 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h4><ul><li><p>for of 是用来遍历可迭代对象的，js 引擎是通过判断对象是否具有 <code>Symbol.iterator</code> 来判断的，</p><ul><li>[][Symbol.iterator]</li><li>{}[Symbol.iterator]</li></ul></li><li><p>迭代器：有next()方法的对象，next()方法返回：done和value，done标示是否遍历完，value就是当前的值</p></li><li><p>跟 forEach 相比，它可以正确响应 break, continue, return。</p></li><li><p>for-of 循环不仅支持数组，还支持大多数类数组对象，例如 DOM nodelist 对象。</p></li><li><p>for-of 循环也支持字符串遍历，它将字符串视为一系列 Unicode 字符来进行遍历</p></li><li><p>for-of循环不支持普通对象，但如果你想迭代一个对象的属性，你可以用for-in 循环</p></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>item<span class="token punctuation">,</span>index<span class="token punctuation">]</span> <span class="token keyword">of</span> arr1<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span>index<span class="token punctuation">,</span><span class="token string">'===========for of'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>既然知道了<code>for of</code>的工作原理，那么我们是否可以手动实现一个功能，让对象可以被<code>for of</code>遍历呢？</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">createIterator</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">let</span> propKeys <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> propKey <span class="token keyword">of</span> propKeys<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">yield</span> <span class="token punctuation">[</span>propKey<span class="token punctuation">,</span> obj<span class="token punctuation">[</span>propKey<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span><span class="token string">'kaka'</span><span class="token punctuation">,</span>  age<span class="token punctuation">:</span><span class="token number">24</span><span class="token punctuation">}</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span>value<span class="token punctuation">]</span> <span class="token keyword">of</span> <span class="token function">createIterator</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">,</span><span class="token string">'=========forof'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS和CSS的tree-shaking</title>
      <link href="/2019/11/30/Webpack/tree-shaking/"/>
      <url>/2019/11/30/Webpack/tree-shaking/</url>
      
        <content type="html"><![CDATA[<h4 id="js：tree-shaking"><a href="#js：tree-shaking" class="headerlink" title="js：tree-shaking"></a>js：tree-shaking</h4><ul><li><p>它是指帮助开发者消除不同模块之间的一些无效代码的feature。在webpack中，也是有tree-shaking功能的，但是它的功能十分简单粗暴：只寻找<code>import</code>引入进来的变量是否出现过在模块内，非常简单粗暴。因为在开发过程中，开发者经常会犯这种错误：一些模块曾经引入了进来，但是后来却没有使用到，忘记删除了，这就会导致打包的时候，webpack自带的tree-shaking功能无法将这些无效的feature去除。</p></li><li><p>这是我们需要借助一些第三方插件去做这个事情：</p><pre class=" language-base"><code class="language-base">npm install --save-dev webpack-deep-scope-plugin//在webpack.config.js中引用const WebpackDeepScopeAnalysisPlugin = require('webpack-deep-scope-plugin').default;module.export = {    ......    plugins:[        new WebpackDeepScopeAnalysisPlugin()    ]}</code></pre><p>详情请参考：<a href="https://diverse.space/2018/05/better-tree-shaking-with-scope-analysis" target="_blank" rel="noopener">https://diverse.space/2018/05/better-tree-shaking-with-scope-analysis</a></p></li></ul><h4 id="css-tree-shaking"><a href="#css-tree-shaking" class="headerlink" title="css:tree-shaking"></a>css:tree-shaking</h4><ul><li><p>spa：<a href="https://www.npmjs.com/package/purifycss-webpack" target="_blank" rel="noopener">purifycss-webpack</a>该插件会把所有未被引用的css全部去除</p><pre class=" language-javascript"><code class="language-javascript">production：npm install <span class="token operator">--</span>save<span class="token operator">-</span>dev purifycss<span class="token operator">-</span>webpack<span class="token comment" spellcheck="true">//在webpack.config.js中引用</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//查找文件</span><span class="token keyword">const</span> glob <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'glob'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> PurifyCSSPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'purifycss-webpack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span><span class="token keyword">export</span> <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token operator">...</span>    plugins<span class="token punctuation">:</span><span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">PurifyCSSPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// Give paths to parse for rules. These should be absolute!</span>      paths<span class="token punctuation">:</span> glob<span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'./dist/*.html'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre></li><li><p>mpa：<a href="https://www.npmjs.com/package/mini-css-extract-plugin" target="_blank" rel="noopener">mini-css-extract-plugin</a>将css从js中抽离出来</p><blockquote><p>注意：它和style-loader 互斥， 不能同时开启，且HMR(热更新的时候也不支持) ， 只用于开发环境。</p></blockquote><pre class=" language-javascript"><code class="language-javascript">npm install <span class="token operator">--</span>save<span class="token operator">-</span>dev mini<span class="token operator">-</span>css<span class="token operator">-</span>extract<span class="token operator">-</span>plugin<span class="token punctuation">;</span><span class="token keyword">const</span> MiniCssExtractPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'mini-css-extract-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span><span class="token keyword">export</span> <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token operator">...</span><span class="token operator">...</span>  rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      test<span class="token punctuation">:</span> <span class="token regex">/\.css$/i</span><span class="token punctuation">,</span>      use<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token comment" spellcheck="true">// 'style-loader',</span>        <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//和style-loader 互斥 不能同时开启 HMR(热更新的时候也不支持)  只用于开发环境</span>          loader<span class="token punctuation">:</span> MiniCssExtractPlugin<span class="token punctuation">.</span>loader<span class="token punctuation">,</span>          options<span class="token punctuation">:</span> <span class="token punctuation">{</span>            publicPath<span class="token punctuation">:</span> <span class="token string">'../'</span><span class="token punctuation">,</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        loader<span class="token punctuation">:</span> <span class="token string">'css-loader'</span>        <span class="token punctuation">}</span>      <span class="token punctuation">]</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单元测试</title>
      <link href="/2019/11/30/Mocha/index/"/>
      <url>/2019/11/30/Mocha/index/</url>
      
        <content type="html"><![CDATA[<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>单元测试是指对软件中最小可测试单元进行检查验证，也称作模块测试。在nodeJs中通常是指对某个函数或者API进行正确验证，以保证代码的可用性。</p><p>单元测试有很多种，常见的有：行为驱动开发（BDD）和 测试驱动开发（TDD）。</p><ul><li>行为驱动开发（BDD）：行为驱动开发关注的是整个系统的最终实现是否和用户期望一致。</li><li>测试驱动开发（TDD）：测试驱动开发的目的是取得快速反馈，使所有功能都是可用的。</li></ul><h4 id="Mocha"><a href="#Mocha" class="headerlink" title="Mocha"></a>Mocha</h4><p>Mocha是现在最流行的一种单元测试框架。Mocha功能比较丰富，支持BDD、TDD</p><p>风格的测试，而且支持异步、同步的测试。</p><p>安装：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g mochaor<span class="token function">npm</span> <span class="token function">install</span> -S mocha</code></pre><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><p>创建一个demo01.js文件，文件中包含一个求和函数：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">...</span>rest<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> rest<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a <span class="token operator">+</span> b    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    add<span class="token punctuation">}</span></code></pre><p>再创建一个test的文件夹，进行测试：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> lib <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'../demo01.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> assert <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'assert'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> should <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'should'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">'Math'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">'#add'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">'add(0,0) should return 0'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//使用assert断言库</span>            <span class="token comment" spellcheck="true">// assert.strictEqual(0,lib.add(0,0));</span>            <span class="token comment" spellcheck="true">//使用should.js断言库进行测试</span>            lib<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>should<span class="token punctuation">.</span>be<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">'add(1,-1) should return 0'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// assert.strictEqual(0,lib.add(1,-1))</span>            lib<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>should<span class="token punctuation">.</span>be<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">'add(1,1) should return 2'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// assert.strictEqual(2,lib.add(1,1))</span>            lib<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>should<span class="token punctuation">.</span>be<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>describe(moduleName,testDetail):描述将要测试的模块。</p><p>it(info,function()):测试语句放在回调函数中：</p><ul><li>info 是正确输出时的简单语句描述</li><li>一个it对应一个实际的可能情况</li></ul><p>关于assets的更多的API，可参考<a href="https://nodejs.org/dist/latest/docs/api/assert.html#assert_assert" target="_blank" rel="noopener">node.js官网</a></p><p>关于should.js的更多的API，可参考<a href="https://shouldjs.github.io/" target="_blank" rel="noopener">should.js官网</a></p><p>然后，在package.json中写一下命令：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token string">"scripts"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>  <span class="token string">"test"</span><span class="token punctuation">:</span> <span class="token string">"mocha"</span><span class="token punctuation">}</span></code></pre><p>执行命令，mocha即可自动执行test文件夹下所有的测试脚本。</p><h4 id="异步测试"><a href="#异步测试" class="headerlink" title="异步测试"></a>异步测试</h4><p>使用Mocha进行异步测试，只需要在测试完成之后回调一个回调函数即可，例如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//异步测试</span><span class="token keyword">function</span> <span class="token function">asyncFn</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        callback <span class="token operator">&amp;&amp;</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    asyncFn<span class="token punctuation">}</span></code></pre><p>测试：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> lib <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'../demo03.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">'async.js'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">'async'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">'should wait 1000ms'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>done<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            lib<span class="token punctuation">.</span><span class="token function">asyncFn</span><span class="token punctuation">(</span>done<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h4 id="路由测试"><a href="#路由测试" class="headerlink" title="路由测试"></a>路由测试</h4><p>需要借用<code>supertest</code>库对后端的API接口进行测试.</p><p>安装：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev supertest</code></pre><p>supertest支持各种框架。本例以Express为例：</p><pre><code>//测试路由const express = require(&#39;express&#39;);const app = express();app.get(&#39;/user&#39;,(req,res) =&gt; {    res.status(200).json({        name:&#39;ykx&#39;,        age:24    })});module.exports = app;</code></pre><p>express设置了一个返回json格式的/user路由，通过get请求，返回用户名和年龄。</p><p>测试：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> request <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'supertest'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'../demo04.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">'GET /user'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">'should an name with age'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>done<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">request</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/user'</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span><span class="token string">'application/json;charset=utf-8'</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token punctuation">{</span>            name<span class="token punctuation">:</span><span class="token string">'ykx'</span><span class="token punctuation">,</span>            age<span class="token punctuation">:</span><span class="token number">24</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>done<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h4 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h4><p>测试覆盖率一般包含四个维度：</p><ul><li>行覆盖率：是否每一行都执行了</li><li>函数覆盖率：是否每一个函数都执行了</li><li>分支覆盖率：是否每个if代码块都执行了</li><li>语句覆盖率。是否每个语句都执行了</li></ul><p>在NodeJs中可以使用<code>Istanbul</code>代码覆盖率工具。</p><p>安装：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g istanbul</code></pre><p>然后在package.json中去配置命令：</p><pre class=" language-bash"><code class="language-bash"><span class="token string">"scripts"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>  <span class="token string">"test"</span><span class="token keyword">:</span> <span class="token string">"mocha"</span>,  <span class="token string">"cover"</span><span class="token keyword">:</span><span class="token string">"istanbul cover node_modules/mocha/bin/_mocha test/"</span><span class="token punctuation">}</span></code></pre><p>执行<code>npm run cover</code>命令，会在根目录下生成coverage文件夹，里面包含所有的测试数据。</p>]]></content>
      
      
      <categories>
          
          <category> Mocha </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mocha </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL自然连接查询</title>
      <link href="/2019/11/24/Mysql/naturalJoin/"/>
      <url>/2019/11/24/Mysql/naturalJoin/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是自然连接？"><a href="#什么是自然连接？" class="headerlink" title="什么是自然连接？"></a>什么是自然连接？</h4><p>通过mysql自己判断完成连接过程,不需要指定连接条件，mysql会根据多个表内的相同字段作为连接条件。</p><h4 id="自然连接的分类"><a href="#自然连接的分类" class="headerlink" title="自然连接的分类"></a>自然连接的分类</h4><p>自然连接分为：<strong><em>内自然连接</em></strong>（inner natural join）和 <strong><em>外自然连接</em></strong>。其中<strong><em>外自然连接</em></strong>又可分为<strong><em>左外自然连接</em></strong>（left natural join ）和 <strong><em>右外自然连接</em></strong>（right natural join）。</p><p>注意：自然连接没有判断语句！！！</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>假如存在两张表：tab1和tab2</p><ul><li><p>内自然连接</p><pre class=" language-javascript"><code class="language-javascript">select <span class="token operator">*</span> <span class="token keyword">from</span> tab1 natural join tab2<span class="token punctuation">;</span></code></pre><p>内自然连接相当于<strong>using为判断语句的内连接：</strong>即：</p><pre class=" language-javascript"><code class="language-javascript">select <span class="token operator">*</span> <span class="token keyword">from</span> tbl_name1 inner join tbl_name2 using<span class="token punctuation">;</span></code></pre></li><li><p>左外自然连接</p><pre class=" language-javascript"><code class="language-javascript">select <span class="token operator">*</span> <span class="token keyword">from</span> tab1 natural left join tab2<span class="token punctuation">;</span></code></pre><p>相当于using为判断语句的左外连接：</p><pre class=" language-javascript"><code class="language-javascript">select <span class="token operator">*</span> <span class="token keyword">from</span> tab1 left outer join tab2 using<span class="token punctuation">;</span></code></pre></li><li><p>右外自然连接</p><pre class=" language-javascript"><code class="language-javascript">select <span class="token operator">*</span> <span class="token keyword">from</span> tab1 natural right join tab2<span class="token punctuation">;</span></code></pre><p>相当于using为判断语句的右外连接：</p><pre class=" language-javascript"><code class="language-javascript">select <span class="token operator">*</span> <span class="token keyword">from</span> tab1 natural right join tab2<span class="token punctuation">;</span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 8.0+重置密码</title>
      <link href="/2019/11/24/Mysql/resetPassWord/"/>
      <url>/2019/11/24/Mysql/resetPassWord/</url>
      
        <content type="html"><![CDATA[<h4 id="关闭数据库"><a href="#关闭数据库" class="headerlink" title="关闭数据库"></a>关闭数据库</h4><p>1、在终端中输入：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> /usr/local/mysql/support-files mysql.server stop</code></pre><p>2、在访达中找到安装好的mysql，关闭mysql运行。</p><h4 id="跳过验证"><a href="#跳过验证" class="headerlink" title="跳过验证"></a>跳过验证</h4><pre class=" language-bash"><code class="language-bash">// 进入数据库指令文件<span class="token function">cd</span> /usr/local/mysql/bin// 跳过权限认证<span class="token function">sudo</span> ./mysqld_safe --skip-grant-tables</code></pre><h4 id="免密码进入数据库"><a href="#免密码进入数据库" class="headerlink" title="免密码进入数据库"></a>免密码进入数据库</h4><p>在上述指令运行后，新开一个终端，同时保持原来那个终端也开着，在新的终端输入指令如下：</p><pre class=" language-bash"><code class="language-bash">//  执行mysql指令/usr/local/mysql/bin/mysql// 进入名为<span class="token operator">&lt;</span>mysql<span class="token operator">></span>的数据库use mysql<span class="token punctuation">;</span>把之前密码清空：update user <span class="token keyword">set</span> authentication_string<span class="token operator">=</span><span class="token string">''</span>  where user<span class="token operator">=</span><span class="token string">'root'</span><span class="token punctuation">;</span>// 刷新权限flush privileges<span class="token punctuation">;</span>// 修改密码 但不适用于8.0+的版本// <span class="token keyword">set</span> password <span class="token keyword">for</span> <span class="token string">'root'</span>@<span class="token string">'localhost'</span> <span class="token operator">=</span> password<span class="token punctuation">(</span><span class="token string">'新的密码'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>// 8.0+版本修改密码ALTER user <span class="token string">'root'</span>@<span class="token string">'localhost'</span> indentified by <span class="token string">'新密码'</span><span class="token punctuation">;</span>//刷新一下flush privileges<span class="token punctuation">;</span>// 退出mysql<span class="token keyword">exit</span></code></pre><p>mysql常用命令：</p><pre class=" language-bash"><code class="language-bash">1、进入本地数据库：/usr/local/mysql/bin/mysql -u root -p 根据提示输入密码2、进入远程数据库：假设远程主机的IP为：23.106.134.88，用户名为root,密码为123456：mysql -h23.106.134.88 -u root -p 根据提示输入密码。3、启动mysql服务：<span class="token function">sudo</span> /usr/local/mysql/support-files/mysql.server start<span class="token punctuation">;</span>4、终止mysql服务：<span class="token function">sudo</span> /usr/local/mysql/support-files/mysql.server stop<span class="token punctuation">;</span>5、重启mysql服务：<span class="token function">sudo</span> /usr/local/mysql/support-files/mysql.server restart<span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESC服务器Linux下安装mysql</title>
      <link href="/2019/11/24/Linux/mysql/"/>
      <url>/2019/11/24/Linux/mysql/</url>
      
        <content type="html"><![CDATA[<p>1、重启服务器：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@sir-xiao server<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># reboot</span></code></pre><p>2、检查是否已经安装mysql服务：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@sir-xiao server<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># yum list installed | grep mysql</span></code></pre><p>如果显示一下内容，则表示没有安装：-bash: gerp: command not found<br>3、下载mysql安装包：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@sir-xiao server<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># rpm -ivh http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm</span></code></pre><p>4、安装mysql：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@sir-xiao server<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># yum install -y mysql-server</span>或者<span class="token punctuation">[</span>root@sir-xiao server<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># yum install mysql-community-server</span></code></pre><p>5、设置开机启动：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@sir-xiao server<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl enable mysqld.service</span></code></pre><p>6、查看服务是否加入开机自动启动：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@sir-xiao server<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl list-unit-files | grep mysqld</span></code></pre><p>7、查看mysql的默认临时密码：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@sir-xiao server<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl list-unit-files | grep mysqld</span></code></pre><p>8、root用户登录mysql数据库：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@sir-xiao server<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mysql -u root -p </span>Enter password: 根据提示 输入密码</code></pre><p>9、修改root用户密码：</p><pre class=" language-bash"><code class="language-bash">mysql<span class="token operator">></span> use  mysql；----切换到mysql dbmysql<span class="token operator">></span> UPDATE user SET authentication_string <span class="token operator">=</span> PASSWORD<span class="token punctuation">(</span><span class="token string">'newpass'</span><span class="token punctuation">)</span> WHERE user <span class="token operator">=</span> <span class="token string">'root'</span><span class="token punctuation">;</span>---新版本mysql执行mysql<span class="token operator">></span> UPDATE user SET Password <span class="token operator">=</span> PASSWORD<span class="token punctuation">(</span><span class="token string">'newpass'</span><span class="token punctuation">)</span> WHERE user <span class="token operator">=</span> <span class="token string">'root'</span><span class="token punctuation">;</span>---老版本mysql执行mysql<span class="token operator">></span> flush privileges<span class="token punctuation">;</span>---命令立即执行生效</code></pre><p>10、忘记密码重置密码：</p><pre class=" language-bash"><code class="language-bash">1、查找mysql的启动文件：<span class="token punctuation">[</span>root@sir-xiao etc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># whereis  my</span>2、vim /etc/my.cnf修改my.cnf启动参数，在文件的最后增加，mysql启动参数—— --skip-grant-tables。启动mysql时不启动授权表 grant-tables<span class="token punctuation">[</span>root@sir-xiao etc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># vi /etc/my.cnf skip-grant-tables</span><span class="token punctuation">[</span>root@sir-xiao etc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># :wq</span>vi模式Enter进入，按“i”键，编辑文件，按“esc”键，输入:wq写入保存退出，:q 不保存退出3、重启mysql服务4、修改密码：同上5、密码修改成功后需要进入vi模式下重新编辑/etc/my.cnf去掉增加的skip-grant-tables 重启mysql服务，就可以用密码登录了</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx同域名下配置多项目</title>
      <link href="/2019/11/23/Nginx/multiProject/"/>
      <url>/2019/11/23/Nginx/multiProject/</url>
      
        <content type="html"><![CDATA[<h4 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h4><pre class=" language-bash"><code class="language-bash">build: <span class="token punctuation">{</span>    index: path.resolve<span class="token punctuation">(</span>__dirname, <span class="token string">'../dist/index.html'</span><span class="token punctuation">)</span>,    // Paths    assetsRoot: path.resolve<span class="token punctuation">(</span>__dirname, <span class="token string">'../dist'</span><span class="token punctuation">)</span>,    assetsSubDirectory: <span class="token string">'static'</span>,    assetsPublicPath: <span class="token string">'/admin/'</span>,    productionSourceMap: true,    devtool: <span class="token string">'#source-map'</span>,    productionGzip: true,    productionGzipExtensions: <span class="token punctuation">[</span><span class="token string">'js'</span>, <span class="token string">'css'</span><span class="token punctuation">]</span>,    bundleAnalyzerReport: process.env.npm_config_report  <span class="token punctuation">}</span></code></pre><p>把 assetsPublicPath修改为你在nginx配置的路径。</p><h4 id="router-js"><a href="#router-js" class="headerlink" title="router.js"></a>router.js</h4><pre class=" language-bash"><code class="language-bash">//base要和上面配置的assetsPublicPath配置的一样 mode:<span class="token string">'history'</span>, base: <span class="token string">'/admin/'</span>,</code></pre><h4 id="配置nginx："><a href="#配置nginx：" class="headerlink" title="配置nginx："></a>配置nginx：</h4><pre class=" language-bash"><code class="language-bash">keepalive_timeout  65<span class="token punctuation">;</span><span class="token function">gzip</span>  on<span class="token punctuation">;</span>//开启Gzip压缩gzip_disable <span class="token string">'msie6'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">#不使用gzip IE6</span>gzip_min_length 100k<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">#gzip压缩最小文件大小，超出进行压缩（自行调节）</span>gzip_buffers 4 16k<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">#buffer 不用修改</span>gzip_comp_level 3<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">#压缩级别:1-10，数字越大压缩的越好，时间也越长</span>server <span class="token punctuation">{</span>    listen 80<span class="token punctuation">;</span>    server_name www.xxx.cn<span class="token punctuation">;</span>//配置你的域名    location /<span class="token punctuation">{</span>//配置默认的项目         root /data/www/web<span class="token punctuation">;</span>         try_files <span class="token variable">$uri</span> <span class="token variable">$uri</span>/ /index.html<span class="token punctuation">;</span>         index index.html index.htm<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">#proxy_pass http://127.0.0.1:8080;</span>     <span class="token punctuation">}</span>     location ^~/admin<span class="token punctuation">{</span>//配置 域名/admin 对应的项目         <span class="token function">alias</span> /data/www/admin/<span class="token punctuation">;</span>//别名 配置项目文件路径         try_files <span class="token variable">$uri</span> <span class="token variable">$uri</span>/ /index.html<span class="token punctuation">;</span>         index index.html index.htm<span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>-e <span class="token variable">$request_filename</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>//防止二级路由下页面reload空白页面             rewrite ^/<span class="token punctuation">(</span>.*<span class="token punctuation">)</span> /admin/index.html last<span class="token punctuation">;</span>             <span class="token keyword">break</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">#proxy_pass http://127.0.0.1:8080;</span>     <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx下配置Vue项目</title>
      <link href="/2019/11/23/Nginx/vue/"/>
      <url>/2019/11/23/Nginx/vue/</url>
      
        <content type="html"><![CDATA[<p>1、配置选择：</p><ul><li>Linux系统：Centos 6.5 x64</li><li>Nginx版本：1.7.8</li></ul><p>2、安装nginx：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local//下载nginx<span class="token function">wget</span> http://nginx.org/download/nginx-1.7.8.tar.gz<span class="token function">cd</span> nginx-1.7.8<span class="token function">make</span><span class="token function">make</span> <span class="token function">install</span></code></pre><p>3、开启nginx服务：</p><pre class=" language-bash"><code class="language-bash">/usr/local/nginx-1.7.8/sbin/nginx重启或关闭进程：/usr/local/nginx-1.7.8/sbin/nginx -s reload/usr/local/nginx-1.7.8/sbin/nginx -s stop</code></pre><p>4、关闭防火墙：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">service</span> iptables stop</code></pre><p>5、修改配置文件：</p><pre class=" language-bash"><code class="language-bash">usr/local/nginx-1.7.8/conf/nginx.confserver <span class="token punctuation">{</span>    listen 80<span class="token punctuation">;</span>//监听80端口    server_name www.yangkunxiao.cn<span class="token punctuation">;</span>   //项目对应域名    location /<span class="token punctuation">{</span>     root /data/www/dist<span class="token punctuation">;</span>     //项目存放路径     try_files <span class="token variable">$uri</span> <span class="token variable">$uri</span>/ /index.html<span class="token punctuation">;</span>    //vue项目配置history模式     index index.html index.htm<span class="token punctuation">;</span>    //项目首页名称     <span class="token comment" spellcheck="true">#proxy_pass http://127.0.0.1:8080;   //域名对应URL，这个URL对应的就是http://m.horace.space，可通过域名直接访问</span>    <span class="token punctuation">}</span>    location /assets/<span class="token punctuation">{</span>//配置资源文件夹        root /usr/<span class="token punctuation">;</span>//资源文件夹路径        autoindex on<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>7、多个项目配置多个service即可<br>6、重启即可</p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx下配置静态资源</title>
      <link href="/2019/11/23/Nginx/staticSource/"/>
      <url>/2019/11/23/Nginx/staticSource/</url>
      
        <content type="html"><![CDATA[<p>1、查看nginx安装路径：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">whereis</span> nginx</code></pre><p>2、新建静态资源存储文件夹：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> assets</code></pre><p>3、进入nginx目录中，修改nginx.conf文件：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> nginx: /usr/local/nginx/confvim nginx.conf具体配置如下：server <span class="token punctuation">{</span>    listen 80<span class="token punctuation">;</span>    server_name www.yangkunxiao.cn<span class="token punctuation">;</span>    location /<span class="token punctuation">{</span>     root /data/www/dist<span class="token punctuation">;</span>     try_files <span class="token variable">$uri</span> <span class="token variable">$uri</span>/ /index.html<span class="token punctuation">;</span>     index index.html index.htm<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">#proxy_pass http://127.0.0.1:8080;</span>    <span class="token punctuation">}</span>    location /assets/<span class="token punctuation">{</span>        root /usr/<span class="token punctuation">;</span>        autoindex on<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>4、保存并重启nginx</p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php和mySql</title>
      <link href="/2019/11/22/Php/mysql/"/>
      <url>/2019/11/22/Php/mysql/</url>
      
        <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>通过PHP，开发者可以和数据库相连。<br>在PHP5.0版本以后，官方推荐一下两种方式进行PHP和数据库的连接：</p><ul><li>MySQLi extension (“i” 意为 improved)：MySQLi 只针对 MySQL 数据库</li><li>PDO (PHP Data Objects)：PDO 应用在 12 种不同数据库中<br>因为我这里只安装了mySql，所以本文栗子均以第一种方式进行操作。</li></ul><h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><p>在访问数据库之前，我们需要进行数据库的连接</p><pre class=" language-bash"><code class="language-bash"><span class="token variable">$serverName</span> <span class="token operator">=</span> <span class="token string">'localhost'</span><span class="token punctuation">;</span>//数据库地址<span class="token variable">$serverRoot</span> <span class="token operator">=</span> <span class="token string">'root'</span><span class="token punctuation">;</span>//数据库登录名称<span class="token variable">$passWord</span> <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>//数据库密码<span class="token variable">$dbName</span> <span class="token operator">=</span> <span class="token string">"myDB"</span><span class="token punctuation">;</span><span class="token variable">$conn</span> <span class="token operator">=</span> new mysqli<span class="token punctuation">(</span><span class="token variable">$serverName</span>,<span class="token variable">$userName</span>,<span class="token variable">$userPassword</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//连接失败if<span class="token punctuation">(</span><span class="token variable">$conn</span>-<span class="token operator">></span>connect_error<span class="token punctuation">)</span><span class="token punctuation">{</span>    die<span class="token punctuation">(</span><span class="token string">"数据库连接失败："</span><span class="token keyword">.</span><span class="token variable">$conn</span>-<span class="token operator">></span>connect_error<span class="token punctuation">)</span><span class="token punctuation">}</span>mysqli_set_charset<span class="token punctuation">(</span><span class="token variable">$this</span>-<span class="token operator">></span>conn, <span class="token string">"utf8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//设置字符编码为utf8格式 否则汉字可能出现乱码的情况//数据库操作完成之后 一定记得关闭数据库的连接<span class="token variable">$conn</span>-<span class="token operator">></span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h4><p>1、创建数据库：<code>$sql = &quot;CREATE DATABASE IF NOT EXISTS dbname&quot;</code><br>2、创建表：上面的连接语句要修改下，加个参数，用来选择数据库：</p><pre class=" language-bash"><code class="language-bash"><span class="token variable">$conn</span> <span class="token operator">=</span> new mysqli<span class="token punctuation">(</span><span class="token variable">$serverName</span>,<span class="token variable">$userName</span>,<span class="token variable">$userPassword</span>,<span class="token variable">$dbName</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$sql</span> <span class="token operator">=</span> <span class="token string">"CREATE TABLE MyGuests (id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY, firstname VARCHAR(30) NOT NULL,lastname VARCHAR(30) NOT NULL,email VARCHAR(50),reg_date TIMESTAMP)"</span><span class="token punctuation">;</span></code></pre><p>属性说明：</p><ul><li>NOT NULL - 每一行都必须含有值（不能为空），null 值是不允许的。</li><li>DEFAULT value - 设置默认值</li><li>UNSIGNED - 使用无符号数值类型，0 及正数</li><li>AUTO INCREMENT - 设置 MySQL 字段的值在新增记录时每次自动增长 1</li><li>PRIMARY KEY - 设置数据表中每条记录的唯一标识。 通常列的 PRIMARY KEY 设置为 ID 数值，与 AUTO_INCREMENT 一起使用。<br>每个表都应该有一个主键(本列为 “id” 列)，主键必须包含唯一的值</li></ul><p>3、插入数据：<code>$sql=&#39;INSERT INTO table_name (column1, column2, column3,...)VALUES (value1, value2, value3,...)&#39;</code><br>4、插入多条数据：</p><pre class=" language-bash"><code class="language-bash"><span class="token variable">$sql</span> <span class="token operator">=</span> <span class="token string">"INSERT INTO student (column1, column2, column3,...)VALUES (value1, value2, value3,...);"</span><span class="token punctuation">;</span><span class="token variable">$sql</span>.<span class="token operator">=</span><span class="token string">"INSERT INTO student (column1, column2, column3,...)VALUES (value1, value2, value3,...);"</span><span class="token punctuation">;</span><span class="token variable">$sql</span>.<span class="token operator">=</span><span class="token string">"INSERT INTO student (column1, column2, column3,...)VALUES (value1, value2, value3,...);"</span><span class="token punctuation">;</span></code></pre><p>注意：sql语句之间用;隔开</p><p>5、查询数据：<code>$sql = &#39;SELECT * FROM  myDB;&#39;</code><br>6、更新数据：<br><code>UPDATE table_nameSET column1=value, column2=value2,...WHERE some_column=some_value</code><br>7、删除数据：<code>DELETE FROM table_nameWHERE some_column = some_value</code></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
          <category> mySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> mySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php基础</title>
      <link href="/2019/11/22/Php/base/"/>
      <url>/2019/11/22/Php/base/</url>
      
        <content type="html"><![CDATA[<h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><p>（全称：PHP：Hypertext Preprocessor，即”PHP：超文本预处理器”）是一种通用开源脚本语言。</p><h4 id="PHP的作用"><a href="#PHP的作用" class="headerlink" title="PHP的作用"></a>PHP的作用</h4><ul><li>PHP 可以生成动态页面内容</li><li>PHP 可以创建、打开、读取、写入、关闭服务器上的文件<ul><li>PHP 可以收集表单数据</li><li>PHP 可以发送和接收 cookies</li><li>PHP 可以添加、删除、修改您的数据库中的数据</li><li>PHP 可以限制用户访问您的网站上的一些页面</li><li>PHP 可以加密数据</li></ul></li></ul><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><pre><code>&lt;?php    $x=5;    $y=6;    $z=$x+$y;    echo $z;?&gt;</code></pre><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p>PHP有四种不同的变量作用域：</p><ul><li>local：局部作用域。在 PHP 函数内部声明的变量是局部变量，仅能在函数内部访问</li><li>global：全局作用域。在所有函数外部定义的变量，拥有全局作用域。除了函数外，全局变量可以被脚本中的任何部分访问，要在一个函数中访问一个全局变量，需要使用 global 关键字。</li><li>static：当一个函数完成时，它的所有变量通常都会被删除。然而，有时候我们希望某个局部变量不要被删除，可以使用static</li><li>parameter：参数作用域。参数是通过调用代码将值传递给函数的局部变量。参数是在参数列表中声明的，作为函数声明的一部分</li></ul><h4 id="局部和全局作用域"><a href="#局部和全局作用域" class="headerlink" title="局部和全局作用域"></a>局部和全局作用域</h4><pre><code>$x = 5;//全局变量function test(){    global $x;//使用global关键字 使用全局变量    static $n = 0;//局部变量    $y = 10;//局部变量    $n++;    echo &#39;x: &#39;.$x.&#39;&lt;br/&gt;&#39;;    echo &#39;y: &#39;.$y.&#39;&lt;br/&gt;&#39;;    echo $n.&#39;&lt;br /&gt;&#39;;};test();test();test();</code></pre><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>常量值被定义后，在脚本的其他任何地方都不能被改变。常量是一个简单值的标识符。该值在脚本中不能改变。<br>一个常量由英文字母、下划线、和数字组成,但数字不能作为首字母出现。 (常量名不需要加 $ 修饰符)。<br>设置常量，使用 define() 函数，函数语法如下：</p><blockquote><p>bool define ( string $name , mixed $value [, bool $case_insensitive = false ] )<br>该函数有三个参数:</p></blockquote><ul><li>name：必选参数，常量名称，即标志符</li><li>value：必选参数，常量的值</li><li>case_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的</li></ul><pre><code>&lt;?phpdefine(&quot;GREETING&quot;, &quot;欢迎访问 Runoob.com&quot;);echo GREETING;    // 输出 &quot;欢迎访问 Runoob.com&quot;echo &#39;&lt;br&gt;&#39;;echo greeting;   // 输出 &quot;greeting&quot;?&gt;</code></pre><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li>字符串</li><li>整型：整数是一个没有小数的数字</li><li>浮点型：浮点数是带小数部分的数字，或是指数形式。</li><li>布尔型</li><li>数组</li><li>对象：在 PHP 中，对象必须声明。首先，你必须使用class关键字声明类对象。类是可以包含属性和方法的结构。然后我们在类中定义数据类型，然后在实例化的类中使用数据类型</li><li>NULL</li></ul>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建</title>
      <link href="/2019/11/22/Hexo/index/"/>
      <url>/2019/11/22/Hexo/index/</url>
      
        <content type="html"><![CDATA[<h4 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h4><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul><li><p>Node（本文不做多余叙述）</p></li><li><p>Git（本文不做多余叙述）</p></li><li><p>Hexo<br><code>$ npm install -g hexo-cli</code><br>安装完成后，到一个新的文件夹下，打开Git Bash，执行一下命令：</p><pre><code>$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install</code></pre><p>新建完成之后，打开新建的项目，查看项目目录：</p></li><li><p>public：执行hexo generate命令，生成的HTML静态文件</p></li><li><p>scaffolds：模版文件夹</p></li><li><p>source：资源文件夹，文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里</p><ul><li>_data：你的数据文件夹，例如：<ul><li>friends.json：存放友情链接的数据</li><li>musics.json：存放音乐播放器的数据</li></ul></li><li>_posts：文章存放文件夹</li><li>categories：分类</li><li>tags：标签<ul><li>thems：主题文件夹，Hexo 会根据主题来生成静态页面。以我当前使用的metery主题为例</li><li>langauages：存放语言相关设置的yml文件</li><li>layout：存放文章的ejs模版，可以在里面修改相关的HTML、CSS、JS等</li><li>source：该主题下使用的资源文件夹</li><li>_config.yml：该主题的配置文件</li></ul></li></ul></li></ul><ul><li>_config.yml：该项目的配置文件</li><li>db.json：source解析所得到的</li><li>package.json：项目所需模块项目的配置信息</li></ul><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><ul><li>GitHub上新建一个项目</li><li>本地Git Bash上配置github账户信息<ul><li><code>git config --global user.name &#39;yourName&#39;</code></li><li><code>git config --global user.email &#39;yourEmail&#39;</code><ul><li>创建SSH</li><li>在gitbash中输入：</li><li><code>ssh-keygen -t rsa -C &quot;youremail@example.com</code>，生成ssh。</li><li><code>cd ~/.ssh</code> 找到id_rsa.pub</li><li><code>cat id_rsa.pub</code>复制其中的内容到github上，创建一个新的 SSH KEY</li></ul></li></ul></li></ul><ul><li>修改_config.yml<pre><code>deploy:type: gitrepo: https://github.com/YourgithubName/YourgithubName.github.io.gitbranch: master</code></pre></li><li>回到Git Bash<pre><code>npm i hexo-serverhexo cleanhexo generatehexo server</code></pre></li><li>上传到GitHub<pre><code>npm install hexo-deployer-git --savehexo cleanhexo generatehexo deploy</code></pre>注意deploy的过程中要输入你的username及passward。<br>然后在浏览器中输入 <a href="http://yourgithubname.github.io" target="_blank" rel="noopener">http://yourgithubname.github.io</a> 就可以看到你的个人博客。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作用域和作用域链</title>
      <link href="/2019/11/21/JavaScript/ScopeChain/"/>
      <url>/2019/11/21/JavaScript/ScopeChain/</url>
      
        <content type="html"><![CDATA[<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>在JavaScript中的作用域有<strong><em>全局作用域</em></strong>、<strong><em>局部作用域</em></strong>（在JavaScript中局部作用域即是<strong><em>函数作用域</em></strong>）以及<strong><em>块级作用域</em></strong>。</p><ul><li><p>全局作用域：在最外层函数定义的变量即拥有全局作用域，对于任意函数来说，都可以访问到。例如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1</span>  <span class="token punctuation">}</span>  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><ul><li><p>局部作用域：和全局作用域相反，局部作用域的变量即是在特定代码块中才能过访问，对于外部是不能够访问的。注意：在函数内部定义变量的时候，如果不用var，那么你声明的就是全局变量了。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//1</span>  <span class="token punctuation">}</span>  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//b is not defined</span><span class="token punctuation">}</span></code></pre></li><li><p>块级作用域：在代码块中使用<strong><em>let</em></strong>定义的变量，只能在当前代码块中进行访问。块级作用域可以形成暂时性死区。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1-9</span>  <span class="token punctuation">}</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//undefined</span><span class="token punctuation">}</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></li></ul><h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p>个人理解，作用域就是在函数内部可以访问外部变量的机制，使用链式查找哪些变量可以被函数内部访问。说起作用域链，那么不得不说<strong><em>执行环境</em></strong>了。</p><h4 id="执行环境（Execution-Context）"><a href="#执行环境（Execution-Context）" class="headerlink" title="执行环境（Execution Context）"></a>执行环境（Execution Context）</h4><p>EC是JavaScript中一个最为重要的概念。EC定义了变量和函数有权访问的其他数据。JavaScript中，函数在运行时都会产生一个执行环境，并且JS引擎还会产生一个与当前EC相关联的<strong><em>变量对象</em></strong>（Variable Object，即VO）。EC中所有定义的变量和方法都包含在VO中。全局执行环境是最外围的执行环境，它是一个“兜底”的执行环境。</p><p>JS引擎在进入一段可执行的代码时，需要完成以下三个初始化工作：</p><p>首先，创建一个<strong><em>全局对象</em></strong>(Global Object，即GO)，将Math、String、Data等常用的js对象作为其属性，但是这个GO在全局是不可见的，不可直接访问的。因此它还有另外一个属性window，并将window指向了自身，这样就可以在全局通过访问window，来访问GO的属性和方法了。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> globalObject <span class="token operator">=</span> <span class="token punctuation">{</span>  Math<span class="token punctuation">,</span>  String<span class="token punctuation">,</span>  Data<span class="token punctuation">,</span>  Function<span class="token punctuation">,</span>  <span class="token operator">...</span>  window<span class="token punctuation">:</span><span class="token keyword">this</span><span class="token punctuation">}</span></code></pre><p>其次，JS引擎会创建一个<strong><em>执行环境栈</em></strong>（Execution Context Stack 即ECS），与此同时还会创建一个全局环境EC。当JS的执行流执行到一个函数时，JS引擎就会把该函数的EC推到ECS中，当函数执行完之后，再把EC从ECS中弹出，将执行流的控制权交还给上一层的EC。ECMAScript的执行流就是由这种机制控制着。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> ecStack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行到函数fn</span>ecStock<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>EC<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行完fn</span>ecStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span>EC<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>最后，JS引擎会创造一个和EC相关连的变量对象VO。如果这个环境是一个函数，则将其<strong><em>活动对象</em></strong>（Action Object，即AO）作为其变量对象。初始时AO只包含一个变量，即arguments。作用域链的下一个变量对象来自于外部包含环境，而下一个变量对象来自下一个包含环境，这样一直延伸到全局环境。全局变量对象（GO）始终都是作用域链的最后一个对象。</p><p>每一个函数在定义的时候，都会创建一个与之关联的<strong><em>[[scopes]]</em></strong>属性，该scope总是指向定义函数时的执行环境EC。举个🌰：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="http://cdn.yangkunxiao.cn/xv64Ki.png" alt="scopes"></p><p>如上图所示，函数fn的[[scopes]][0]即是它的执行环境，GO。</p><p>再看：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> t <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span></code></pre><p><img src="http://cdn.yangkunxiao.cn/KL9FAg.png" alt="scopes"></p><p>fn中始终都没有定义变量a，那么JS引擎就会沿着Scope Chain一直向上寻找a，最终在GO中找到了a。</p><h4 id="作用域链-1"><a href="#作用域链-1" class="headerlink" title="作用域链"></a>作用域链</h4><p>当JavaScript的代码块在运行时，就会创建与之相关的作用域链。</p><blockquote><p>作用域链的作用就是保证当前环境对其有权访问的变量和方法进行有序的访问 ——JavaScript高级程序设计</p></blockquote><p>作用域链的前端（也就是开头）就是当前执行环境EC的变量对象，它的变量对象来自于它的外部包含环境，再下一个变量对象同时也来自再下一个外部包含环境，这样一直延伸到全局执行环境，同时，GO也是作用域链的最后一个对象。</p><h4 id="标识符解析"><a href="#标识符解析" class="headerlink" title="标识符解析"></a>标识符解析</h4><p>当在某个环境中为了读取或写入从而引入一个标识符时，必须通过搜索来确定该标识符代表了什么。搜索过程从当期作用域链的前端开始，向上逐级搜索，如果在局部环境中查找到了该标识符的定义，则停止搜索‘否则将一直沿着作用域链向上查找，直到找到GO上。如果找不到，则会报错。</p><h4 id="延长作用域"><a href="#延长作用域" class="headerlink" title="延长作用域"></a>延长作用域</h4><p>虽然作用域只有两种：全局和局部（函数），但是还是有其他办法可以用来延长作用域链。其主要思路就是：有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象在代码执行后就被销毁。</p><p>1、try-catch语句的catch块</p><p>2、with语句</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>什么是闭包？个人理解就是由于函数的嵌套，并且对外提供访问接口就会产生闭包。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> b  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> t <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2</span></code></pre><p>在上面的代码中，正常情况下，函数fn执行完之后，应该<strong><em>JS的垃圾回收机制</em></strong>被标记“等待清除”，等待下一次垃圾回收机制执行的时候被清除，但是由于返回函数中引用了fn中的变量b，所以函数fn并不会被清除，而是一直保存着内存中，直到没有任何引用，才会被清除。</p><p>从上面的🌰我们可以得出，闭包有什么作用呢？</p><ul><li>闭包可以使得程序在函数外部可以访问到函数内部的变量</li><li>闭包可以在内存中维持一个变量</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> i    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>    <span class="token keyword">return</span> array<span class="token punctuation">}</span><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//10</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//10</span></code></pre><p>正常情况下，我们期待的结果就是返回0和1,但是结果出人意料。为什么呢？</p><p>其实我们可以先看下arr[0]执行时，它的scope chain：</p><p><img src="http://cdn.yangkunxiao.cn/r0f77m.png" alt="scopes"></p><p>我们可以清楚的看到，此时arr[0]中并没有i的定义，它会沿着作用域链向上找i，那么就会找到fn中的i，但是此时，i已经变成10了。</p><p>从此我们也可以得出一个结论：</p><blockquote><p>JS的函数中的变量的值不是在编译的时候确定的，而是在运行时再去寻找的。</p></blockquote><p>如果我们想让上面的🌰按照我们预期的执行，那么考虑使用立即执行函数。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//函数参数的传递是按值传递，会创建i的副本，而不是直接使用变量i</span>      <span class="token keyword">return</span> num    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> array<span class="token punctuation">}</span><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用原生JavaScript实现call、apply和bind</title>
      <link href="/2019/11/21/JavaScript/this/"/>
      <url>/2019/11/21/JavaScript/this/</url>
      
        <content type="html"><![CDATA[<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>在JavaScript中this的指向问题中提到，作为对象方法的调用。函数还可以作为某个对象的方法调用，这时this就指这个上级对象。也就是我们平时说的，谁调用，this就指向谁。</p><blockquote><p>实现方法：在传入的参数中传入一个方法，然后执行这个方法，最后删除该方法（为了保持对象的前后一致性）。</p></blockquote><h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><pre class=" language-bash"><code class="language-bash">var obj <span class="token operator">=</span> <span class="token punctuation">{</span>    age <span class="token punctuation">;</span> 10<span class="token punctuation">}</span>var fn <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    this.value <span class="token operator">=</span> 100<span class="token punctuation">;</span><span class="token punctuation">}</span>/**将newCall绑定在Function的原型上 context:上下文 即this<span class="token punctuation">..</span>.rest ES6语法糖 用来取代arguments*/Function.prototype.newCall <span class="token operator">=</span> function<span class="token punctuation">(</span>context,<span class="token punctuation">..</span>.rest<span class="token punctuation">)</span><span class="token punctuation">{</span>    if<span class="token punctuation">(</span> context instanceof Object <span class="token punctuation">)</span><span class="token punctuation">{</span>        context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>    <span class="token punctuation">}</span>else<span class="token punctuation">{</span>        context <span class="token operator">=</span> Object.create<span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    //使用symbal 避免原来的context上有函数fn    const fn <span class="token operator">=</span> Symbal<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> this<span class="token punctuation">;</span>//此时this 谁调用 指向谁    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">..</span>.rest<span class="token punctuation">)</span><span class="token punctuation">;</span>//context 调用fn,改变this指向    delete context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span>//删除fn属性 保持原对象的统一<span class="token punctuation">}</span>var fun <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console.log<span class="token punctuation">(</span>this.age<span class="token punctuation">)</span><span class="token punctuation">;</span>//10    // fn.newCall<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>    //console.log<span class="token punctuation">(</span>this.value<span class="token punctuation">)</span><span class="token punctuation">;</span> 100<span class="token punctuation">}</span>fun.newCall<span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p>和call类似，只是传参的不同，不多说 ，直接上代码： </p><pre class=" language-bash"><code class="language-bash">Function.prototype.newCall <span class="token operator">=</span> function<span class="token punctuation">(</span>context,parames<span class="token punctuation">)</span><span class="token punctuation">{</span>    if<span class="token punctuation">(</span> context instanceof Object <span class="token punctuation">)</span><span class="token punctuation">{</span>        context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>    <span class="token punctuation">}</span>else<span class="token punctuation">{</span>        context <span class="token operator">=</span> Object.create<span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    //使用symbal 避免原来的context上有函数fn    const fn <span class="token operator">=</span> Symbal<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> this<span class="token punctuation">;</span>//此时this 谁调用 指向谁    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span>parames<span class="token punctuation">)</span><span class="token punctuation">;</span>//context 调用fn,改变this指向    delete context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span>//删除fn属性 保持原对象的统一<span class="token punctuation">}</span></code></pre><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>bind和call、apply的区别，这里不再多做赘述。直接上代码：</p><pre class=" language-bash"><code class="language-bash">Function.prototype.bind <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>context,<span class="token punctuation">..</span>.innerArgs<span class="token punctuation">)</span> <span class="token punctuation">{</span>  var self <span class="token operator">=</span> this  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">..</span>.finnalyArgs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> self.call<span class="token punctuation">(</span>context,<span class="token punctuation">..</span>.innerArgs,<span class="token punctuation">..</span>.finnalyArgs<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript原型、原型链和继承</title>
      <link href="/2019/11/21/JavaScript/prototype/"/>
      <url>/2019/11/21/JavaScript/prototype/</url>
      
        <content type="html"><![CDATA[<h4 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h4><p>无论我们什么时候创建一个函数，它都会有一个属性prototype，该属性是一个指针，它指向函数的原型对象，该原型对象所拥有的属性和方法都可被函数的实例所共享。举个🌰：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>fn<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span>fn<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>todo <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'todo'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> newFn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//查看fn所有的属性和方法</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newFn<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//'a'</span>newFn<span class="token punctuation">.</span><span class="token function">todo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>所有的原型对象都会自动拥有一个属性constructor(构造函数)，这个属性包含一个指向构造函数的指针。即：</p><pre class=" language-javascript"><code class="language-javascript">fn<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> fn<span class="token punctuation">;</span></code></pre><blockquote><p>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262第5版中管这个指针叫[[Prototype]]。虽然在脚本中没有标准的方式访问[[Prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性__proto__；而在其他实现中，这个属性对脚本则是完全不可见的。——JavaScript高级程序设计</p></blockquote><p><img src="http://cdn.yangkunxiao.cn/prototype.png" alt=""></p><p>该属性是实例和构造函数的原型对象之间的联系，和构造函数并无直接关联，其实实例之所以可以调用构造函数的原型对象上面的属性和方法，也是通过该属性实现的。</p><p>小结：</p><ul><li>所有的引用类型都可以自由的扩展其属性（除null）</li><li>所有的引用类型都有_proto_属性（除null）</li><li>所有的对象都有prototype属性</li><li>所有的引用类型的_proto_都指向它们的构造函数的prototype</li><li>当寻找一个引用类型的属性时，如果在当前对象找不到该属性的定义，就会沿着_proro_一直向上寻找，直到找到为止或者找到Object.prototype(即null)为止。</li></ul><p>注意：大家可能已经注意到，函数既有prototype属性，也有_proto_属性。下面就针对函数做一个解释：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> Fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Fn<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span><span class="token string">'yellow'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>Fn<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>todo <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'todo'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> fn1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>fn1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//Fn.prototype</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>fn1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//Object.prototye</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>fn1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//null</span></code></pre><blockquote><p>请记住：万物皆对象。一切引用类型都有一个隐式原型Object.prototype。</p></blockquote><p><img src="http://cdn.yangkunxiao.cn/scopeChain.jpeg" alt="原型链"></p><h4 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h4><p>原型对象最大的问题就是因其共享性所导致的。看个🌰：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//原型</span><span class="token keyword">var</span> Fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Fn<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span><span class="token string">'yellow'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>Fn<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>todo <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'todo'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> fn1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fn1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> fn2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ["red", "yellow", "blue"]</span></code></pre><h4 id="为什么要使用原型对象"><a href="#为什么要使用原型对象" class="headerlink" title="为什么要使用原型对象"></a>为什么要使用原型对象</h4><p>首先，看一段代码：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//新建一个构造函数 </span><span class="token keyword">var</span> Person <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token function">drink</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'drink'</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>eat <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'eat'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>person<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在这段代码中，我们分别在Person和Person.prototye上挂载了 eat 和 drink 函数，然后使用 new 关键字对构造函数 Person 进行了实例化。</p><p>对于 drink 函数：每进行一次实例化，都要重新在内存中占用一些资源。</p><p>对于 eat 函数：我们将 eat 函数挂载在 Person 的原型上，Person 的实例每次只需要调用原型上的方法即可，节约了内存占用。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>ECMAScript中实现继承的主要就是依靠原型链来实现的。</p><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><p>最为ECMAScript最主要的继承方法，其基本思想就是让一个引用类型继承另一个引用类型的属性和方法。在上面我们说过，每一个构造函数都有一个原型对象，原型对象都有一个指向构造函数的指针constructor，每一个构造函数都可以生成一个实例，每一个实例都有一个指向原型对象的内部指针_proto_。简单来说就是：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> Fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> Test <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Fn<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Fn<span class="token punctuation">;</span>fn<span class="token punctuation">.</span>_proto_ <span class="token operator">=</span><span class="token operator">></span> Fn<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span></code></pre><p>如果此时我们让一个Fn的原型对象指向另一个类型的实例呢？</p><pre><code>Fn.prototype = new Test();</code></pre><p>那么此时，原型对象就会有一个指向另一个原型的指针，另一个原型也会包含一个指向另一个构造函数的指针。如此层层递进，即构成了原型链。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">,</span> <span class="token string">"green"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>SuperType<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>Fun <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//继承了SuperType</span>SubType<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"black"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//"red,blue,green,black"</span><span class="token keyword">var</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//"red,blue,green,black"</span></code></pre><blockquote><p>优点：可以通过 instanceOf 和 isPrototypeOf 检测</p><p>缺点：</p><p>1、父类型中的私有属性会变为子类型中的公有属性</p><p>2、创建子类型的时候，不能像父类型的构造函数中传递参数。</p></blockquote><h4 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h4><blockquote><p>JavaScript规定，每一个构造函数都有一个prototype属性，它指向一个对象，这个对象中的所有的属性和方法都会被构造函数的实例所继承。</p></blockquote><p>构造函数的继承是通过new关键字，生成实例完成的。使用new关键字生成实例的过程中，就会把this绑定到实例上，具体过程如下：</p><ol><li><p>在内存中先生成一个object的实例对象，</p></li><li><p>将实例对象的_proto_指向构造函数的prototype（即构造函数的原型），</p></li><li><p>运行构造函数，</p></li><li><p>检查返回值，如果返回值为基本数据类型，则无视该返回值，而将生成的对象返回。如果为引用类型，则将该返回值返回。</p></li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">,</span> <span class="token string">"green"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>  SuperType<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">'ykx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'yellow'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Subtype</span><span class="token punctuation">(</span><span class="token string">'lhd'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span></code></pre><blockquote><p>优点：</p><p>1、实例化子类型的时候可以传参</p><p>2、父类型中的属性不会变为公共的属性</p><p>缺点：虽然构造函数实现继承的方式比较好用，但是并不推荐这种方式。构造函数继承存在内存浪费的情况，每生成一个实例，都会占用一些内存。</p></blockquote><h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><p>寄生式继承有点类似与工厂模式，即仅创建一个封装继承过程的函数，该函数在函数内部使用某种方式增强对象，最后再返回一个对象。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">inhertprototype</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> child <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">creata</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span>  child<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> child<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> Person <span class="token operator">=</span> <span class="token punctuation">{</span>    age<span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token keyword">var</span> boy <span class="token operator">=</span> <span class="token function">inhertprototype</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span><span class="token punctuation">;</span>boy<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>使用寄生式继承来为对象添加函数，不能够使函数得到更多的复用，降低了效率，类似于构造函数。</p><h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Man</span><span class="token punctuation">(</span>age<span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>eat <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>something<span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">+</span> <span class="token string">'岁的'</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">'正在吃: '</span> <span class="token operator">+</span> something<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>Man<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>drink <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>something<span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">'正在喝:'</span> <span class="token operator">+</span> something<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Boy</span><span class="token punctuation">(</span>age<span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>   Man<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>age<span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//组合继承</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**不推荐使用 Boy.prototype = new Man();//组合继承因为在JavaScript中没有显式的constructor，所以使用new关键字实例化的时候 该函数会被调用一次*/</span><span class="token keyword">function</span> inhertprototype <span class="token punctuation">(</span>child<span class="token punctuation">,</span>parent<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>  prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> child<span class="token punctuation">;</span>  child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Boy.prototype = Object.create(Man.prototype);</span><span class="token comment" spellcheck="true">//Boy.prototype.constructor = Boy;//避免原型错乱</span><span class="token function">inhertprototype</span><span class="token punctuation">(</span>Boy<span class="token punctuation">,</span>Man<span class="token punctuation">)</span><span class="token keyword">var</span> boy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boy</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token string">'ykx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>boy<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>boy<span class="token punctuation">.</span><span class="token function">drink</span><span class="token punctuation">(</span><span class="token string">'water'</span><span class="token punctuation">)</span></code></pre><p>原型错乱：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  SuperType<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span>Sub<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>SuperType<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>Sub<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>结果如下：</p><p><img src="http://cdn.yangkunxiao.cn/prototypeError.jpg" alt="原型错乱"></p><p>正确的继承结果应该如下：</p><p><img src="http://cdn.yangkunxiao.cn/prototypeRight.jpg" alt="原型正常"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript数据类型</title>
      <link href="/2019/11/21/JavaScript/dataType/"/>
      <url>/2019/11/21/JavaScript/dataType/</url>
      
        <content type="html"><![CDATA[<p>JavaScript中有一下七种数据类型：Number、String、Null、Undefined、Bool、Object以及Symbal。</p><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>Number、String、Null、Undefined、Bool。<br>JavaScript的基本数据类型的访问是按值访问的，因为基本数据类型的值是保存在栈中的。</p><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>Object、Function、Array等。<br>JavaScript的引用数据类型的访问是按引用访问的，引用数据类型的值是存放在栈和堆中的：指针存放在栈中，值存放在堆中。栈区内存保存变量标识符和指向堆内存中该对象的指针，也可以说是该对象在堆内存的地址。</p><h4 id="数据类型的区分"><a href="#数据类型的区分" class="headerlink" title="数据类型的区分"></a>数据类型的区分</h4><ol><li>typeof 检查</li></ol><pre class=" language-bash"><code class="language-bash">typeof   123　　 //Numbertypeof   <span class="token string">'abc'</span>　　//Stringtypeof    <span class="token boolean">true</span>       //Booleantypeof    undefined   //Undefinedtypeof    null        //Object     typeof    <span class="token punctuation">{</span> <span class="token punctuation">}</span>           //Objecttypeof    <span class="token punctuation">[</span> <span class="token punctuation">]</span>           //Objecttypeof    console.log<span class="token punctuation">(</span><span class="token punctuation">)</span>       //Function</code></pre><p>可以看出 typeof 是检查不出来 null、{} 、[] 的。<br>推荐使用一下方法：</p><pre class=" language-bash"><code class="language-bash">判断基本类型：Object.prototype.toString.call<span class="token punctuation">(</span>null<span class="token punctuation">)</span> //<span class="token string">"[object Null]"</span>Object.prototype.toString.call<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> //<span class="token string">"[object Array]"</span>Object.prototype.toString.call<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> //<span class="token string">"[object Object]"</span>Object.prototype.toString.call<span class="token punctuation">(</span>123<span class="token punctuation">)</span> //<span class="token string">"[object Number]"</span>Object.prototype.toString.call<span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span> //<span class="token string">"[object String]"</span>Object.prototype.toString.call<span class="token punctuation">(</span>undefined<span class="token punctuation">)</span> //<span class="token string">"[object Undefined]"</span>Object.prototype.toString.call<span class="token punctuation">(</span>true<span class="token punctuation">)</span> //<span class="token string">"[object Boolean]"</span>判断引用类型：Function fn<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console.log<span class="token punctuation">(</span>“test”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Object.prototype.toString.call<span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>//<span class="token string">"[object Function]"</span>var <span class="token function">date</span> <span class="token operator">=</span> new Date<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Object.prototype.toString.call<span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>//<span class="token string">"[object Date]"</span>var reg <span class="token operator">=</span> /<span class="token punctuation">[</span>hbc<span class="token punctuation">]</span>at/gi<span class="token punctuation">;</span>Object.prototype.toString.call<span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>//<span class="token string">"[object RegExp]"</span></code></pre><h4 id="数据包装类型"><a href="#数据包装类型" class="headerlink" title="数据包装类型"></a>数据包装类型</h4><p>数据包装类型包含：Number、String、Boolean。数据包装类型是特殊的引用类型，每当创建一个基本数据类型的时候，就会在后台创建一个对应的数据包装类型对象，用来使基本数据类型可以访问对象上的方法和属性。<br>举个🌰：</p><pre class=" language-bash"><code class="language-bash">var str <span class="token operator">=</span> <span class="token string">'123'</span><span class="token punctuation">;</span>str.split<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//后台创建对应的数据包装类型var str <span class="token operator">=</span> new String<span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span>//创建str对象str.split<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//执行方法str <span class="token operator">=</span> null//销毁str</code></pre><p>而且，通过构造函数和对象字面量创建的对象是不一样的：</p><pre class=" language-bash"><code class="language-bash">var str <span class="token operator">=</span> <span class="token string">'123'</span><span class="token punctuation">;</span>typeof str // stringvar str1 <span class="token operator">=</span> new String<span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>typeof str1 // object</code></pre><p>其他的 Boolean 和 Number 也和 String 类似。</p><h4 id="为什么使用Object-prototype-toString-call"><a href="#为什么使用Object-prototype-toString-call" class="headerlink" title="为什么使用Object.prototype.toString.call()?"></a>为什么使用Object.prototype.toString.call()?</h4><p>因为toString方法是Object原型上的方法，而Array、function等类型作为Object的实例，都重写了toString方法。不同的对象的调用toString方法的时候，调用的都是重写的toString方法，而不是Object原型链上的方法。所以如果要得到对象的具体的类型，需要调用Object原型上的toString方法，即使用call将toString的this指向改变。</p><pre class=" language-bash"><code class="language-bash">var fun <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    alert<span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>fun.toString<span class="token punctuation">(</span><span class="token punctuation">))</span>//返回的是 函数的字符串形式delete Function.prototype.toString<span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>fun.toString<span class="token punctuation">(</span><span class="token punctuation">))</span>// 返回的是<span class="token punctuation">[</span>object Function<span class="token punctuation">]</span></code></pre><p>因为删除了Function.prototype上的toString方法之后，根据原型链，它会沿着原型链查找到Object.prototype.toString方法</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决多图片压缩上传和iOS端图片上传选择90度的问题</title>
      <link href="/2019/11/20/JavaScript/multiImageUpload/"/>
      <url>/2019/11/20/JavaScript/multiImageUpload/</url>
      
        <content type="html"><![CDATA[<p>逻辑思路：<br>1、监听input文件值的change事件<br>2、获取文件列表<br>3、使用FileReader()函数读取图片信息，并转为base64格式<br>4、根据预设的阀值，判断是否压缩<br>5、如果不压缩，将图片转为blob格式，使用FormData()函数，上传图片<br>6、如果压缩图片，使用canvas重新绘制图片，根据需要，选择是否使用瓦片canvas<br>7、使用Exif.js，获取图片方向信息，确定是否需要使用canvas的rotate()函数进行旋转图片<br>8、上传图片</p><h4 id="自定义图片上传组件："><a href="#自定义图片上传组件：" class="headerlink" title="自定义图片上传组件："></a>自定义图片上传组件：</h4><pre class=" language-bash"><code class="language-bash">//推荐<span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">'file'</span> id<span class="token operator">=</span><span class="token string">'upload'</span> accept<span class="token operator">=</span><span class="token string">'image/gif,image/jpeg,image/png,image/jpg'</span> @change<span class="token operator">=</span><span class="token string">'upload'</span> <span class="token operator">></span>//不推荐使用下面这种方法，该形式在Chrome浏览器中，选择文件弹框会滞留一段时间才弹出<span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">'file'</span> name<span class="token operator">=</span><span class="token string">'file'</span> class<span class="token operator">=</span><span class="token string">'element'</span> accept<span class="token operator">=</span><span class="token string">'image/*'</span><span class="token operator">></span></code></pre><h4 id="引入exif-js"><a href="#引入exif-js" class="headerlink" title="引入exif.js"></a>引入exif.js</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> Exif from <span class="token string">'exif-js'</span></code></pre><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><pre class=" language-bash"><code class="language-bash">upload<span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> files <span class="token operator">=</span> e.target.files <span class="token operator">||</span> e.dataTransfer.files<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>files.length<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    this.picValue <span class="token operator">=</span> files<span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token punctuation">;</span>    this.imgPreview<span class="token punctuation">(</span>this.picValue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>,//图片预览、处理、上传imgPreview<span class="token punctuation">(</span>file<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> self <span class="token operator">=</span> this<span class="token punctuation">;</span>    <span class="token keyword">let</span> Orientation<span class="token punctuation">;</span>    //去获取拍照时的信息，解决拍出来的照片旋转问题    Exif.getData<span class="token punctuation">(</span>file, function<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Orientation <span class="token operator">=</span> Exif.getTag<span class="token punctuation">(</span>this, <span class="token string">'Orientation'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    // alert<span class="token punctuation">(</span>Orientation,<span class="token string">'console.log(Orientation)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    debugger    // 看支持不支持FileReader    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>file <span class="token operator">||</span> <span class="token operator">!</span>window.FileReader<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    // alert<span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>    // 创建一个reader    <span class="token keyword">let</span> reader <span class="token operator">=</span> new FileReader<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    // 将图片2将转成 base64 格式    reader.readAsDataURL<span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>    // 读取成功后的回调    reader.onloadend <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> result <span class="token operator">=</span> this.result<span class="token punctuation">;</span>        <span class="token keyword">let</span> img <span class="token operator">=</span> new Image<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        img.onload <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> data <span class="token operator">=</span> self.compress<span class="token punctuation">(</span>img, Orientation<span class="token punctuation">)</span><span class="token punctuation">;</span>            /*self.headerImage <span class="token operator">=</span> data<span class="token punctuation">;</span>  */            var blob <span class="token operator">=</span> self.dataURItoBlob<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>            var fd <span class="token operator">=</span> new FormData<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            fd.append<span class="token punctuation">(</span><span class="token string">"file"</span>, blob, <span class="token string">'image.png'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            fd.fileName <span class="token operator">=</span> blob<span class="token punctuation">;</span>            console.log<span class="token punctuation">(</span>fd, <span class="token string">'fd'</span><span class="token punctuation">)</span>            axios.post<span class="token punctuation">(</span><span class="token string">'/sunrise-gateway/oss/ossUpload'</span>, fd<span class="token punctuation">)</span>.then<span class="token punctuation">((</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> res            <span class="token punctuation">}</span><span class="token punctuation">)</span>.then<span class="token punctuation">((</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                console.log<span class="token punctuation">(</span>res, <span class="token string">'res'</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>res.data.code <span class="token operator">==</span> <span class="token string">'000000'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    self.list.push<span class="token punctuation">(</span><span class="token punctuation">..</span>.res.data.data<span class="token punctuation">)</span><span class="token punctuation">;</span>                    self.objUrl <span class="token operator">=</span> res.data.data<span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token punctuation">;</span>                    self.picNum++<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    MessageBox.alert<span class="token punctuation">(</span><span class="token string">'上传失败0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                Indicator.close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>.catch<span class="token punctuation">((</span>err<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                Indicator.close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                MessageBox.alert<span class="token punctuation">(</span><span class="token string">'上传失败1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>            // alert<span class="token punctuation">(</span>blob<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        img.src <span class="token operator">=</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>,//base64转blobdataURItoBlob<span class="token punctuation">(</span>base64Data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    var byteString<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>base64Data.split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">[</span>0<span class="token punctuation">]</span>.indexOf<span class="token punctuation">(</span><span class="token string">'base64'</span><span class="token punctuation">)</span> <span class="token operator">>=</span> 0<span class="token punctuation">)</span> <span class="token punctuation">{</span>        byteString <span class="token operator">=</span> atob<span class="token punctuation">(</span>base64Data.split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        byteString <span class="token operator">=</span> unescape<span class="token punctuation">(</span>base64Data.split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    var mimeString <span class="token operator">=</span> base64Data.split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">[</span>0<span class="token punctuation">]</span>.split<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">)</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>.split<span class="token punctuation">(</span><span class="token string">';'</span><span class="token punctuation">)</span><span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token punctuation">;</span>    var ia <span class="token operator">=</span> new Uint8Array<span class="token punctuation">(</span>byteString.length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>var i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> byteString.length<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ia<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> byteString.charCodeAt<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> new Blob<span class="token punctuation">(</span><span class="token punctuation">[</span>ia<span class="token punctuation">]</span>, <span class="token punctuation">{</span>        type: mimeString    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>,//图片旋转rotateImg<span class="token punctuation">(</span>img, direction, canvas<span class="token punctuation">)</span> <span class="token punctuation">{</span>    //最小与最大旋转方向，图片旋转4次后回到原方向    const min_step <span class="token operator">=</span> 0<span class="token punctuation">;</span>    const max_step <span class="token operator">=</span> 3<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>img <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    //img的高度和宽度不能在img元素隐藏后获取，否则会出错    <span class="token keyword">let</span> height <span class="token operator">=</span> img.height<span class="token punctuation">;</span>    <span class="token keyword">let</span> width <span class="token operator">=</span> img.width<span class="token punctuation">;</span>    <span class="token keyword">let</span> step <span class="token operator">=</span> 2<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>step <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        step <span class="token operator">=</span> min_step<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>direction <span class="token operator">==</span> <span class="token string">'right'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        step++<span class="token punctuation">;</span>        //旋转到原位置，即超过最大值        step <span class="token operator">></span> max_step <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>step <span class="token operator">=</span> min_step<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        step--<span class="token punctuation">;</span>        step <span class="token operator">&lt;</span> min_step <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>step <span class="token operator">=</span> max_step<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    //旋转角度以弧度值为参数    <span class="token keyword">let</span> degree <span class="token operator">=</span> step * 90 * Math.PI / 180<span class="token punctuation">;</span>    <span class="token keyword">let</span> ctx <span class="token operator">=</span> canvas.getContext<span class="token punctuation">(</span><span class="token string">'2d'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    switch <span class="token punctuation">(</span>step<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> 0:            canvas.width <span class="token operator">=</span> width<span class="token punctuation">;</span>            canvas.height <span class="token operator">=</span> height<span class="token punctuation">;</span>            ctx.drawImage<span class="token punctuation">(</span>img, 0, 0<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> 1:            canvas.width <span class="token operator">=</span> height<span class="token punctuation">;</span>            canvas.height <span class="token operator">=</span> width<span class="token punctuation">;</span>            ctx.rotate<span class="token punctuation">(</span>degree<span class="token punctuation">)</span><span class="token punctuation">;</span>            ctx.drawImage<span class="token punctuation">(</span>img, 0, -height<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> 2:            canvas.width <span class="token operator">=</span> width<span class="token punctuation">;</span>            canvas.height <span class="token operator">=</span> height<span class="token punctuation">;</span>            ctx.rotate<span class="token punctuation">(</span>degree<span class="token punctuation">)</span><span class="token punctuation">;</span>            ctx.drawImage<span class="token punctuation">(</span>img, -width, -height<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> 3:            canvas.width <span class="token operator">=</span> height<span class="token punctuation">;</span>            canvas.height <span class="token operator">=</span> width<span class="token punctuation">;</span>            ctx.rotate<span class="token punctuation">(</span>degree<span class="token punctuation">)</span><span class="token punctuation">;</span>            ctx.drawImage<span class="token punctuation">(</span>img, -width, 0<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>,//图片压缩compress<span class="token punctuation">(</span>img, Orientation<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> canvas <span class="token operator">=</span> document.createElement<span class="token punctuation">(</span><span class="token string">'canvas'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> ctx <span class="token operator">=</span> canvas.getContext<span class="token punctuation">(</span><span class="token string">'2d'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    //瓦片canvas    <span class="token keyword">let</span> tCanvas <span class="token operator">=</span> document.createElement<span class="token punctuation">(</span><span class="token string">'canvas'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> tctx <span class="token operator">=</span> tCanvas.getContext<span class="token punctuation">(</span><span class="token string">'2d'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> initSize <span class="token operator">=</span> img.src.length<span class="token punctuation">;</span>    <span class="token keyword">let</span> width <span class="token operator">=</span> img.width<span class="token punctuation">;</span>    <span class="token keyword">let</span> height <span class="token operator">=</span> img.height<span class="token punctuation">;</span>    //如果图片大于四百万像素，计算压缩比并将大小压至400万以下    <span class="token keyword">let</span> ratio<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">((</span>ratio <span class="token operator">=</span> width * height / 4000000<span class="token punctuation">)</span> <span class="token operator">></span> 1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        // console.log<span class="token punctuation">(</span><span class="token string">'大于400万像素'</span><span class="token punctuation">)</span>        ratio <span class="token operator">=</span> Math.sqrt<span class="token punctuation">(</span>ratio<span class="token punctuation">)</span><span class="token punctuation">;</span>        width /<span class="token operator">=</span> ratio<span class="token punctuation">;</span>        height /<span class="token operator">=</span> ratio<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        ratio <span class="token operator">=</span> 1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    canvas.width <span class="token operator">=</span> width<span class="token punctuation">;</span>    canvas.height <span class="token operator">=</span> height<span class="token punctuation">;</span>    //铺底色    ctx.fillStyle <span class="token operator">=</span> <span class="token string">'#fff'</span><span class="token punctuation">;</span>    ctx.fillRect<span class="token punctuation">(</span>0, 0, canvas.width, canvas.height<span class="token punctuation">)</span><span class="token punctuation">;</span>    //如果图片像素大于100万则使用瓦片绘制    <span class="token keyword">let</span> count<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">((</span>count <span class="token operator">=</span> width * height / 1000000<span class="token punctuation">)</span> <span class="token operator">></span> 1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        // console.log<span class="token punctuation">(</span><span class="token string">'超过100W像素'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        count <span class="token operator">=</span> ~~<span class="token punctuation">(</span>Math.sqrt<span class="token punctuation">(</span>count<span class="token punctuation">)</span> + 1<span class="token punctuation">)</span><span class="token punctuation">;</span> //计算要分成多少块瓦片        //计算每块瓦片的宽和高        <span class="token keyword">let</span> nw <span class="token operator">=</span> ~~<span class="token punctuation">(</span>width / count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> nh <span class="token operator">=</span> ~~<span class="token punctuation">(</span>height / count<span class="token punctuation">)</span><span class="token punctuation">;</span>        tCanvas.width <span class="token operator">=</span> nw<span class="token punctuation">;</span>        tCanvas.height <span class="token operator">=</span> nh<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>let i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>let j <span class="token operator">=</span> 0<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> j++<span class="token punctuation">)</span> <span class="token punctuation">{</span>                tctx.drawImage<span class="token punctuation">(</span>img, i * nw * ratio, j * nh * ratio, nw * ratio, nh * ratio, 0, 0, nw, nh<span class="token punctuation">)</span><span class="token punctuation">;</span>                ctx.drawImage<span class="token punctuation">(</span>tCanvas, i * nw, j * nh, nw, nh<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        ctx.drawImage<span class="token punctuation">(</span>img, 0, 0, width, height<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    //修复ios上传图片的时候 被旋转的问题    <span class="token keyword">if</span> <span class="token punctuation">(</span>Orientation <span class="token operator">!=</span> <span class="token string">''</span> <span class="token operator">&amp;&amp;</span> Orientation <span class="token operator">!=</span> 1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        switch <span class="token punctuation">(</span>Orientation<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> 6: //需要顺时针（向左）90度旋转                this.rotateImg<span class="token punctuation">(</span>img, <span class="token string">'left'</span>, canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> 8: //需要逆时针（向右）90度旋转                this.rotateImg<span class="token punctuation">(</span>img, <span class="token string">'right'</span>, canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> 3: //需要180度旋转                this.rotateImg<span class="token punctuation">(</span>img, <span class="token string">'right'</span>, canvas<span class="token punctuation">)</span><span class="token punctuation">;</span> //转两次                this.rotateImg<span class="token punctuation">(</span>img, <span class="token string">'right'</span>, canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    //进行最小压缩        <span class="token keyword">let</span> ndata <span class="token operator">=</span> canvas.toDataURL<span class="token punctuation">(</span><span class="token string">'image/jpeg'</span>, 0.1<span class="token punctuation">)</span><span class="token punctuation">;</span>    tCanvas.width <span class="token operator">=</span> tCanvas.height <span class="token operator">=</span> canvas.width <span class="token operator">=</span> canvas.height <span class="token operator">=</span> 0<span class="token punctuation">;</span>    <span class="token keyword">return</span> ndata<span class="token punctuation">;</span><span class="token punctuation">}</span>,</code></pre><p>备注：<br>canvas.toDataURL() 方法返回一个包含图片展示的 data URI 。可以使用 type 参数其类型，默认为 image/png 格式。图片的分辨率为96dpi。</p><p>在指定图片格式为 image/jpeg 或 image/webp的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92。其他参数会被忽略。</p><p>返回值：包含dataURI的DOMString。</p><p> DataURI格式：data:[<mediatype>][;base64],<data>。其中mediatype声明了文件类型，遵循MIME规则，如“image/png”、“text/plain”；之后是编码类型，这里我们只涉及 base64；紧接着就是文件编码后的内容了。</p><p>URI（Uniform Resource Identifier）:统一资源标识符,服务器资源名被称为统一资源标识符.如：<code>img src=&#39;images/image.png&#39;</code></p><p>URL（Uniform Resource Locator）:统一资源定位符，描述了一台特定服务器上某资源的特定位置。如:</p><pre><code>img src=&#39;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAWCAYAAAArdgcFAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAACXBIWXMAAAsTAAALEwEAmpwYAAABSUlEQVQ4Ee1VPUsDQRB9s3dBRCRNQvCjkDQW/hJ/gb9AOwWDoIXFgYXYXGP+hYW1/gIr7WzsE8VGxZBcwt04dznCJWw2twtWutXMmzdvlrd7t4SZVbvi1ZihZuCFqT9A/B7Qd5FI44RpPcQpE1oC1IsEq5jRBeGyc0zXaV8mvhbyOREurIRMZMZhp0VthYB9mXBi4jrUztIev1bNbKg6CMxvIWwg5GWVDOHNZ7lX6l/wrG+Fzbh/ca1bf9QWBhKtHznobgtjKF92ZBL3TUWpRbK7LhiVCY8kY3xK/iTiexNcEywSXxKBrfHvrdBN2JRsp4BoQ3dbtHLT4K+JqxWw8vr4YDaf+vR+SmXRWw99lT9N96VaypIYtwgoyWyJRtiX3T+X7TXxROcxGeAo5chlyNcBVxrb2JVpTUHsz4IQi/DL6wPucENxqvoDx69PXP8OKn4AAAAASUVORK5CYII=&#39;/</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac开启本地服务器</title>
      <link href="/2019/11/20/Other/server/"/>
      <url>/2019/11/20/Other/server/</url>
      
        <content type="html"><![CDATA[<h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>是一个高性能的HTTP和反向代理服务器，同时也是一个 IMAP/POP3/SMTP 代理服务器。</p><pre class=" language-bash"><code class="language-bash">安装：搜索软件：brew search nginx安装软件：brew <span class="token function">install</span> nginx卸载软件：brew uninstall nginx升级brew：sudo brew update查看安装信息：sudo brew info nginx查看已经安装的软件：brew list</code></pre><p>nginx常用命令：</p><pre class=" language-bash"><code class="language-bash">nginx -v //查看下安装好的nginx版本<span class="token function">sudo</span> nginx  // 启动nginx<span class="token function">sudo</span> nginx              //启动nginx<span class="token function">sudo</span> nginx -s reload    //修改配置后重新加载生效<span class="token comment" spellcheck="true">#简单解释下，上面这种方法重启，nginx在重启的时候不会中断服务，因为  nginx在启动后，会有一个master进程和多个worker进程，重启是会先生成新的worker进程去接受reload命令，等老的worker进程执行完毕，master进程在关闭他们，所以服务器不会中断。</span><span class="token function">sudo</span> nginx -s  reopen   //重新打开日志文件<span class="token function">sudo</span> nginx -s stop  //快速停止nginx<span class="token function">sudo</span> nginx -s quit  //完整有序的停止nginx<span class="token function">sudo</span> nginx -t     //测试当前配置文件是否正确</code></pre><p>nginx常见目录：</p><pre class=" language-bash"><code class="language-bash">/usr/local/Cellar/  <span class="token comment" spellcheck="true">#nginx默认安装的目录,所有使用brew安装的软件默认都在这里</span>/usr/local/Cellar/nginx/1.8.0/html  ＃默认的访问目录，就是我们说的网站根目录/usr/local/etc/nginx/     <span class="token comment" spellcheck="true"># nginx.conf所在的目录</span>修改默认路径从nginx/html改成你自己放置代码的路径vim /usr/local/etc/nginx/nginx.conf</code></pre><p>接下来的任务就很明确了，把listen 80下面的两个 root html中的路径，改成我们自己放代码的文件夹。例如在桌面下面新建一个home的文件夹，再在目录下新建一个www的文件夹，那么路径就是：桌面:homewww，把task1.html放进去，然后修改配置修改完成后，点击Esc键<code>·shift+: 输入：wq</code>，保存修改。</p><h4 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h4><p>打开终端，开启Apache:</p><pre class=" language-bash"><code class="language-bash">//开启apache:  <span class="token function">sudo</span> apachectl start//重启apache:  <span class="token function">sudo</span> apachectl restart//关闭apache:  <span class="token function">sudo</span> apachectl stop//查看apache版本 <span class="token function">sudo</span> apachectl -v</code></pre><p>回车会提示输入密码，也就是你电脑的密码，<a href="http://127.0.0.1/测试一下。" target="_blank" rel="noopener">http://127.0.0.1/测试一下。</a><br>点击Finder,然后Command+Shift+G,前往Apache服务器的文件路径(/Library/WebServer/Documents)，在步骤1中只输入一个<a href="http://127.0.0.1其实默认打开的是index.html.en(html是一个网页文件)，该文件的内容就是在步骤1中测试时浏览器所显示的内容" target="_blank" rel="noopener">http://127.0.0.1其实默认打开的是index.html.en(html是一个网页文件)，该文件的内容就是在步骤1中测试时浏览器所显示的内容</a></p>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue使用webpack优化构建流程</title>
      <link href="/2019/11/20/Vue/webpack%E6%9E%84%E5%BB%BA/"/>
      <url>/2019/11/20/Vue/webpack%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>初衷：如果我们的 Vue 项目比较大．或者说项目中引入了许多第三方库，那么在执行 npm run build 构建项目的时候会极其的慢．比如我现在的项目就每次打包就要 83s。<br>下面提供一些方法用来提供优化打包速度：</p><h4 id="resolve-modules"><a href="#resolve-modules" class="headerlink" title="resolve.modules"></a>resolve.modules</h4><p>思路：webpack 的 resolve.modules 是用来配置模块库（即 node_modules）所在的位置。当 js 里出现 import ‘vue’ 这样不是相对、也不是绝对路径的写法时，它便会到 node_modules 目录下去找。在默认配置下，webpack 会采用向上递归搜索的方式去寻找。但通常项目目录里只有一个 node_modules，且是在项目根目录。为了减少搜索范围，可我们以直接写明 node_modules 的全路径。</p><pre><code>打开 build/webpack.base.conf.js 文件，添加如下配置：module.exports = {  resolve: {    extensions: [&#39;.js&#39;, &#39;.vue&#39;, &#39;.json&#39;],    modules: [      resolve(&#39;src&#39;),      resolve(&#39;node_modules&#39;)    ],    alias: {      &#39;vue$&#39;: &#39;vue/dist/vue.esm.js&#39;,      &#39;@&#39;: resolve(&#39;src&#39;),    }  },</code></pre><h4 id="webpack-parallel-uglify-plugin"><a href="#webpack-parallel-uglify-plugin" class="headerlink" title="webpack-parallel-uglify-plugin"></a>webpack-parallel-uglify-plugin</h4><p>原理：webpack默认提供了UglifyJS插件来压缩JS代码，但是它使用的是单线程压缩代码，也就是说多个js文件需要被压缩，它需要一个个文件进行压缩。所以说在正式环境打包压缩代码速度非常慢(因为压缩JS代码需要先把代码解析成用Object抽象表示的AST语法树，再去应用各种规则分析和处理AST，导致这个过程耗时非常大)。源码：</p><pre><code>module.exports = {  plugins: [    new webpack.optimize.UglifyJsPlugin({      sourceMap: true,      compress: {        warnings: false      }    }),  ]}</code></pre><p>我们可以改用 webpack-parallel-uglify-plugin 插件，它可以并行运行 UglifyJS 插件，从而更加充分、合理的使用 CPU 资源，从而大大减少构建时间。<br>当webpack有多个JS文件需要输出和压缩时候，原来会使用UglifyJS去一个个压缩并且输出，但是ParallelUglifyPlugin插件则会开启多个子进程，把对多个文件压缩的工作分别给多个子进程去完成，但是每个子进程还是通过UglifyJS去压缩代码。无非就是变成了并行处理该压缩了，并行处理多个子任务，效率会更高。</p><pre><code>安装：npm i webpack-parallel-uglify-plugin打开 build/webpack.prod.conf.js 文件，并作如下修改：const ParallelUglifyPlugin = require(&#39;webpack-parallel-uglify-plugin&#39;);// 删掉webpack提供的UglifyJS插件    //new UglifyJsPlugin({    //  uglifyOptions: {    //    compress: {    //      warnings: false    //    }    //  },    //  sourceMap: config.build.productionSourceMap,    //  parallel: true    //}),    // 增加 webpack-parallel-uglify-plugin来替换    new ParallelUglifyPlugin({      cacheDir: &#39;.cache/&#39;,      uglifyJS:{        output: {          comments: false        },        compress: {          warnings: false,          drop_debugger: true,          drop_console: true        }      }    }),</code></pre><h4 id="HappyPack"><a href="#HappyPack" class="headerlink" title="HappyPack"></a>HappyPack</h4><p>原理：由于运行在 Node.js 之上的 Webpack 是单线程模型的，所以 Webpack 需要处理的事情只能一件一件地做，不能多件事一起做。而 HappyPack 的处理思路是：将原有的 webpack 对 loader 的执行过程，从单一进程的形式扩展多进程模式，从而加速代码构建。</p><pre><code>安装：npm i happypack打开 build/webpack.base.conf.js 文件，并作如下修改：const HappyPack = require(&#39;happypack&#39;);const os = require(&#39;os&#39;);const happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length });module.exports = {  module: {    rules: [      {        test: /.js$/,        //把对.js 的文件处理交给id为happyBabel 的HappyPack 的实例执行        loader: &#39;happypack/loader?id=happyBabel&#39;,        include: [resolve(&#39;src&#39;)],        //排除node_modules 目录下的文件        exclude: /node_modules/      },    ]  },  plugins: [    new HappyPack({        //用id来标识 happypack处理那里类文件      id: &#39;happyBabel&#39;,      //如何处理  用法和loader 的配置一样      loaders: [{        loader: &#39;babel-loader?cacheDirectory=true&#39;,      }],      //共享进程池      threadPool: happyThreadPool,      //允许 HappyPack 输出日志      verbose: true,    })  ]}</code></pre><h4 id="DllPlugin-和-DllReferencePlugin"><a href="#DllPlugin-和-DllReferencePlugin" class="headerlink" title="DllPlugin 和 DllReferencePlugin"></a>DllPlugin 和 DllReferencePlugin</h4><p>原理：我们的项目依赖中通常会引用大量的 npm 包，而这些包在正常的开发过程中并不会进行修改，但是在每一次构建过程中却需要反复的将其解析，而下面介绍的两个插件就是用来规避此类损耗的：<br>DllPlugin 插件：作用是预先编译一些模块。<br>DllReferencePlugin 插件：它的所用则是把这些预先编译好的模块引用起来。<br>注意：DllPlugin 必须要在 DllReferencePlugin 执行前先执行一次。</p><pre><code>1、在 build 文件夹中新建 webpack.dll.conf.js 文件，内容如下（主要是配置下需要提前编译打包的库）：const path = require(&#39;path&#39;);const webpack = require(&#39;webpack&#39;);module.exports = {  entry: {    vendor: [&#39;vue/dist/vue.common.js&#39;,            &#39;vue-router&#39;,            &#39;axios&#39;,            &#39;vuex&#39;,            &#39;element-ui&#39;]  },  output: {    path: path.join(__dirname, &#39;../static/js&#39;),    filename: &#39;[name].dll.js&#39;,    library: &#39;[name]_library&#39;       // vendor.dll.js中暴露出的全局变量名  },  plugins: [    new webpack.DllPlugin({      path: path.join(__dirname, &#39;.&#39;, &#39;[name]-manifest.json&#39;),      name: &#39;[name]_library&#39;    }),    new webpack.optimize.UglifyJsPlugin({      compress: {        warnings: false      }    })  ]};2、编辑 package.json 文件，添加一条编译命令：    dll: webpack --config webpack.dll.conf.js接着执行 npm run dll 命令来生成 vendor.dll.js。注意：如果之后这些需要预编译的库又有变动，则需再次执行 npm run dll 命令来重新生成 vendor.dll.js3、index.html 这边将 vendor.dll.js 引入进来：&lt;script src=‘./static/js/vendor.dll.js’&gt;&lt;/script&gt;4、打开 build/webpack.base.conf.js 文件，编辑添加如下高亮配置，作用是通过 DLLReferencePlugin 来使用 DllPlugin 生成的 DLL Bundle。const webpack = require(&#39;webpack&#39;);module.exports = {  context: path.resolve(__dirname, &#39;../&#39;),  entry: {    app: &#39;./src/main.js&#39;  },  //.....  plugins: [     // 添加DllReferencePlugin插件     new webpack.DllReferencePlugin({       context: path.resolve(__dirname, &#39;..&#39;),       manifest: require(&#39;./vendor-manifest.json&#39;)     }),  ]}</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
