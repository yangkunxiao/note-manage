<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL自然连接查询</title>
      <link href="/2019/11/20/Mysql/naturalJoin/"/>
      <url>/2019/11/20/Mysql/naturalJoin/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是自然连接？"><a href="#什么是自然连接？" class="headerlink" title="什么是自然连接？"></a>什么是自然连接？</h4><p>通过mysql自己判断完成连接过程,不需要指定连接条件，mysql会根据多个表内的相同字段作为连接条件。</p><h4 id="自然连接的分类"><a href="#自然连接的分类" class="headerlink" title="自然连接的分类"></a>自然连接的分类</h4><p>自然连接分为：<strong><em>内自然连接</em></strong>（inner natural join）和 <strong><em>外自然连接</em></strong>。其中<strong><em>外自然连接</em></strong>又可分为<strong><em>左外自然连接</em></strong>（left natural join ）和 <strong><em>右外自然连接</em></strong>（right natural join）。</p><p>注意：自然连接没有判断语句！！！</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>假如存在两张表：tab1和tab2</p><ul><li><p>内自然连接</p><pre class=" language-javascript"><code class="language-javascript">select <span class="token operator">*</span> <span class="token keyword">from</span> tab1 natural join tab2<span class="token punctuation">;</span></code></pre><p>内自然连接相当于<strong>using为判断语句的内连接：</strong>即：</p><pre class=" language-javascript"><code class="language-javascript">select <span class="token operator">*</span> <span class="token keyword">from</span> tbl_name1 inner join tbl_name2 using<span class="token punctuation">;</span></code></pre></li><li><p>左外自然连接</p><pre class=" language-javascript"><code class="language-javascript">select <span class="token operator">*</span> <span class="token keyword">from</span> tab1 natural left join tab2<span class="token punctuation">;</span></code></pre><p>相当于using为判断语句的左外连接：</p><pre class=" language-javascript"><code class="language-javascript">select <span class="token operator">*</span> <span class="token keyword">from</span> tab1 left outer join tab2 using<span class="token punctuation">;</span></code></pre></li><li><p>右外自然连接</p><pre class=" language-javascript"><code class="language-javascript">select <span class="token operator">*</span> <span class="token keyword">from</span> tab1 natural right join tab2<span class="token punctuation">;</span></code></pre><p>相当于using为判断语句的右外连接：</p><pre class=" language-javascript"><code class="language-javascript">select <span class="token operator">*</span> <span class="token keyword">from</span> tab1 natural right join tab2<span class="token punctuation">;</span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决多图片压缩上传和iOS端图片上传选择90度的问题</title>
      <link href="/2019/11/20/JavaScript/multiImageUpload/"/>
      <url>/2019/11/20/JavaScript/multiImageUpload/</url>
      
        <content type="html"><![CDATA[<p>逻辑思路：<br>1、监听input文件值的change事件<br>2、获取文件列表<br>3、使用FileReader()函数读取图片信息，并转为base64格式<br>4、根据预设的阀值，判断是否压缩<br>5、如果不压缩，将图片转为blob格式，使用FormData()函数，上传图片<br>6、如果压缩图片，使用canvas重新绘制图片，根据需要，选择是否使用瓦片canvas<br>7、使用Exif.js，获取图片方向信息，确定是否需要使用canvas的rotate()函数进行旋转图片<br>8、上传图片</p><h4 id="自定义图片上传组件："><a href="#自定义图片上传组件：" class="headerlink" title="自定义图片上传组件："></a>自定义图片上传组件：</h4><pre class=" language-bash"><code class="language-bash">//推荐<span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">'file'</span> id<span class="token operator">=</span><span class="token string">'upload'</span> accept<span class="token operator">=</span><span class="token string">'image/gif,image/jpeg,image/png,image/jpg'</span> @change<span class="token operator">=</span><span class="token string">'upload'</span> <span class="token operator">></span>//不推荐使用下面这种方法，该形式在Chrome浏览器中，选择文件弹框会滞留一段时间才弹出<span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">'file'</span> name<span class="token operator">=</span><span class="token string">'file'</span> class<span class="token operator">=</span><span class="token string">'element'</span> accept<span class="token operator">=</span><span class="token string">'image/*'</span><span class="token operator">></span></code></pre><h4 id="引入exif-js"><a href="#引入exif-js" class="headerlink" title="引入exif.js"></a>引入exif.js</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> Exif from <span class="token string">'exif-js'</span></code></pre><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><pre class=" language-bash"><code class="language-bash">upload<span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">let</span> files <span class="token operator">=</span> e.target.files <span class="token operator">||</span> e.dataTransfer.files<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>files.length<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>                this.picValue <span class="token operator">=</span> files<span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token punctuation">;</span>                this.imgPreview<span class="token punctuation">(</span>this.picValue<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>,            //图片预览、处理、上传            imgPreview<span class="token punctuation">(</span>file<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">let</span> self <span class="token operator">=</span> this<span class="token punctuation">;</span>                <span class="token keyword">let</span> Orientation<span class="token punctuation">;</span>                //去获取拍照时的信息，解决拍出来的照片旋转问题                Exif.getData<span class="token punctuation">(</span>file, function<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Orientation <span class="token operator">=</span> Exif.getTag<span class="token punctuation">(</span>this, <span class="token string">'Orientation'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                // alert<span class="token punctuation">(</span>Orientation,<span class="token string">'console.log(Orientation)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                debugger                // 看支持不支持FileReader                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>file <span class="token operator">||</span> <span class="token operator">!</span>window.FileReader<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>                // alert<span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>                // 创建一个reader                <span class="token keyword">let</span> reader <span class="token operator">=</span> new FileReader<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                // 将图片2将转成 base64 格式                reader.readAsDataURL<span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>                // 读取成功后的回调                reader.onloadend <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">let</span> result <span class="token operator">=</span> this.result<span class="token punctuation">;</span>                    <span class="token keyword">let</span> img <span class="token operator">=</span> new Image<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    img.onload <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">let</span> data <span class="token operator">=</span> self.compress<span class="token punctuation">(</span>img, Orientation<span class="token punctuation">)</span><span class="token punctuation">;</span>                        /*self.headerImage <span class="token operator">=</span> data<span class="token punctuation">;</span>  */                        var blob <span class="token operator">=</span> self.dataURItoBlob<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>                        var fd <span class="token operator">=</span> new FormData<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        fd.append<span class="token punctuation">(</span><span class="token string">"file"</span>, blob, <span class="token string">'image.png'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        fd.fileName <span class="token operator">=</span> blob<span class="token punctuation">;</span>                        console.log<span class="token punctuation">(</span>fd, <span class="token string">'fd'</span><span class="token punctuation">)</span>                        axios.post<span class="token punctuation">(</span><span class="token string">'/sunrise-gateway/oss/ossUpload'</span>, fd<span class="token punctuation">)</span>.then<span class="token punctuation">((</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                            <span class="token keyword">return</span> res                        <span class="token punctuation">}</span><span class="token punctuation">)</span>.then<span class="token punctuation">((</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                            console.log<span class="token punctuation">(</span>res, <span class="token string">'res'</span><span class="token punctuation">)</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>res.data.code <span class="token operator">==</span> <span class="token string">'000000'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                self.list.push<span class="token punctuation">(</span><span class="token punctuation">..</span>.res.data.data<span class="token punctuation">)</span><span class="token punctuation">;</span>                                self.objUrl <span class="token operator">=</span> res.data.data<span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token punctuation">;</span>                                self.picNum++<span class="token punctuation">;</span>                            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                                MessageBox.alert<span class="token punctuation">(</span><span class="token string">'上传失败0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                            Indicator.close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span><span class="token punctuation">)</span>.catch<span class="token punctuation">((</span>err<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                            Indicator.close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            MessageBox.alert<span class="token punctuation">(</span><span class="token string">'上传失败1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span><span class="token punctuation">)</span>                        // alert<span class="token punctuation">(</span>blob<span class="token punctuation">)</span>                    <span class="token punctuation">}</span>                    img.src <span class="token operator">=</span> result<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>,            //base64转blob            dataURItoBlob<span class="token punctuation">(</span>base64Data<span class="token punctuation">)</span> <span class="token punctuation">{</span>                var byteString<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>base64Data.split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">[</span>0<span class="token punctuation">]</span>.indexOf<span class="token punctuation">(</span><span class="token string">'base64'</span><span class="token punctuation">)</span> <span class="token operator">>=</span> 0<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    byteString <span class="token operator">=</span> atob<span class="token punctuation">(</span>base64Data.split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    byteString <span class="token operator">=</span> unescape<span class="token punctuation">(</span>base64Data.split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                var mimeString <span class="token operator">=</span> base64Data.split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">[</span>0<span class="token punctuation">]</span>.split<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">)</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>.split<span class="token punctuation">(</span><span class="token string">';'</span><span class="token punctuation">)</span><span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token punctuation">;</span>                var ia <span class="token operator">=</span> new Uint8Array<span class="token punctuation">(</span>byteString.length<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>var i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> byteString.length<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    ia<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> byteString.charCodeAt<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> new Blob<span class="token punctuation">(</span><span class="token punctuation">[</span>ia<span class="token punctuation">]</span>, <span class="token punctuation">{</span>                    type: mimeString                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>,            //图片旋转            rotateImg<span class="token punctuation">(</span>img, direction, canvas<span class="token punctuation">)</span> <span class="token punctuation">{</span>                //最小与最大旋转方向，图片旋转4次后回到原方向                const min_step <span class="token operator">=</span> 0<span class="token punctuation">;</span>                const max_step <span class="token operator">=</span> 3<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>img <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>                //img的高度和宽度不能在img元素隐藏后获取，否则会出错                <span class="token keyword">let</span> height <span class="token operator">=</span> img.height<span class="token punctuation">;</span>                <span class="token keyword">let</span> width <span class="token operator">=</span> img.width<span class="token punctuation">;</span>                <span class="token keyword">let</span> step <span class="token operator">=</span> 2<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>step <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    step <span class="token operator">=</span> min_step<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>direction <span class="token operator">==</span> <span class="token string">'right'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    step++<span class="token punctuation">;</span>                    //旋转到原位置，即超过最大值                    step <span class="token operator">></span> max_step <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>step <span class="token operator">=</span> min_step<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    step--<span class="token punctuation">;</span>                    step <span class="token operator">&lt;</span> min_step <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>step <span class="token operator">=</span> max_step<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                //旋转角度以弧度值为参数                <span class="token keyword">let</span> degree <span class="token operator">=</span> step * 90 * Math.PI / 180<span class="token punctuation">;</span>                <span class="token keyword">let</span> ctx <span class="token operator">=</span> canvas.getContext<span class="token punctuation">(</span><span class="token string">'2d'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                switch <span class="token punctuation">(</span>step<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">case</span> 0:                        canvas.width <span class="token operator">=</span> width<span class="token punctuation">;</span>                        canvas.height <span class="token operator">=</span> height<span class="token punctuation">;</span>                        ctx.drawImage<span class="token punctuation">(</span>img, 0, 0<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token keyword">case</span> 1:                        canvas.width <span class="token operator">=</span> height<span class="token punctuation">;</span>                        canvas.height <span class="token operator">=</span> width<span class="token punctuation">;</span>                        ctx.rotate<span class="token punctuation">(</span>degree<span class="token punctuation">)</span><span class="token punctuation">;</span>                        ctx.drawImage<span class="token punctuation">(</span>img, 0, -height<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token keyword">case</span> 2:                        canvas.width <span class="token operator">=</span> width<span class="token punctuation">;</span>                        canvas.height <span class="token operator">=</span> height<span class="token punctuation">;</span>                        ctx.rotate<span class="token punctuation">(</span>degree<span class="token punctuation">)</span><span class="token punctuation">;</span>                        ctx.drawImage<span class="token punctuation">(</span>img, -width, -height<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token keyword">case</span> 3:                        canvas.width <span class="token operator">=</span> height<span class="token punctuation">;</span>                        canvas.height <span class="token operator">=</span> width<span class="token punctuation">;</span>                        ctx.rotate<span class="token punctuation">(</span>degree<span class="token punctuation">)</span><span class="token punctuation">;</span>                        ctx.drawImage<span class="token punctuation">(</span>img, -width, 0<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>,            //图片压缩            compress<span class="token punctuation">(</span>img, Orientation<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> canvas <span class="token operator">=</span> document.createElement<span class="token punctuation">(</span><span class="token string">'canvas'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">let</span> ctx <span class="token operator">=</span> canvas.getContext<span class="token punctuation">(</span><span class="token string">'2d'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    //瓦片canvas                    <span class="token keyword">let</span> tCanvas <span class="token operator">=</span> document.createElement<span class="token punctuation">(</span><span class="token string">'canvas'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">let</span> tctx <span class="token operator">=</span> tCanvas.getContext<span class="token punctuation">(</span><span class="token string">'2d'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">let</span> initSize <span class="token operator">=</span> img.src.length<span class="token punctuation">;</span>                    <span class="token keyword">let</span> width <span class="token operator">=</span> img.width<span class="token punctuation">;</span>                    <span class="token keyword">let</span> height <span class="token operator">=</span> img.height<span class="token punctuation">;</span>                    //如果图片大于四百万像素，计算压缩比并将大小压至400万以下                    <span class="token keyword">let</span> ratio<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">((</span>ratio <span class="token operator">=</span> width * height / 4000000<span class="token punctuation">)</span> <span class="token operator">></span> 1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        // console.log<span class="token punctuation">(</span><span class="token string">'大于400万像素'</span><span class="token punctuation">)</span>                        ratio <span class="token operator">=</span> Math.sqrt<span class="token punctuation">(</span>ratio<span class="token punctuation">)</span><span class="token punctuation">;</span>                        width /<span class="token operator">=</span> ratio<span class="token punctuation">;</span>                        height /<span class="token operator">=</span> ratio<span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        ratio <span class="token operator">=</span> 1<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    canvas.width <span class="token operator">=</span> width<span class="token punctuation">;</span>                    canvas.height <span class="token operator">=</span> height<span class="token punctuation">;</span>                    //铺底色                    ctx.fillStyle <span class="token operator">=</span> <span class="token string">'#fff'</span><span class="token punctuation">;</span>                    ctx.fillRect<span class="token punctuation">(</span>0, 0, canvas.width, canvas.height<span class="token punctuation">)</span><span class="token punctuation">;</span>                    //如果图片像素大于100万则使用瓦片绘制                    <span class="token keyword">let</span> count<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">((</span>count <span class="token operator">=</span> width * height / 1000000<span class="token punctuation">)</span> <span class="token operator">></span> 1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        // console.log<span class="token punctuation">(</span><span class="token string">'超过100W像素'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        count <span class="token operator">=</span> ~~<span class="token punctuation">(</span>Math.sqrt<span class="token punctuation">(</span>count<span class="token punctuation">)</span> + 1<span class="token punctuation">)</span><span class="token punctuation">;</span> //计算要分成多少块瓦片                        //计算每块瓦片的宽和高                        <span class="token keyword">let</span> nw <span class="token operator">=</span> ~~<span class="token punctuation">(</span>width / count<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">let</span> nh <span class="token operator">=</span> ~~<span class="token punctuation">(</span>height / count<span class="token punctuation">)</span><span class="token punctuation">;</span>                        tCanvas.width <span class="token operator">=</span> nw<span class="token punctuation">;</span>                        tCanvas.height <span class="token operator">=</span> nh<span class="token punctuation">;</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span>let i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">for</span> <span class="token punctuation">(</span>let j <span class="token operator">=</span> 0<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> j++<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                tctx.drawImage<span class="token punctuation">(</span>img, i * nw * ratio, j * nh * ratio, nw * ratio, nh * ratio, 0, 0, nw, nh<span class="token punctuation">)</span><span class="token punctuation">;</span>                                ctx.drawImage<span class="token punctuation">(</span>tCanvas, i * nw, j * nh, nw, nh<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        ctx.drawImage<span class="token punctuation">(</span>img, 0, 0, width, height<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    //修复ios上传图片的时候 被旋转的问题                    <span class="token keyword">if</span> <span class="token punctuation">(</span>Orientation <span class="token operator">!=</span> <span class="token string">''</span> <span class="token operator">&amp;&amp;</span> Orientation <span class="token operator">!=</span> 1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        switch <span class="token punctuation">(</span>Orientation<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">case</span> 6: //需要顺时针（向左）90度旋转                                this.rotateImg<span class="token punctuation">(</span>img, <span class="token string">'left'</span>, canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token keyword">break</span><span class="token punctuation">;</span>                            <span class="token keyword">case</span> 8: //需要逆时针（向右）90度旋转                                this.rotateImg<span class="token punctuation">(</span>img, <span class="token string">'right'</span>, canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token keyword">break</span><span class="token punctuation">;</span>                            <span class="token keyword">case</span> 3: //需要180度旋转                                this.rotateImg<span class="token punctuation">(</span>img, <span class="token string">'right'</span>, canvas<span class="token punctuation">)</span><span class="token punctuation">;</span> //转两次                                this.rotateImg<span class="token punctuation">(</span>img, <span class="token string">'right'</span>, canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                    //进行最小压缩                        <span class="token keyword">let</span> ndata <span class="token operator">=</span> canvas.toDataURL<span class="token punctuation">(</span><span class="token string">'image/jpeg'</span>, 0.1<span class="token punctuation">)</span><span class="token punctuation">;</span>                    tCanvas.width <span class="token operator">=</span> tCanvas.height <span class="token operator">=</span> canvas.width <span class="token operator">=</span> canvas.height <span class="token operator">=</span> 0<span class="token punctuation">;</span>                    <span class="token keyword">return</span> ndata<span class="token punctuation">;</span>                <span class="token punctuation">}</span>,</code></pre><p>备注：<br>canvas.toDataURL() 方法返回一个包含图片展示的 data URI 。可以使用 type 参数其类型，默认为 image/png 格式。图片的分辨率为96dpi。</p><p>在指定图片格式为 image/jpeg 或 image/webp的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92。其他参数会被忽略。</p><p>返回值：包含dataURI的DOMString。</p><p> DataURI格式：data:[<mediatype>][;base64],<data>。其中mediatype声明了文件类型，遵循MIME规则，如“image/png”、“text/plain”；之后是编码类型，这里我们只涉及 base64；紧接着就是文件编码后的内容了。</p><p>URI（Uniform Resource Identifier）:统一资源标识符,服务器资源名被称为统一资源标识符.如：<code>img src=&#39;images/image.png&#39;</code></p><p>URL（Uniform Resource Locator）:统一资源定位符，描述了一台特定服务器上某资源的特定位置。如:</p><pre><code>img src=&#39;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAWCAYAAAArdgcFAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAACXBIWXMAAAsTAAALEwEAmpwYAAABSUlEQVQ4Ee1VPUsDQRB9s3dBRCRNQvCjkDQW/hJ/gb9AOwWDoIXFgYXYXGP+hYW1/gIr7WzsE8VGxZBcwt04dznCJWw2twtWutXMmzdvlrd7t4SZVbvi1ZihZuCFqT9A/B7Qd5FI44RpPcQpE1oC1IsEq5jRBeGyc0zXaV8mvhbyOREurIRMZMZhp0VthYB9mXBi4jrUztIev1bNbKg6CMxvIWwg5GWVDOHNZ7lX6l/wrG+Fzbh/ca1bf9QWBhKtHznobgtjKF92ZBL3TUWpRbK7LhiVCY8kY3xK/iTiexNcEywSXxKBrfHvrdBN2JRsp4BoQ3dbtHLT4K+JqxWw8vr4YDaf+vR+SmXRWw99lT9N96VaypIYtwgoyWyJRtiX3T+X7TXxROcxGeAo5chlyNcBVxrb2JVpTUHsz4IQi/DL6wPucENxqvoDx69PXP8OKn4AAAAASUVORK5CYII=&#39;/</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 8.0+重置密码</title>
      <link href="/2019/11/20/Mysql/resetPassWord/"/>
      <url>/2019/11/20/Mysql/resetPassWord/</url>
      
        <content type="html"><![CDATA[<h4 id="关闭数据库"><a href="#关闭数据库" class="headerlink" title="关闭数据库"></a>关闭数据库</h4><p>1、在终端中输入：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> /usr/local/mysql/support-files mysql.server stop</code></pre><p>2、在访达中找到安装好的mysql，关闭mysql运行。</p><h4 id="跳过验证"><a href="#跳过验证" class="headerlink" title="跳过验证"></a>跳过验证</h4><pre class=" language-bash"><code class="language-bash">// 进入数据库指令文件<span class="token function">cd</span> /usr/local/mysql/bin// 跳过权限认证<span class="token function">sudo</span> ./mysqld_safe --skip-grant-tables</code></pre><h4 id="免密码进入数据库"><a href="#免密码进入数据库" class="headerlink" title="免密码进入数据库"></a>免密码进入数据库</h4><p>在上述指令运行后，新开一个终端，同时保持原来那个终端也开着，在新的终端输入指令如下：</p><pre class=" language-bash"><code class="language-bash">//  执行mysql指令/usr/local/mysql/bin/mysql// 进入名为<span class="token operator">&lt;</span>mysql<span class="token operator">></span>的数据库use mysql<span class="token punctuation">;</span>把之前密码清空：update user <span class="token keyword">set</span> authentication_string<span class="token operator">=</span><span class="token string">''</span>  where user<span class="token operator">=</span><span class="token string">'root'</span><span class="token punctuation">;</span>// 刷新权限flush privileges<span class="token punctuation">;</span>// 修改密码 但不适用于8.0+的版本// <span class="token keyword">set</span> password <span class="token keyword">for</span> <span class="token string">'root'</span>@<span class="token string">'localhost'</span> <span class="token operator">=</span> password<span class="token punctuation">(</span><span class="token string">'新的密码'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>// 8.0+版本修改密码ALTER user <span class="token string">'root'</span>@<span class="token string">'localhost'</span> indentified by <span class="token string">'新密码'</span><span class="token punctuation">;</span>//刷新一下flush privileges<span class="token punctuation">;</span>// 退出mysql<span class="token keyword">exit</span></code></pre><p>mysql常用命令：</p><pre class=" language-bash"><code class="language-bash">1、进入本地数据库：/usr/local/mysql/bin/mysql -u root -p 根据提示输入密码2、进入远程数据库：假设远程主机的IP为：23.106.134.88，用户名为root,密码为123456：mysql -h23.106.134.88 -u root -p 根据提示输入密码。3、启动mysql服务：<span class="token function">sudo</span> /usr/local/mysql/support-files/mysql.server start<span class="token punctuation">;</span>4、终止mysql服务：<span class="token function">sudo</span> /usr/local/mysql/support-files/mysql.server stop<span class="token punctuation">;</span>5、重启mysql服务：<span class="token function">sudo</span> /usr/local/mysql/support-files/mysql.server restart<span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac开启本地服务器</title>
      <link href="/2019/11/20/Other/server/"/>
      <url>/2019/11/20/Other/server/</url>
      
        <content type="html"><![CDATA[<h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>是一个高性能的HTTP和反向代理服务器，同时也是一个 IMAP/POP3/SMTP 代理服务器。</p><pre class=" language-bash"><code class="language-bash">安装：搜索软件：brew search nginx安装软件：brew <span class="token function">install</span> nginx卸载软件：brew uninstall nginx升级brew：sudo brew update查看安装信息：sudo brew info nginx查看已经安装的软件：brew list</code></pre><p>nginx常用命令：</p><pre class=" language-bash"><code class="language-bash">nginx -v //查看下安装好的nginx版本<span class="token function">sudo</span> nginx  // 启动nginx<span class="token function">sudo</span> nginx              //启动nginx<span class="token function">sudo</span> nginx -s reload    //修改配置后重新加载生效<span class="token comment" spellcheck="true">#简单解释下，上面这种方法重启，nginx在重启的时候不会中断服务，因为  nginx在启动后，会有一个master进程和多个worker进程，重启是会先生成新的worker进程去接受reload命令，等老的worker进程执行完毕，master进程在关闭他们，所以服务器不会中断。</span><span class="token function">sudo</span> nginx -s  reopen   //重新打开日志文件<span class="token function">sudo</span> nginx -s stop  //快速停止nginx<span class="token function">sudo</span> nginx -s quit  //完整有序的停止nginx<span class="token function">sudo</span> nginx -t     //测试当前配置文件是否正确</code></pre><p>nginx常见目录：</p><pre class=" language-bash"><code class="language-bash">/usr/local/Cellar/  <span class="token comment" spellcheck="true">#nginx默认安装的目录,所有使用brew安装的软件默认都在这里</span>/usr/local/Cellar/nginx/1.8.0/html  ＃默认的访问目录，就是我们说的网站根目录/usr/local/etc/nginx/     <span class="token comment" spellcheck="true"># nginx.conf所在的目录</span>修改默认路径从nginx/html改成你自己放置代码的路径vim /usr/local/etc/nginx/nginx.conf</code></pre><p>接下来的任务就很明确了，把listen 80下面的两个 root html中的路径，改成我们自己放代码的文件夹。例如在桌面下面新建一个home的文件夹，再在目录下新建一个www的文件夹，那么路径就是：桌面:homewww，把task1.html放进去，然后修改配置修改完成后，点击Esc键<code>·shift+: 输入：wq</code>，保存修改。</p><h4 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h4><p>打开终端，开启Apache:</p><pre class=" language-bash"><code class="language-bash">//开启apache:  <span class="token function">sudo</span> apachectl start//重启apache:  <span class="token function">sudo</span> apachectl restart//关闭apache:  <span class="token function">sudo</span> apachectl stop//查看apache版本 <span class="token function">sudo</span> apachectl -v</code></pre><p>回车会提示输入密码，也就是你电脑的密码，<a href="http://127.0.0.1/测试一下。" target="_blank" rel="noopener">http://127.0.0.1/测试一下。</a><br>点击Finder,然后Command+Shift+G,前往Apache服务器的文件路径(/Library/WebServer/Documents)，在步骤1中只输入一个<a href="http://127.0.0.1其实默认打开的是index.html.en(html是一个网页文件)，该文件的内容就是在步骤1中测试时浏览器所显示的内容" target="_blank" rel="noopener">http://127.0.0.1其实默认打开的是index.html.en(html是一个网页文件)，该文件的内容就是在步骤1中测试时浏览器所显示的内容</a></p>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx同域名下配置多项目</title>
      <link href="/2019/11/20/Nginx/multiProject/"/>
      <url>/2019/11/20/Nginx/multiProject/</url>
      
        <content type="html"><![CDATA[<h4 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h4><pre class=" language-bash"><code class="language-bash">build: <span class="token punctuation">{</span>    index: path.resolve<span class="token punctuation">(</span>__dirname, <span class="token string">'../dist/index.html'</span><span class="token punctuation">)</span>,    // Paths    assetsRoot: path.resolve<span class="token punctuation">(</span>__dirname, <span class="token string">'../dist'</span><span class="token punctuation">)</span>,    assetsSubDirectory: <span class="token string">'static'</span>,    assetsPublicPath: <span class="token string">'/admin/'</span>,    productionSourceMap: true,    devtool: <span class="token string">'#source-map'</span>,    productionGzip: true,    productionGzipExtensions: <span class="token punctuation">[</span><span class="token string">'js'</span>, <span class="token string">'css'</span><span class="token punctuation">]</span>,    bundleAnalyzerReport: process.env.npm_config_report  <span class="token punctuation">}</span></code></pre><p>把 assetsPublicPath修改为你在nginx配置的路径。</p><h4 id="router-js"><a href="#router-js" class="headerlink" title="router.js"></a>router.js</h4><pre class=" language-bash"><code class="language-bash">//base要和上面配置的assetsPublicPath配置的一样 mode:<span class="token string">'history'</span>, base: <span class="token string">'/admin/'</span>,</code></pre><h4 id="配置nginx："><a href="#配置nginx：" class="headerlink" title="配置nginx："></a>配置nginx：</h4><pre class=" language-bash"><code class="language-bash">keepalive_timeout  65<span class="token punctuation">;</span><span class="token function">gzip</span>  on<span class="token punctuation">;</span>//开启Gzip压缩gzip_disable <span class="token string">'msie6'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">#不使用gzip IE6</span>gzip_min_length 100k<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">#gzip压缩最小文件大小，超出进行压缩（自行调节）</span>gzip_buffers 4 16k<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">#buffer 不用修改</span>gzip_comp_level 3<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">#压缩级别:1-10，数字越大压缩的越好，时间也越长</span>server <span class="token punctuation">{</span>    listen 80<span class="token punctuation">;</span>    server_name www.xxx.cn<span class="token punctuation">;</span>//配置你的域名    location /<span class="token punctuation">{</span>//配置默认的项目         root /data/www/web<span class="token punctuation">;</span>         try_files <span class="token variable">$uri</span> <span class="token variable">$uri</span>/ /index.html<span class="token punctuation">;</span>         index index.html index.htm<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">#proxy_pass http://127.0.0.1:8080;</span>     <span class="token punctuation">}</span>     location ^~/admin<span class="token punctuation">{</span>//配置 域名/admin 对应的项目         <span class="token function">alias</span> /data/www/admin/<span class="token punctuation">;</span>//别名 配置项目文件路径         try_files <span class="token variable">$uri</span> <span class="token variable">$uri</span>/ /index.html<span class="token punctuation">;</span>         index index.html index.htm<span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>-e <span class="token variable">$request_filename</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>//防止二级路由下页面reload空白页面             rewrite ^/<span class="token punctuation">(</span>.*<span class="token punctuation">)</span> /admin/index.html last<span class="token punctuation">;</span>             <span class="token keyword">break</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">#proxy_pass http://127.0.0.1:8080;</span>     <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ngigx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue使用webpack优化构建流程</title>
      <link href="/2019/11/20/Vue/webpack%E6%9E%84%E5%BB%BA/"/>
      <url>/2019/11/20/Vue/webpack%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>初衷：如果我们的 Vue 项目比较大．或者说项目中引入了许多第三方库，那么在执行 npm run build 构建项目的时候会极其的慢．比如我现在的项目就每次打包就要 83s。<br>下面提供一些方法用来提供优化打包速度：</p><h4 id="resolve-modules"><a href="#resolve-modules" class="headerlink" title="resolve.modules"></a>resolve.modules</h4><p>思路：webpack 的 resolve.modules 是用来配置模块库（即 node_modules）所在的位置。当 js 里出现 import ‘vue’ 这样不是相对、也不是绝对路径的写法时，它便会到 node_modules 目录下去找。在默认配置下，webpack 会采用向上递归搜索的方式去寻找。但通常项目目录里只有一个 node_modules，且是在项目根目录。为了减少搜索范围，可我们以直接写明 node_modules 的全路径。</p><pre><code>打开 build/webpack.base.conf.js 文件，添加如下配置：module.exports = {  resolve: {    extensions: [&#39;.js&#39;, &#39;.vue&#39;, &#39;.json&#39;],    modules: [      resolve(&#39;src&#39;),      resolve(&#39;node_modules&#39;)    ],    alias: {      &#39;vue$&#39;: &#39;vue/dist/vue.esm.js&#39;,      &#39;@&#39;: resolve(&#39;src&#39;),    }  },</code></pre><h4 id="webpack-parallel-uglify-plugin"><a href="#webpack-parallel-uglify-plugin" class="headerlink" title="webpack-parallel-uglify-plugin"></a>webpack-parallel-uglify-plugin</h4><p>原理：webpack默认提供了UglifyJS插件来压缩JS代码，但是它使用的是单线程压缩代码，也就是说多个js文件需要被压缩，它需要一个个文件进行压缩。所以说在正式环境打包压缩代码速度非常慢(因为压缩JS代码需要先把代码解析成用Object抽象表示的AST语法树，再去应用各种规则分析和处理AST，导致这个过程耗时非常大)。源码：</p><pre><code>module.exports = {  plugins: [    new webpack.optimize.UglifyJsPlugin({      sourceMap: true,      compress: {        warnings: false      }    }),  ]}</code></pre><p>我们可以改用 webpack-parallel-uglify-plugin 插件，它可以并行运行 UglifyJS 插件，从而更加充分、合理的使用 CPU 资源，从而大大减少构建时间。<br>当webpack有多个JS文件需要输出和压缩时候，原来会使用UglifyJS去一个个压缩并且输出，但是ParallelUglifyPlugin插件则会开启多个子进程，把对多个文件压缩的工作分别给多个子进程去完成，但是每个子进程还是通过UglifyJS去压缩代码。无非就是变成了并行处理该压缩了，并行处理多个子任务，效率会更高。</p><pre><code>安装：npm i webpack-parallel-uglify-plugin打开 build/webpack.prod.conf.js 文件，并作如下修改：const ParallelUglifyPlugin = require(&#39;webpack-parallel-uglify-plugin&#39;);// 删掉webpack提供的UglifyJS插件    //new UglifyJsPlugin({    //  uglifyOptions: {    //    compress: {    //      warnings: false    //    }    //  },    //  sourceMap: config.build.productionSourceMap,    //  parallel: true    //}),    // 增加 webpack-parallel-uglify-plugin来替换    new ParallelUglifyPlugin({      cacheDir: &#39;.cache/&#39;,      uglifyJS:{        output: {          comments: false        },        compress: {          warnings: false,          drop_debugger: true,          drop_console: true        }      }    }),</code></pre><h4 id="HappyPack"><a href="#HappyPack" class="headerlink" title="HappyPack"></a>HappyPack</h4><p>原理：由于运行在 Node.js 之上的 Webpack 是单线程模型的，所以 Webpack 需要处理的事情只能一件一件地做，不能多件事一起做。而 HappyPack 的处理思路是：将原有的 webpack 对 loader 的执行过程，从单一进程的形式扩展多进程模式，从而加速代码构建。</p><pre><code>安装：npm i happypack打开 build/webpack.base.conf.js 文件，并作如下修改：const HappyPack = require(&#39;happypack&#39;);const os = require(&#39;os&#39;);const happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length });module.exports = {  module: {    rules: [      {        test: /.js$/,        //把对.js 的文件处理交给id为happyBabel 的HappyPack 的实例执行        loader: &#39;happypack/loader?id=happyBabel&#39;,        include: [resolve(&#39;src&#39;)],        //排除node_modules 目录下的文件        exclude: /node_modules/      },    ]  },  plugins: [    new HappyPack({        //用id来标识 happypack处理那里类文件      id: &#39;happyBabel&#39;,      //如何处理  用法和loader 的配置一样      loaders: [{        loader: &#39;babel-loader?cacheDirectory=true&#39;,      }],      //共享进程池      threadPool: happyThreadPool,      //允许 HappyPack 输出日志      verbose: true,    })  ]}</code></pre><h4 id="DllPlugin-和-DllReferencePlugin"><a href="#DllPlugin-和-DllReferencePlugin" class="headerlink" title="DllPlugin 和 DllReferencePlugin"></a>DllPlugin 和 DllReferencePlugin</h4><p>原理：我们的项目依赖中通常会引用大量的 npm 包，而这些包在正常的开发过程中并不会进行修改，但是在每一次构建过程中却需要反复的将其解析，而下面介绍的两个插件就是用来规避此类损耗的：<br>DllPlugin 插件：作用是预先编译一些模块。<br>DllReferencePlugin 插件：它的所用则是把这些预先编译好的模块引用起来。<br>注意：DllPlugin 必须要在 DllReferencePlugin 执行前先执行一次。</p><pre><code>1、在 build 文件夹中新建 webpack.dll.conf.js 文件，内容如下（主要是配置下需要提前编译打包的库）：const path = require(&#39;path&#39;);const webpack = require(&#39;webpack&#39;);module.exports = {  entry: {    vendor: [&#39;vue/dist/vue.common.js&#39;,            &#39;vue-router&#39;,            &#39;axios&#39;,            &#39;vuex&#39;,            &#39;element-ui&#39;]  },  output: {    path: path.join(__dirname, &#39;../static/js&#39;),    filename: &#39;[name].dll.js&#39;,    library: &#39;[name]_library&#39;       // vendor.dll.js中暴露出的全局变量名  },  plugins: [    new webpack.DllPlugin({      path: path.join(__dirname, &#39;.&#39;, &#39;[name]-manifest.json&#39;),      name: &#39;[name]_library&#39;    }),    new webpack.optimize.UglifyJsPlugin({      compress: {        warnings: false      }    })  ]};2、编辑 package.json 文件，添加一条编译命令：    dll: webpack --config webpack.dll.conf.js接着执行 npm run dll 命令来生成 vendor.dll.js。注意：如果之后这些需要预编译的库又有变动，则需再次执行 npm run dll 命令来重新生成 vendor.dll.js3、index.html 这边将 vendor.dll.js 引入进来：&lt;script src=‘./static/js/vendor.dll.js’&gt;&lt;/script&gt;4、打开 build/webpack.base.conf.js 文件，编辑添加如下高亮配置，作用是通过 DLLReferencePlugin 来使用 DllPlugin 生成的 DLL Bundle。const webpack = require(&#39;webpack&#39;);module.exports = {  context: path.resolve(__dirname, &#39;../&#39;),  entry: {    app: &#39;./src/main.js&#39;  },  //.....  plugins: [     // 添加DllReferencePlugin插件     new webpack.DllReferencePlugin({       context: path.resolve(__dirname, &#39;..&#39;),       manifest: require(&#39;./vendor-manifest.json&#39;)     }),  ]}</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx下配置Vue项目</title>
      <link href="/2019/11/20/Nginx/vue/"/>
      <url>/2019/11/20/Nginx/vue/</url>
      
        <content type="html"><![CDATA[<p>1、配置选择：</p><ul><li>Linux系统：Centos 6.5 x64</li><li>Nginx版本：1.7.8</li></ul><p>2、安装nginx：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local//下载nginx<span class="token function">wget</span> http://nginx.org/download/nginx-1.7.8.tar.gz<span class="token function">cd</span> nginx-1.7.8<span class="token function">make</span><span class="token function">make</span> <span class="token function">install</span></code></pre><p>3、开启nginx服务：</p><pre class=" language-bash"><code class="language-bash">/usr/local/nginx-1.7.8/sbin/nginx重启或关闭进程：/usr/local/nginx-1.7.8/sbin/nginx -s reload/usr/local/nginx-1.7.8/sbin/nginx -s stop</code></pre><p>4、关闭防火墙：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">service</span> iptables stop</code></pre><p>5、修改配置文件：</p><pre class=" language-bash"><code class="language-bash">usr/local/nginx-1.7.8/conf/nginx.confserver <span class="token punctuation">{</span>    listen 80<span class="token punctuation">;</span>//监听80端口    server_name www.yangkunxiao.cn<span class="token punctuation">;</span>   //项目对应域名    location /<span class="token punctuation">{</span>     root /data/www/dist<span class="token punctuation">;</span>     //项目存放路径     try_files <span class="token variable">$uri</span> <span class="token variable">$uri</span>/ /index.html<span class="token punctuation">;</span>    //vue项目配置history模式     index index.html index.htm<span class="token punctuation">;</span>    //项目首页名称     <span class="token comment" spellcheck="true">#proxy_pass http://127.0.0.1:8080;   //域名对应URL，这个URL对应的就是http://m.horace.space，可通过域名直接访问</span>    <span class="token punctuation">}</span>    location /assets/<span class="token punctuation">{</span>//配置资源文件夹        root /usr/<span class="token punctuation">;</span>//资源文件夹路径        autoindex on<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>7、多个项目配置多个service即可<br>6、重启即可</p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx下配置静态资源</title>
      <link href="/2019/11/20/Nginx/staticSource/"/>
      <url>/2019/11/20/Nginx/staticSource/</url>
      
        <content type="html"><![CDATA[<p>1、查看nginx安装路径：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">whereis</span> nginx</code></pre><p>2、新建静态资源存储文件夹：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> assets</code></pre><p>3、进入nginx目录中，修改nginx.conf文件：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> nginx: /usr/local/nginx/confvim nginx.conf具体配置如下：server <span class="token punctuation">{</span>    listen 80<span class="token punctuation">;</span>    server_name www.yangkunxiao.cn<span class="token punctuation">;</span>    location /<span class="token punctuation">{</span>     root /data/www/dist<span class="token punctuation">;</span>     try_files <span class="token variable">$uri</span> <span class="token variable">$uri</span>/ /index.html<span class="token punctuation">;</span>     index index.html index.htm<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">#proxy_pass http://127.0.0.1:8080;</span>    <span class="token punctuation">}</span>    location /assets/<span class="token punctuation">{</span>        root /usr/<span class="token punctuation">;</span>        autoindex on<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>4、保存并重启nginx</p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESC服务器Linux下安装mysql</title>
      <link href="/2019/11/20/Linux/mysql/"/>
      <url>/2019/11/20/Linux/mysql/</url>
      
        <content type="html"><![CDATA[<p>1、重启服务器：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@sir-xiao server<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># reboot</span></code></pre><p>2、检查是否已经安装mysql服务：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@sir-xiao server<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># yum list installed | grep mysql</span></code></pre><p>如果显示一下内容，则表示没有安装：-bash: gerp: command not found<br>3、下载mysql安装包：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@sir-xiao server<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># rpm -ivh http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm</span></code></pre><p>4、安装mysql：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@sir-xiao server<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># yum install -y mysql-server</span>或者<span class="token punctuation">[</span>root@sir-xiao server<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># yum install mysql-community-server</span></code></pre><p>5、设置开机启动：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@sir-xiao server<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl enable mysqld.service</span></code></pre><p>6、查看服务是否加入开机自动启动：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@sir-xiao server<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl list-unit-files | grep mysqld</span></code></pre><p>7、查看mysql的默认临时密码：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@sir-xiao server<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl list-unit-files | grep mysqld</span></code></pre><p>8、root用户登录mysql数据库：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@sir-xiao server<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mysql -u root -p </span>Enter password: 根据提示 输入密码</code></pre><p>9、修改root用户密码：</p><pre class=" language-bash"><code class="language-bash">mysql<span class="token operator">></span> use  mysql；----切换到mysql dbmysql<span class="token operator">></span> UPDATE user SET authentication_string <span class="token operator">=</span> PASSWORD<span class="token punctuation">(</span><span class="token string">'newpass'</span><span class="token punctuation">)</span> WHERE user <span class="token operator">=</span> <span class="token string">'root'</span><span class="token punctuation">;</span>---新版本mysql执行mysql<span class="token operator">></span> UPDATE user SET Password <span class="token operator">=</span> PASSWORD<span class="token punctuation">(</span><span class="token string">'newpass'</span><span class="token punctuation">)</span> WHERE user <span class="token operator">=</span> <span class="token string">'root'</span><span class="token punctuation">;</span>---老版本mysql执行mysql<span class="token operator">></span> flush privileges<span class="token punctuation">;</span>---命令立即执行生效</code></pre><p>10、忘记密码重置密码：</p><pre class=" language-bash"><code class="language-bash">1、查找mysql的启动文件：<span class="token punctuation">[</span>root@sir-xiao etc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># whereis  my</span>2、vim /etc/my.cnf修改my.cnf启动参数，在文件的最后增加，mysql启动参数—— --skip-grant-tables。启动mysql时不启动授权表 grant-tables<span class="token punctuation">[</span>root@sir-xiao etc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># vi /etc/my.cnf skip-grant-tables</span><span class="token punctuation">[</span>root@sir-xiao etc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># :wq</span>vi模式Enter进入，按“i”键，编辑文件，按“esc”键，输入:wq写入保存退出，:q 不保存退出3、重启mysql服务4、修改密码：同上5、密码修改成功后需要进入vi模式下重新编辑/etc/my.cnf去掉增加的skip-grant-tables 重启mysql服务，就可以用密码登录了</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript数据类型</title>
      <link href="/2019/11/19/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/11/19/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>JavaScript中有一下七种数据类型：Number、String、Null、Undefined、Bool、Object以及Symbal。</p><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>Number、String、Null、Undefined、Bool。<br>JavaScript的基本数据类型的访问是按值访问的，因为基本数据类型的值是保存在栈中的。</p><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>Object、Function、Array等。<br>JavaScript的引用数据类型的访问是按引用访问的，引用数据类型的值是存放在栈和堆中的：指针存放在栈中，值存放在堆中。栈区内存保存变量标识符和指向堆内存中该对象的指针，也可以说是该对象在堆内存的地址。</p><h4 id="数据类型的区分"><a href="#数据类型的区分" class="headerlink" title="数据类型的区分"></a>数据类型的区分</h4><ol><li>typeof 检查</li></ol><pre class=" language-bash"><code class="language-bash">typeof   123　　 //Numbertypeof   <span class="token string">'abc'</span>　　//Stringtypeof    <span class="token boolean">true</span>       //Booleantypeof    undefined   //Undefinedtypeof    null        //Object     typeof    <span class="token punctuation">{</span> <span class="token punctuation">}</span>           //Objecttypeof    <span class="token punctuation">[</span> <span class="token punctuation">]</span>           //Objecttypeof    console.log<span class="token punctuation">(</span><span class="token punctuation">)</span>       //Function</code></pre><p>可以看出 typeof 是检查不出来 null、{} 、[] 的。<br>推荐使用一下方法：</p><pre class=" language-bash"><code class="language-bash">判断基本类型：Object.prototype.toString.call<span class="token punctuation">(</span>null<span class="token punctuation">)</span> //<span class="token string">"[object Null]"</span>Object.prototype.toString.call<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> //<span class="token string">"[object Array]"</span>Object.prototype.toString.call<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> //<span class="token string">"[object Object]"</span>Object.prototype.toString.call<span class="token punctuation">(</span>123<span class="token punctuation">)</span> //<span class="token string">"[object Number]"</span>Object.prototype.toString.call<span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span> //<span class="token string">"[object String]"</span>Object.prototype.toString.call<span class="token punctuation">(</span>undefined<span class="token punctuation">)</span> //<span class="token string">"[object Undefined]"</span>Object.prototype.toString.call<span class="token punctuation">(</span>true<span class="token punctuation">)</span> //<span class="token string">"[object Boolean]"</span>判断引用类型：Function fn<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console.log<span class="token punctuation">(</span>“test”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Object.prototype.toString.call<span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>//<span class="token string">"[object Function]"</span>var <span class="token function">date</span> <span class="token operator">=</span> new Date<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Object.prototype.toString.call<span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>//<span class="token string">"[object Date]"</span>var reg <span class="token operator">=</span> /<span class="token punctuation">[</span>hbc<span class="token punctuation">]</span>at/gi<span class="token punctuation">;</span>Object.prototype.toString.call<span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>//<span class="token string">"[object RegExp]"</span></code></pre><h4 id="数据包装类型"><a href="#数据包装类型" class="headerlink" title="数据包装类型"></a>数据包装类型</h4><p>数据包装类型包含：Number、String、Boolean。数据包装类型是特殊的引用类型，每当创建一个基本数据类型的时候，就会在后台创建一个对应的数据包装类型对象，用来使基本数据类型可以访问对象上的方法和属性。<br>举个🌰：</p><pre class=" language-bash"><code class="language-bash">var str <span class="token operator">=</span> <span class="token string">'123'</span><span class="token punctuation">;</span>str.split<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//后台创建对应的数据包装类型var str <span class="token operator">=</span> new String<span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span>//创建str对象str.split<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//执行方法str <span class="token operator">=</span> null//销毁str</code></pre><p>而且，通过构造函数和对象字面量创建的对象是不一样的：</p><pre class=" language-bash"><code class="language-bash">var str <span class="token operator">=</span> <span class="token string">'123'</span><span class="token punctuation">;</span>typeof str // stringvar str1 <span class="token operator">=</span> new String<span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>typeof str1 // object</code></pre><p>其他的 Boolean 和 Number 也和 String 类似。</p><h4 id="为什么使用Object-prototype-toString-call"><a href="#为什么使用Object-prototype-toString-call" class="headerlink" title="为什么使用Object.prototype.toString.call()?"></a>为什么使用Object.prototype.toString.call()?</h4><p>因为toString方法是Object原型上的方法，而Array、function等类型作为Object的实例，都重写了toString方法。不同的对象的调用toString方法的时候，调用的都是重写的toString方法，而不是Object原型链上的方法。所以如果要得到对象的具体的类型，需要调用Object原型上的toString方法，即使用call将toString的this指向改变。</p><pre class=" language-bash"><code class="language-bash">var fun <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    alert<span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>fun.toString<span class="token punctuation">(</span><span class="token punctuation">))</span>//返回的是 函数的字符串形式delete Function.prototype.toString<span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>fun.toString<span class="token punctuation">(</span><span class="token punctuation">))</span>// 返回的是<span class="token punctuation">[</span>object Function<span class="token punctuation">]</span></code></pre><p>因为删除了Function.prototype上的toString方法之后，根据原型链，它会沿着原型链查找到Object.prototype.toString方法</p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>执行环境（Execution Context）</title>
      <link href="/2019/11/18/JavaScript/EC%20and%20Scope/"/>
      <url>/2019/11/18/JavaScript/EC%20and%20Scope/</url>
      
        <content type="html"><![CDATA[<h4 id="执行环境EC"><a href="#执行环境EC" class="headerlink" title="执行环境EC"></a>执行环境EC</h4><p>Execution Context，即EC,是JavaScript中最为重要的一个概念。</p><a id="more"></a><p>执行环境定义链变量及函数有权访问的其他数据，决定了它们各自的行为。<br>全局执行环境是一个“兜底”的执行环境，它是最外围的执行环境。</p><h4 id="全局对象GO"><a href="#全局对象GO" class="headerlink" title="全局对象GO"></a>全局对象GO</h4><p>它在全局只存在一份，它的属性可以在任何地方都可以访问到，它的存在是伴随着整个程序的生命周期的。</p><p>JS引擎在进入一段可执行的代码时，需要完成以下三个初始化工作：</p><p>1、首先，创建一个全局对象(Global Object，即GO)，将Math、String、Data等常用的js对象作为其属性，但是这个GO在全局是不可见的，不可直接访问的。因此它还有另外一个属性window，并将window指向了自身，这样就可以在全局通过访问window，来访问GO的属性了。</p><pre class=" language-bash"><code class="language-bash">//创建一个全局对象var globalObject <span class="token operator">=</span> <span class="token punctuation">{</span>    Math:<span class="token punctuation">{</span><span class="token punctuation">}</span>,    String:<span class="token punctuation">{</span><span class="token punctuation">}</span>,    Date:<span class="token punctuation">{</span><span class="token punctuation">}</span>,    document:<span class="token punctuation">{</span><span class="token punctuation">}</span>, //DOM操作    <span class="token punctuation">..</span>.    window:this //让window属性指向了自身<span class="token punctuation">}</span></code></pre><h4 id="环境执行栈ECS"><a href="#环境执行栈ECS" class="headerlink" title="环境执行栈ECS"></a>环境执行栈ECS</h4><p>然后JS引擎会创建一个环境执行栈(Execution Context Stack，即ECS)，与此同时，还会建立一个全局的执行环境(Execution Context，即EC)。当执行流进入到一个函数时，函数的执行环境就会被推到ECS中，而在函数执行完毕之后，ECS就会将其环境弹出，并且将程序的控制权交给之前的EC。ECMAScript程序的执行流就是由这种机制控制着。</p><pre class=" language-bash"><code class="language-bash">var ECStack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> //定义一个执行环境栈，类似于数组var EC <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   //创建一个执行空间，//ECMA-262规范并没有对EC的数据结构做明确的定义，你可以理解为在内存中分配的一块空间ECStack.push<span class="token punctuation">(</span>EC<span class="token punctuation">)</span><span class="token punctuation">;</span> //进入函数，压入执行环境ECStack.pop<span class="token punctuation">(</span>EC<span class="token punctuation">)</span><span class="token punctuation">;</span>  //函数返回后，删除执行环境</code></pre><h4 id="变量对象VO"><a href="#变量对象VO" class="headerlink" title="变量对象VO"></a>变量对象VO</h4><p>最后，JS引擎会创建一个与EC相关联的对象，<strong>变量对象</strong>（Variable Object，即VO），每个执行环境都有与之关联的VO，并把VO指向全局对象，VO中不仅仅包含了全局对象的属性，还包含了环境中定义的所有的变量和函数。<br>每个函数在定义的时候，都会创建一个与之关联的<strong>scope</strong>属性，scope总是指向定义函数时所在的环境。</p><h4 id="作用域链Scope-Chain"><a href="#作用域链Scope-Chain" class="headerlink" title="作用域链Scope Chain"></a>作用域链Scope Chain</h4><p>当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行环境的代码所在的变量对象。如果这个环境是函数，则将其<strong>活动对象</strong>（Activation Object，即AO）作为变量对象，初始时AO只包含一个变量，即arguments。作用域链的下一个变量对象来自于外部包含环境，而下一个变量对象来自下一个包含环境，这样一直延伸到全局环境。全局变量对象（GO）始终都是作用域链的最后一个对象。</p><h4 id="标识符解析"><a href="#标识符解析" class="headerlink" title="标识符解析"></a>标识符解析</h4><p>当在某个环境中为了读取或写入从而引入一个标识符时，必须通过搜索来确定该标识符代表了什么。搜索过程从当期作用域链的前端开始，向上逐级搜索，如果在局部环境中查找到了该标识符的定义，则停止搜索‘否则将一直沿着作用域链向上查找，直到找到GO上。如果找不到，则会报错</p><h4 id="延长作用域"><a href="#延长作用域" class="headerlink" title="延长作用域"></a>延长作用域</h4><p>虽然作用域只有两种：全局和局部（函数），但是还是有其他办法可以用来延长作用域链。其主要思路就是：有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象在代码执行后就被销毁。<br>1、try-catch语句的catch块<br>2、with语句</p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用原生JavaScript实现call、apply和bind</title>
      <link href="/2019/11/18/JavaScript/this/"/>
      <url>/2019/11/18/JavaScript/this/</url>
      
        <content type="html"><![CDATA[<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>在JavaScript中this的指向问题中提到，作为对象方法的调用。函数还可以作为某个对象的方法调用，这时this就指这个上级对象。也就是我们平时说的，谁调用，this就指向谁。</p><blockquote><p>实现方法：在传入的参数中传入一个方法，然后执行这个方法，最后删除该方法（为了保持对象的前后一致性）。</p></blockquote><h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><pre class=" language-bash"><code class="language-bash">var obj <span class="token operator">=</span> <span class="token punctuation">{</span>    age <span class="token punctuation">;</span> 10<span class="token punctuation">}</span>var fn <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    this.value <span class="token operator">=</span> 100<span class="token punctuation">;</span><span class="token punctuation">}</span>/**将newCall绑定在Function的原型上 context:上下文 即this<span class="token punctuation">..</span>.rest ES6语法糖 用来取代arguments*/Function.prototype.newCall <span class="token operator">=</span> function<span class="token punctuation">(</span>context,<span class="token punctuation">..</span>.rest<span class="token punctuation">)</span><span class="token punctuation">{</span>    if<span class="token punctuation">(</span> context instanceof Object <span class="token punctuation">)</span><span class="token punctuation">{</span>        context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>    <span class="token punctuation">}</span>else<span class="token punctuation">{</span>        context <span class="token operator">=</span> Object.create<span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    //使用symbal 避免原来的context上有函数fn    const fn <span class="token operator">=</span> Symbal<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> this<span class="token punctuation">;</span>//此时this 谁调用 指向谁    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">..</span>.rest<span class="token punctuation">)</span><span class="token punctuation">;</span>//context 调用fn,改变this指向    delete context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span>//删除fn属性 保持原对象的统一<span class="token punctuation">}</span>var fun <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console.log<span class="token punctuation">(</span>this.age<span class="token punctuation">)</span><span class="token punctuation">;</span>//10    // fn.newCall<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>    //console.log<span class="token punctuation">(</span>this.value<span class="token punctuation">)</span><span class="token punctuation">;</span> 100<span class="token punctuation">}</span>fun.newCall<span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p>和call类似，只是传参的不同，不多说 ，直接上代码： </p><pre class=" language-bash"><code class="language-bash">Function.prototype.newCall <span class="token operator">=</span> function<span class="token punctuation">(</span>context,parames<span class="token punctuation">)</span><span class="token punctuation">{</span>    if<span class="token punctuation">(</span> context instanceof Object <span class="token punctuation">)</span><span class="token punctuation">{</span>        context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>    <span class="token punctuation">}</span>else<span class="token punctuation">{</span>        context <span class="token operator">=</span> Object.create<span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    //使用symbal 避免原来的context上有函数fn    const fn <span class="token operator">=</span> Symbal<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> this<span class="token punctuation">;</span>//此时this 谁调用 指向谁    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span>parames<span class="token punctuation">)</span><span class="token punctuation">;</span>//context 调用fn,改变this指向    delete context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span>//删除fn属性 保持原对象的统一<span class="token punctuation">}</span></code></pre><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>bind和call、apply的区别，这里不再多做赘述。直接上代码：</p><pre class=" language-bash"><code class="language-bash">Function.prototype.bind <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>context,<span class="token punctuation">..</span>.innerArgs<span class="token punctuation">)</span> <span class="token punctuation">{</span>  var self <span class="token operator">=</span> this  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">..</span>.finnalyArgs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> self.call<span class="token punctuation">(</span>context,<span class="token punctuation">..</span>.innerArgs,<span class="token punctuation">..</span>.finnalyArgs<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript原型和原型链</title>
      <link href="/2019/11/13/JavaScript/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2019/11/13/JavaScript/%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h4 id="为什么要使用原型prototype"><a href="#为什么要使用原型prototype" class="headerlink" title="为什么要使用原型prototype"></a>为什么要使用原型prototype</h4><p>首先，让我们看一段代码：</p><pre class=" language-bash"><code class="language-bash">//新建一个构造函数var Person <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    drink<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console.log<span class="token punctuation">(</span><span class="token string">'drink'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Person.prototype.eat <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console.log<span class="token punctuation">(</span><span class="token string">'eat'</span><span class="token punctuation">)</span><span class="token punctuation">}</span>var person <span class="token operator">=</span> new Person<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>person.eat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在这段代码中，我们分别在Person和Person.prototye上挂载了 eat 和 drink 函数，然后使用 new 关键字对构造函数 Person 进行了实例化。</p><p>对于 drink 函数：每进行一次实例化，都要重新在内存中占用一些资源；</p><p>对于 eat 函数：我们将 eat 函数挂载在 Person 的原型上，Person 的实例每次只需要调用原型伤的方法即可。不仅节约了资源，而且是的代码更加优雅、美观。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ol><li><p>所有的引用类型（数组、函数、对象）可以自由扩展属性（除null以外）</p></li><li><p>所有引用类型（数组、函数、对象）都有_proto_属性（这是它的隐式原型，除null外）</p></li><li><p>所有构造函数都有prototype属性（这是它的显示原型）</p></li><li><p>所有引用类型的_proto_都指向它们的构造函数的 prototype </p></li><li><p>当寻找一个属性时，如果在当前对象本身找不到该属性，就会沿着_proto_向上进行寻找，直到找到为止或者指向 null 为止。（这就是原型链）</p><p><img src="http://q0sal13sb.bkt.clouddn.com/yuanxinglian.jpeg" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Javascript继承</title>
      <link href="/2019/11/13/JavaScript/%E7%BB%A7%E6%89%BF/"/>
      <url>/2019/11/13/JavaScript/%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p>在JavaScript中有很多继承的方式，接下来让我们一起来总结下各种继承的方法以及它们的不同点。</p><h4 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h4><blockquote><p>JavaScript规定，每一个构造函数都有一个prototype属性，它指向一个对象，这个对象中的所有的属性和方法都会被构造函数的实例所继承。</p></blockquote><p>构造函数的继承是通过new关键字，生成实例完成的。使用new关键字生成实例的过程中，就会把this绑定到实例上，具体过程如下：</p><ol><li>在内存中先生成一个object的实例对象，</li><li>将实例对象的_proto_指向构造函数的prototype（即构造函数的原型），</li><li>运行构造函数，</li><li>检查返回值，如果返回值为基本数据类型，则无视该返回值，而将生成的对象返回。如果为引用类型，则将该返回值返回。</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token keyword">function</span> SuperType<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    this.colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"red"</span>, <span class="token string">"blue"</span>, <span class="token string">"green"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> SubType<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>    SuperType.call<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">}</span>var s <span class="token operator">=</span> new SubType<span class="token punctuation">(</span><span class="token string">'ykx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s.colors.push<span class="token punctuation">(</span><span class="token string">'yellow'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>s.colors<span class="token punctuation">)</span><span class="token punctuation">;</span>var s2 <span class="token operator">=</span> new Subtype<span class="token punctuation">(</span><span class="token string">'lhd'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>s2.colors<span class="token punctuation">)</span></code></pre><blockquote><p>优点：<br>1、实例化子类型的时候可以传参<br>2、父类型中的属性不会变为公共的属性</p></blockquote><blockquote><p>缺点：虽然构造函数实现继承的方式比较好用，但是并不推荐这种方式。构造函数继承存在内存浪费的情况，每生成一个实例，都会占用一些内存。</p></blockquote><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><pre class=" language-bash"><code class="language-bash"><span class="token keyword">function</span> SuperType<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    this.colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"red"</span>, <span class="token string">"blue"</span>, <span class="token string">"green"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>SuperType.prototype.Fun <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> SubType<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>//继承了SuperTypeSubType.prototype <span class="token operator">=</span> new SuperType<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>var instance1 <span class="token operator">=</span> new SubType<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>instance1.colors.push<span class="token punctuation">(</span><span class="token string">"black"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>alert<span class="token punctuation">(</span>instance1.colors<span class="token punctuation">)</span><span class="token punctuation">;</span> //<span class="token string">"red,blue,green,black"</span>var instance2 <span class="token operator">=</span> new SubType<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>alert<span class="token punctuation">(</span>instance2.colors<span class="token punctuation">)</span><span class="token punctuation">;</span> //<span class="token string">"red,blue,green,black"</span></code></pre><blockquote><p>优点：可以通过 instanceOf 和 isPrototypeOf 检测<br>instanceOf：a.instanceOf B ,左操作数是一个对象，右操作数标识对象的类。如果左侧对象是右侧类的实例，则表达式返回为true，否则返回false。<br>isPrototypeOf：检测一个对象是否是另一个对象的原型。或者说一个对象是否被包含在另一个对象的原型链中。</p></blockquote><blockquote><p>缺点：<br>1、父类型中的私有属性会变为子类型中的公有属性<br>2、创建子类型的时候，不能像父类型的构造函数中传递参数。</p></blockquote><h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><pre class=" language-bash"><code class="language-bash"><span class="token keyword">function</span> Man<span class="token punctuation">(</span>age,name<span class="token punctuation">)</span><span class="token punctuation">{</span>    this.eat <span class="token operator">=</span> function<span class="token punctuation">(</span>something<span class="token punctuation">)</span><span class="token punctuation">{</span>        console.log<span class="token punctuation">(</span>this.age + <span class="token string">'岁的'</span> + this.name + <span class="token string">'正在吃: '</span> + something<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>Man.prototype.drink <span class="token operator">=</span> function<span class="token punctuation">(</span>something<span class="token punctuation">)</span><span class="token punctuation">{</span>    console.log<span class="token punctuation">(</span>this.name + <span class="token string">'正在喝:'</span> + something<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">function</span> Boy<span class="token punctuation">(</span>age,name<span class="token punctuation">)</span><span class="token punctuation">{</span>    this.age <span class="token operator">=</span> age<span class="token punctuation">;</span>    this.name <span class="token operator">=</span> name<span class="token punctuation">;</span>    Man.call<span class="token punctuation">(</span>this,age,name<span class="token punctuation">)</span><span class="token punctuation">}</span>/**不推荐使用 Boy.prototype <span class="token operator">=</span> new Man<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>因为在JavaScript中没有显式的constructor，所以使用new关键字实例化的时候 该函数会被调用一次*/Boy.prototype <span class="token operator">=</span> Object.create<span class="token punctuation">(</span>Man.prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>Boy.prototype.constructor <span class="token operator">=</span> Boy<span class="token punctuation">;</span>//避免原型错乱var boy <span class="token operator">=</span> new Boy<span class="token punctuation">(</span>12,<span class="token string">'ykx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>boy.eat<span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>boy.drink<span class="token punctuation">(</span><span class="token string">'water'</span><span class="token punctuation">)</span></code></pre><p>原型错乱：</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">function</span> SuperType<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">function</span> Sub<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    SuperType.call<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">}</span>Sub.prototype <span class="token operator">=</span> Object.create<span class="token punctuation">(</span>SuperType.prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>console.dir<span class="token punctuation">(</span>Sub<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>结果如下：<br><img src="https://img-blog.csdnimg.cn/20191113175800937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MTM0NzIx,size_16,color_FFFFFF,t_70" alt="原型错乱"><br>正确的继承结果应该如下：<br><img src="https://img-blog.csdnimg.cn/20191113175921976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MTM0NzIx,size_16,color_FFFFFF,t_70" alt="原型正常"></p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php和mySql</title>
      <link href="/2019/11/12/Php/mysql/"/>
      <url>/2019/11/12/Php/mysql/</url>
      
        <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>通过PHP，开发者可以和数据库相连。<br>在PHP5.0版本以后，官方推荐一下两种方式进行PHP和数据库的连接：</p><ul><li>MySQLi extension (“i” 意为 improved)：MySQLi 只针对 MySQL 数据库</li><li>PDO (PHP Data Objects)：PDO 应用在 12 种不同数据库中<br>因为我这里只安装了mySql，所以本文栗子均以第一种方式进行操作。</li></ul><h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><p>在访问数据库之前，我们需要进行数据库的连接</p><pre class=" language-bash"><code class="language-bash"><span class="token variable">$serverName</span> <span class="token operator">=</span> <span class="token string">'localhost'</span><span class="token punctuation">;</span>//数据库地址<span class="token variable">$serverRoot</span> <span class="token operator">=</span> <span class="token string">'root'</span><span class="token punctuation">;</span>//数据库登录名称<span class="token variable">$passWord</span> <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>//数据库密码<span class="token variable">$dbName</span> <span class="token operator">=</span> <span class="token string">"myDB"</span><span class="token punctuation">;</span><span class="token variable">$conn</span> <span class="token operator">=</span> new mysqli<span class="token punctuation">(</span><span class="token variable">$serverName</span>,<span class="token variable">$userName</span>,<span class="token variable">$userPassword</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//连接失败if<span class="token punctuation">(</span><span class="token variable">$conn</span>-<span class="token operator">></span>connect_error<span class="token punctuation">)</span><span class="token punctuation">{</span>    die<span class="token punctuation">(</span><span class="token string">"数据库连接失败："</span><span class="token keyword">.</span><span class="token variable">$conn</span>-<span class="token operator">></span>connect_error<span class="token punctuation">)</span><span class="token punctuation">}</span>mysqli_set_charset<span class="token punctuation">(</span><span class="token variable">$this</span>-<span class="token operator">></span>conn, <span class="token string">"utf8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//设置字符编码为utf8格式 否则汉字可能出现乱码的情况//数据库操作完成之后 一定记得关闭数据库的连接<span class="token variable">$conn</span>-<span class="token operator">></span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h4><p>1、创建数据库：<code>$sql = &quot;CREATE DATABASE IF NOT EXISTS dbname&quot;</code><br>2、创建表：上面的连接语句要修改下，加个参数，用来选择数据库：</p><pre class=" language-bash"><code class="language-bash"><span class="token variable">$conn</span> <span class="token operator">=</span> new mysqli<span class="token punctuation">(</span><span class="token variable">$serverName</span>,<span class="token variable">$userName</span>,<span class="token variable">$userPassword</span>,<span class="token variable">$dbName</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$sql</span> <span class="token operator">=</span> <span class="token string">"CREATE TABLE MyGuests (id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY, firstname VARCHAR(30) NOT NULL,lastname VARCHAR(30) NOT NULL,email VARCHAR(50),reg_date TIMESTAMP)"</span><span class="token punctuation">;</span></code></pre><p>属性说明：</p><ul><li>NOT NULL - 每一行都必须含有值（不能为空），null 值是不允许的。</li><li>DEFAULT value - 设置默认值</li><li>UNSIGNED - 使用无符号数值类型，0 及正数</li><li>AUTO INCREMENT - 设置 MySQL 字段的值在新增记录时每次自动增长 1</li><li>PRIMARY KEY - 设置数据表中每条记录的唯一标识。 通常列的 PRIMARY KEY 设置为 ID 数值，与 AUTO_INCREMENT 一起使用。<br>每个表都应该有一个主键(本列为 “id” 列)，主键必须包含唯一的值</li></ul><p>3、插入数据：<code>$sql=&#39;INSERT INTO table_name (column1, column2, column3,...)VALUES (value1, value2, value3,...)&#39;</code><br>4、插入多条数据：</p><pre class=" language-bash"><code class="language-bash"><span class="token variable">$sql</span> <span class="token operator">=</span> <span class="token string">"INSERT INTO student (column1, column2, column3,...)VALUES (value1, value2, value3,...);"</span><span class="token punctuation">;</span><span class="token variable">$sql</span>.<span class="token operator">=</span><span class="token string">"INSERT INTO student (column1, column2, column3,...)VALUES (value1, value2, value3,...);"</span><span class="token punctuation">;</span><span class="token variable">$sql</span>.<span class="token operator">=</span><span class="token string">"INSERT INTO student (column1, column2, column3,...)VALUES (value1, value2, value3,...);"</span><span class="token punctuation">;</span></code></pre><p>注意：sql语句之间用;隔开</p><p>5、查询数据：<code>$sql = &#39;SELECT * FROM  myDB;&#39;</code><br>6、更新数据：<br><code>UPDATE table_nameSET column1=value, column2=value2,...WHERE some_column=some_value</code><br>7、删除数据：<code>DELETE FROM table_nameWHERE some_column = some_value</code></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
          <category> mySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> mySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建</title>
      <link href="/2019/11/11/Hexo/index/"/>
      <url>/2019/11/11/Hexo/index/</url>
      
        <content type="html"><![CDATA[<h4 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h4><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul><li><p>Node（本文不做多余叙述）</p></li><li><p>Git（本文不做多余叙述）</p></li><li><p>Hexo<br><code>$ npm install -g hexo-cli</code><br>安装完成后，到一个新的文件夹下，打开Git Bash，执行一下命令：</p><pre><code>$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install</code></pre><p>新建完成之后，打开新建的项目，查看项目目录：</p></li><li><p>public：执行hexo generate命令，生成的HTML静态文件</p></li><li><p>scaffolds：模版文件夹</p></li><li><p>source：资源文件夹，文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里</p><ul><li>_data：你的数据文件夹，例如：<ul><li>friends.json：存放友情链接的数据</li><li>musics.json：存放音乐播放器的数据</li></ul></li><li>_posts：文章存放文件夹</li><li>categories：分类</li><li>tags：标签<ul><li>thems：主题文件夹，Hexo 会根据主题来生成静态页面。以我当前使用的metery主题为例</li><li>langauages：存放语言相关设置的yml文件</li><li>layout：存放文章的ejs模版，可以在里面修改相关的HTML、CSS、JS等</li><li>source：该主题下使用的资源文件夹</li><li>_config.yml：该主题的配置文件</li></ul></li></ul></li></ul><ul><li>_config.yml：该项目的配置文件</li><li>db.json：source解析所得到的</li><li>package.json：项目所需模块项目的配置信息</li></ul><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><ul><li>GitHub上新建一个项目</li><li>本地Git Bash上配置github账户信息<ul><li><code>git config --global user.name &#39;yourName&#39;</code></li><li><code>git config --global user.email &#39;yourEmail&#39;</code><ul><li>创建SSH</li><li>在gitbash中输入：</li><li><code>ssh-keygen -t rsa -C &quot;youremail@example.com</code>，生成ssh。</li><li><code>cd ~/.ssh</code> 找到id_rsa.pub</li><li><code>cat id_rsa.pub</code>复制其中的内容到github上，创建一个新的 SSH KEY</li></ul></li></ul></li></ul><ul><li>修改_config.yml<pre><code>deploy:type: gitrepo: https://github.com/YourgithubName/YourgithubName.github.io.gitbranch: master</code></pre></li><li>回到Git Bash<pre><code>npm i hexo-serverhexo cleanhexo generatehexo server</code></pre></li><li>上传到GitHub<pre><code>npm install hexo-deployer-git --savehexo cleanhexo generatehexo deploy</code></pre>注意deploy的过程中要输入你的username及passward。<br>然后在浏览器中输入 <a href="http://yourgithubname.github.io" target="_blank" rel="noopener">http://yourgithubname.github.io</a> 就可以看到你的个人博客。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php基础</title>
      <link href="/2019/11/11/Php/base/"/>
      <url>/2019/11/11/Php/base/</url>
      
        <content type="html"><![CDATA[<h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><p>（全称：PHP：Hypertext Preprocessor，即”PHP：超文本预处理器”）是一种通用开源脚本语言。</p><h4 id="PHP的作用"><a href="#PHP的作用" class="headerlink" title="PHP的作用"></a>PHP的作用</h4><ul><li>PHP 可以生成动态页面内容</li><li>PHP 可以创建、打开、读取、写入、关闭服务器上的文件<ul><li>PHP 可以收集表单数据</li><li>PHP 可以发送和接收 cookies</li><li>PHP 可以添加、删除、修改您的数据库中的数据</li><li>PHP 可以限制用户访问您的网站上的一些页面</li><li>PHP 可以加密数据</li></ul></li></ul><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><pre><code>&lt;?php    $x=5;    $y=6;    $z=$x+$y;    echo $z;?&gt;</code></pre><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p>PHP有四种不同的变量作用域：</p><ul><li>local：局部作用域。在 PHP 函数内部声明的变量是局部变量，仅能在函数内部访问</li><li>global：全局作用域。在所有函数外部定义的变量，拥有全局作用域。除了函数外，全局变量可以被脚本中的任何部分访问，要在一个函数中访问一个全局变量，需要使用 global 关键字。</li><li>static：当一个函数完成时，它的所有变量通常都会被删除。然而，有时候我们希望某个局部变量不要被删除，可以使用static</li><li>parameter：参数作用域。参数是通过调用代码将值传递给函数的局部变量。参数是在参数列表中声明的，作为函数声明的一部分</li></ul><h4 id="局部和全局作用域"><a href="#局部和全局作用域" class="headerlink" title="局部和全局作用域"></a>局部和全局作用域</h4><pre><code>$x = 5;//全局变量function test(){    global $x;//使用global关键字 使用全局变量    static $n = 0;//局部变量    $y = 10;//局部变量    $n++;    echo &#39;x: &#39;.$x.&#39;&lt;br/&gt;&#39;;    echo &#39;y: &#39;.$y.&#39;&lt;br/&gt;&#39;;    echo $n.&#39;&lt;br /&gt;&#39;;};test();test();test();</code></pre><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>常量值被定义后，在脚本的其他任何地方都不能被改变。常量是一个简单值的标识符。该值在脚本中不能改变。<br>一个常量由英文字母、下划线、和数字组成,但数字不能作为首字母出现。 (常量名不需要加 $ 修饰符)。<br>设置常量，使用 define() 函数，函数语法如下：</p><blockquote><p>bool define ( string $name , mixed $value [, bool $case_insensitive = false ] )<br>该函数有三个参数:</p></blockquote><ul><li>name：必选参数，常量名称，即标志符</li><li>value：必选参数，常量的值</li><li>case_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的</li></ul><pre><code>&lt;?phpdefine(&quot;GREETING&quot;, &quot;欢迎访问 Runoob.com&quot;);echo GREETING;    // 输出 &quot;欢迎访问 Runoob.com&quot;echo &#39;&lt;br&gt;&#39;;echo greeting;   // 输出 &quot;greeting&quot;?&gt;</code></pre><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li>字符串</li><li>整型：整数是一个没有小数的数字</li><li>浮点型：浮点数是带小数部分的数字，或是指数形式。</li><li>布尔型</li><li>数组</li><li>对象：在 PHP 中，对象必须声明。首先，你必须使用class关键字声明类对象。类是可以包含属性和方法的结构。然后我们在类中定义数据类型，然后在实例化的类中使用数据类型</li><li>NULL</li></ul>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
