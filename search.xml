<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浏览器输入URL到页面加载完成</title>
      <link href="/2020/02/20/Interview/01/"/>
      <url>/2020/02/20/Interview/01/</url>
      
        <content type="html"><![CDATA[<h1 id="从输入URL到页面加载完成的过程"><a href="#从输入URL到页面加载完成的过程" class="headerlink" title="从输入URL到页面加载完成的过程"></a>从输入URL到页面加载完成的过程</h1><h2 id="主干流程"><a href="#主干流程" class="headerlink" title="主干流程"></a>主干流程</h2><ol><li><strong>浏览器接收url，开启一个新的网络请求线程（这部分涉及到浏览器进程与线程之间的关系）。</strong></li><li><strong>从开启网络请求线程到发起一个http请求（这部分涉及到dns解析、五层因特网协议栈、tcp/ip协议等）。</strong></li><li><strong>从服务器接收到一个请求到后台收到请求（这部分涉及到负载均衡、安全拦截、后台程序内部处理等知识）。</strong></li><li><strong>服务端和浏览器之间的交互（如http请求头、状态码、请求报文、cookie、session等）。</strong></li><li><strong>http缓存（包括强缓存、协商缓存等）。</strong></li><li><strong>CSS的可视化模型解析（元素的渲染规则、包含块、控制块、BFC、IFC等）。</strong></li><li><strong>JS的解析过程（JS的解释过程、预处理过程、执行阶段的GO、VO、AO、作用域和作用域连等）。</strong></li><li><strong>其它（如安全策略、跨域等）</strong></li></ol><h2 id="从浏览器接收url到开启网络请求线程"><a href="#从浏览器接收url到开启网络请求线程" class="headerlink" title="从浏览器接收url到开启网络请求线程"></a>从浏览器接收url到开启网络请求线程</h2><h3 id="多进程的浏览器"><a href="#多进程的浏览器" class="headerlink" title="多进程的浏览器"></a>多进程的浏览器</h3><p>浏览器是多进程的，有一个主控进程，每一个tab页都会新开一个进程。<br>这些进程可能包括：主控进程、插件进程、GPU、tab页等。</p><ul><li>Browser进程：浏览器的主进程，负责调控，只有一个。</li><li>GPU进程：负责3D渲染，最多只有一个。</li><li>第三方插件进程：负责管理第三方插件，每一个插件都有一个对应的进程，仅当该插件创建时创建。</li><li>浏览器渲染进程（浏览器内核）：默认每个tab页一个进程，互不干扰，负责控制页面渲染、脚本执行、事件处理等。</li></ul><h3 id="浏览器内核的五大线程"><a href="#浏览器内核的五大线程" class="headerlink" title="浏览器内核的五大线程"></a>浏览器内核的五大线程</h3><p>每一个tab页都可以看作一个浏览器内核进程，而该进程包含多个线程：</p><ul><li>GUI线程：负责页面渲染、重绘、CSS解析等。</li><li>JS引擎线程：负责程序脚本的解析和执行。</li><li>事件触发线程：负责管理事件循环，管理事件任务队列。</li><li>定时触发器线程：setTImeout 和 setInterval 所在的线程。定时器的计时不是有JS引擎控制，而是由该线程控制。</li><li>http请求线程：负责http请求。</li></ul><h4 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h4><p>Q：为什么JS引擎线程和GUI线程互斥？<br>A：因为JS是可以操作DOM的，如果在JS操作DOM的同时，GUI线程也在渲染页面，那么元素最终的呈现可能就不会和我们预期的一致了。<br>Q：为什么JS引擎是单线程？<br>A：1、创建JavaScript语言的时候，多进程多线程并不流行，硬件支持度不高。<br>    2、多进程多线程使用时需要加锁，实施成本高。<br>    3、如果多个线程同时操作一个DOM元素，可能元素的最终呈现不会如预期一样。<br>    4、线程之间资源共享。<br>具体可以参考这篇<a href="https://www.yuque.com/walter-glskq/zf7grn/guyw1x" target="_blank" rel="noopener">文章</a>。</p><h3 id="解析URL"><a href="#解析URL" class="headerlink" title="解析URL"></a>解析URL</h3><p>当用户输入URL之后，会进行解析（URL的本质是统一资源标识符）。<br>URL一般包含这几部分：</p><ul><li>protocol：协议头，如http、https 、ftp等。</li><li>host：指定主机域名或者IP地址。</li><li>port：端口号。</li><li>path：资源路径。</li><li>query：查询参数。</li><li>fragment：即#之后的hash值，一般用来定位到某个位置。</li></ul><h3 id="网络请求都是单独的线程"><a href="#网络请求都是单独的线程" class="headerlink" title="网络请求都是单独的线程"></a>网络请求都是单独的线程</h3><p>每次网络请求都会开辟一个新的线程进行，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载，<br>因此浏览器会根据解析到的http协议去单独开辟出新的网络线程，前往请求资源。</p><h2 id="从开启网络线程到发起http请求"><a href="#从开启网络线程到发起http请求" class="headerlink" title="从开启网络线程到发起http请求"></a>从开启网络线程到发起http请求</h2><p>这一部分主要包含dns解析、tcp/ip请求构建、五层因特网协议栈等。</p><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>如果用户输入的是域名，那么就需要进行dns解析获取对应的IP地址，具体步骤如下：</p><ol><li>如果浏览器有缓存，就使用浏览器缓存；否则使用本机缓存，再没有就使用host。</li><li>如果本地没有缓存，就向dns服务器查询，（查询中可能会使用路由等，路由也是有缓存的，如果有，则使用），获取IP地址。</li></ol><p>注意：域名查询可能经过dns调度器的。而且dns查询是很耗时，如果解析域名较多，那么网站的首屏加载就会变得很慢，这时可以考试使用<code>dns-prefetch</code>，这一点请参考<a href="https://www.cnblogs.com/goloving/p/9368965.html" target="_blank" rel="noopener">这里</a>。</p><h3 id="TCP-IP请求"><a href="#TCP-IP请求" class="headerlink" title="TCP/IP请求"></a>TCP/IP请求</h3><p>http请求本质上还是tcp/ip请求。<br>tcp将http长报文划分为短报文，通过三次握手与服务器建立连接，进行可靠传输。</p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1582018099404-452e08b5-fc6b-4686-9893-7d0b2eaa0183.png" alt="image.png"><br>TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。TCP在发送数据前必须在彼此间建立连接，这里连接意思是：双方需要内保存对方信息（例如：IP，Port…）。</p><p>报文主要段的意思：</p><ul><li>序号seq：发送的数据字节流，确保TCP连接传输有序，对每个字节编号。序列号seq就是这个报文段中的第一个字节的数据编号。</li><li>确认序号ack：发送方期待接收的下一序列号，接收成功后序列号加1，只有ACK为1时，才有效。</li><li>确认ACK：仅当ACK为1时确认号才有效，为0时无效。</li><li>同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时，指的是这是一个请求报文段，若统一连接，则SYN=1，ACK=1。因此，SYN=1，表示这是一个请求连接，或者连接接收报文。SYN只有在建立连接时才会被置为1，握手结束之后置为0.</li><li>终止FIN：用于释放连接。当FIN=1时，表示此报文段的发送方的数据已经发送完毕，并要求释放连接。</li></ul><p>PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。</p><table><thead><tr><th align="center">字段</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">URG</td><td align="center">紧急指针是否有效。为1，表示某一位需要被优先处理</td></tr><tr><td align="center">ACK</td><td align="center">确认号是否有效，一般置为1。</td></tr><tr><td align="center">PSH</td><td align="center">提示接收端应用程序立即从TCP缓冲区把数据读走。</td></tr><tr><td align="center">RST</td><td align="center">对方要求重新建立连接，复位。</td></tr><tr><td align="center">SYN</td><td align="center">请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1</td></tr><tr><td align="center">FIN</td><td align="center">希望断开连接。</td></tr></tbody></table><p><img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1582018876320-c8e1eeaa-ca19-4344-9744-f2044a9bd6e0.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_a2Fr,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></p><ol><li>第一次握手：建立连接时，客户端发送初始序号seq=x，SYN=1请求标志。让服务器知道客户端发送，自己接收正常。</li><li>第二次握手：服务器发送请求标志SYN，发送确认标志ACK，服务器自己的序号seq，发送客户端的确认标志ack：SYN=1，ACK=1，seq=y，ack=x + 1。让客户端知道自己接收、发送正常，服务器接收、发送正常。</li><li>第三次握手：客户端发送确认标志ACK，自己的序号seq，发送服务端的确认序号ack：ACK=1，seq=x+1，ack=y+1。让服务器知道客户端发送、接收，自己发送、接收正常。</li></ol><p>从上面可知，三次握手是让服务器和客户端知道彼此双方发送、接收能力正常的最少握手次数。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1582019583668-d848c108-a4f3-4188-b8f3-c7fda16138e9.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_a2Fr,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="image.png"></p><p>四次挥手过程解析：</p><ol><li>第一次挥手：客户端主动请求断开，向服务端发送FIN=1，seq=u，进入FIN-WAIT-1状态。</li><li>第二次挥手：服务端接收到客户端发送的信息，发送确认序号ACK=1，客户端的确认号ack=u+1，自己的序号seq=v。并且进入CLOSE-WAIT状态。</li><li>第三次挥手：客户端接收到服务端的信息后，进入FIN-WAIT-2状态。此时服务器发送释放FIN=1信号，发送确认标志ACK=1，自己的序号seq=w，客户端的确认号ack=u+1。并且自己进入LAST-ACT状态（最好确认状态）。</li><li>第四次挥手：客户端收到服务端信息后，发送确认标志ACK=1，自己的序号seq=u+1，服务端的确认号ack=w+1。客户端进入TIME-WAIT状态。等待2MSL（2个最长报文段寿命）之后，进入CLOSE状态。服务端收到确认后，也进入CLOSE状态。</li></ol><h4 id="QA-1"><a href="#QA-1" class="headerlink" title="QA"></a>QA</h4><p>Q：为什么三次握手和四次挥手？<br>A：三次握手时，服务器同时把ACK和SYN放在一起发送到了客户端那里。四次挥手时，当收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方 ACK 和 FIN 一般都会分开发送。<br>Q：为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？<br>A：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。<br>Q：如果已经建立了连接，但是客户端突然出现故障了怎么办？<br>A：TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h4 id="tcp-ip的并发限制"><a href="#tcp-ip的并发限制" class="headerlink" title="tcp/ip的并发限制"></a>tcp/ip的并发限制</h4><p>浏览器针对同一个域名下的tcp连接是有限制的（一般是5-20个）。而且在http1.0中，一个资源下载就对应着一个tcp/ip连接。</p><h4 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h4><p>get和post本质上都是tcp/ip，但是两者除了在http层面上的不同，在tcp/ip层面也有区别。<br>get会产生一个tcp包，而post会产生两个：</p><ul><li>get请求时会把headers和data一起发送出去，服务器响应200。</li><li>post请求会先把headers发送出去，服务器响应100 continue，然后浏览器在发送data，服务器响应200。</li></ul><p>其他区别：</p><table><thead><tr><th>分类</th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>可否被缓存</td><td>可以被缓存</td><td>不可以被缓存</td></tr><tr><td>后退或刷新</td><td>无害</td><td>重新提交请求</td></tr><tr><td>编码类型</td><td>application/x-www-form-urlencoded</td><td>application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td></tr><tr><td>历史</td><td>会被保留在浏览器历史记录中</td><td>不会被保留在浏览器历史记录中</td></tr><tr><td>对数据类型的限制</td><td>只允许ASCII字符</td><td>无限制</td></tr><tr><td>安全性</td><td>与POST比，安全性较差，因为发送的数据会暴露在地址栏中</td><td>POST比GET较安全</td></tr><tr><td>可见性</td><td>可见</td><td>不可见</td></tr></tbody></table><h3 id="五层因特网协议"><a href="#五层因特网协议" class="headerlink" title="五层因特网协议"></a>五层因特网协议</h3><p>从客户端发出http请求到服务器接收，这中间会经过一系列的过程：<br><strong>从应用层发出http请求，到传输层经过三次握手建立tcp连接，再到网络层的IP寻址，再到数据链路层封装成帧，最后经由物理层传输。</strong><br>五层因特网协议栈其实就是：</p><ol><li>应用层（dns http）DNS解析IP并发送http请求。</li><li>传输层（tcp udp）经过三次握手，建立tcp连接。</li><li>网络层（IP ARP）IP寻址。</li><li>数据链路层（PPP）封装成帧。</li><li>物理层（利用无力介质传输比特流）物理传输（然后传输的时候通过双绞线，电磁波等介质）。</li></ol><p>相比于完整的IOS/OSI七层框架，少了表示层和会话层。<br>OSI七层框架：<code>物理层</code>、<code>数据链路层</code>、<code>网络层</code>、<code>传输层</code>、<code>会话层</code>、<code>表示层</code>、<code>应用层</code></p><ol><li>表示层：主要处理两个通讯系统之间的信息交换的表示方式，包括数据格式交换、数据加密解密等。</li><li>会话层：它管理不同用户的进程之间的对话，如登录、注销等。</li></ol><h2 id="从服务器接收请求到后台接收到请求"><a href="#从服务器接收请求到后台接收到请求" class="headerlink" title="从服务器接收请求到后台接收到请求"></a>从服务器接收请求到后台接收到请求</h2><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>对于一个大型项目来说，它的并发访问量可能会很大，所以如果只有一台服务器可能是吃不消的，所以一般会有若干个服务器组成一个集群，然后配合反向代理服务器实现负载均衡。<br>简单来说：<strong>就是用户的请求都会指向一个反向代理服务器，如nginx，然后代理服务器按照指定的算法，分配不同的请求给对应集群中的服务器执行，然后反响代理服务器等待服务器的http响应，并将其反应给用户。</strong><br>**</p><h3 id="后台处理"><a href="#后台处理" class="headerlink" title="后台处理"></a>后台处理</h3><p>一般后台都是部署到一个容器中，所以：</p><ul><li>先是容器接收到请求（如tomcat），</li><li>然后对应容器中的程序接收到请求（如java、php等），</li><li>然后就是后台程序中的内部处理，处理完成之后响应结果。</li></ul><p>一般后台都会有统一的验证：安全拦截、跨域处理等，如果验证不通过，则直接拒绝请求。如果验证通过，才会进入后台程序，后台程序进行对应的操作，如数据查询等。等程序执行完毕之后，会返回一个http包，然后将这个包发送给前端，完成交互。</p><h3 id="后台和前台的交互"><a href="#后台和前台的交互" class="headerlink" title="后台和前台的交互"></a>后台和前台的交互</h3><p>前后端交互的时候，http报文作为最重要的信息载体。</p><h4 id="http报文结构"><a href="#http报文结构" class="headerlink" title="http报文结构"></a>http报文结构</h4><p>报文一般包括了通用头部、请求/响应头部、请求/响应体</p><h5 id="通用头部"><a href="#通用头部" class="headerlink" title="通用头部"></a>通用头部</h5><ul><li>Request Url：请求的web服务器地址。</li><li>Request Method：请求方式（GET、POST、PUT、DELETE、HEAD、CONNECT、TRACE）。</li><li>Status Code：请求返回的状态码。</li><li>Remote Address：请求的远程服务器地址（会被转为IP）。</li></ul><p>其中methods一般可以分为两批次：</p><ul><li>HTTP1.0定义了三种请求方法：GET、POST和HEAD方法以及几种额外的请求方式（PUT、DELETE、LINK和UNLINK）。HTTP1.0具体定义请参考：<a href="https://tools.ietf.org/html/rfc1945" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc1945</a>。</li><li>HTTP1.1定义了八种请求方式：GET、POST、PUT、DELETE、HEAD、CONNECT、TRACE。HTTP1.1具体定义请参考：<a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc2616</a>。</li></ul><h5 id="常用状态码"><a href="#常用状态码" class="headerlink" title="常用状态码"></a>常用状态码</h5><pre><code>200-请求成功。请求的资源已返回客户端。301-永久重定向。302-临时重定向。304-表明自上次请求之后，资源未做变更，请使用本地缓存的资源。400-客户端请求出错。401-请求未经授权。403-禁止访问。404-请求资源不存在。500-服务器内部错误。503-服务器不可用。......</code></pre><p>最后列举下大致不同范围的状态码：</p><pre><code>1xx：指示信息，表示请求已接受，正在处理。2xx：请求已被成功接收。3xx：重定向，要完成请求需要进一步的操作。4xx：客户端错误，请求语法错误或者请求无法实现。5xx：服务端错误，服务器实现合法的请求。</code></pre><h4 id="请求-响应头部"><a href="#请求-响应头部" class="headerlink" title="请求/响应头部"></a>请求/响应头部</h4><p>常用的请求头部：</p><pre><code>Accept：接收类型。表示浏览器可以支持的MIME类型（对标服务器返回的Content-Type）。Accept-Encodeing：浏览器支持的压缩类型，如GZip，超出类型不能接收。ConContent-Type：客户端发出去的实体内容的类型。Cache-Control：指定请求和响应应遵循的缓存机制，如no-cache等。If-Modifiy-Since：对应服务端的Last-Modified，用于比较服务器资源文件是否发生变动，精确到1s，http1.0。Expires：缓存控制。设置资源的有效期，有效时间内可以直接使用缓存。使用的是服务端时间，http1.0。Max-age：代表资源在本地的有效时间，有效时间内不会请求，http1.1。If-None-Match：对应服务端的ETag，用于匹配文件内容是否发生改变，比较精确，http1.1。Cookie：有cookie且同域名访问时会带上。Connection：当浏览器与服务器通信时对于长连接如何进行处理，如keep-alive。Host：请求的服务器地址。Origin：请求最初从哪里发起的。Origin比Referer更尊重隐私。Referer：该页面的来源URL（CSRF拦截常用该字段）。User-Agent：用户客户端的信息。</code></pre><p>常用的响应头部：</p><pre><code>Access-Control-Allow-Headers：服务器允许的请求headers。Access-Control-Allow-Methods：服务器允许的请求方式。Access-Control-Allow-Methods：服务器允许的请求Origin头部（如*）。Content-Type：服务器返回的响应内容实体的类型。Date：数据从服务器返回的时间。Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档。Last-Modified：请求资源最后的修改时间。Expires：告诉浏览器应该在什么时候放弃使用资源，从而不在缓存它。Max-age：告诉浏览器应该缓存多长时间，开启Cache-Control有效。ETag：请求资源的文件指纹。Set-cookie：设置该页面的cookie，服务器通过这个设置浏览器页面的cookie。Keep-Alive：如果浏览器有keep-alive，那么服务器也有对应的keep-alive。Server：服务器的一些信息。</code></pre><p>一般来说，请求头部和响应头部都是匹配分析的<br>如：请求头部的Accept要和响应头部的Content-Type是要匹配的，否则就会报错。<br>如：跨域请求时，请求头部的Origin要和响应头部的Access-Control-Allow-Origin匹配，否则回报跨域错误。<br>再比如：缓存时，请求头部的If-Modified-Since和ETag，要与响应头部的Last-Modified和If-None-Match相匹配。</p><h4 id="请求和响应实体"><a href="#请求和响应实体" class="headerlink" title="请求和响应实体"></a>请求和响应实体</h4><p>http请求时，除了头部，还有消息实体，一般来说<br>请求实体中会将一些需要的参数都放入进入（用于post请求）。<br>譬如实体中可以放参数的序列化形式（<code>a=1&amp;b=2</code>这种），或者直接放表单对象（<code>Form Data</code>对象，上传时可以夹杂参数以及文件），等等<br>而一般响应实体中，就是放服务端需要传给客户端的内容<br>一般现在的接口请求时，实体中就是对于的信息的json格式，而像页面请求这种，里面就是直接放了一个html字符串，然后浏览器自己解析并渲染。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1582102205845-08bbd0a9-cfb7-4e35-951c-3ede3cb2e7bd.png#align=left&display=inline&height=933&name=image.png&originHeight=800&originWidth=596&size=402292&status=done&style=none&width=695" alt="image.png"></p><h4 id="cookie及相关优化"><a href="#cookie及相关优化" class="headerlink" title="cookie及相关优化"></a>cookie及相关优化</h4><p>cookie 是一种本地存储方式，主要用于浏览器和服务器通信，常用于验证身份，和服务端的session搭配使用。<br>场景如下（简述）：</p><pre><code>在登陆页面，用户登陆了此时，服务端会生成一个session，session中有对于用户的信息（如用户名、密码等）然后会有一个sessionid（相当于是服务端的这个session对应的key）然后服务端在登录页面中写入cookie，值就是:jsessionid=xxx然后浏览器本地就有这个cookie了，以后访问同域名下的页面时，自动带上cookie，自动检验，在有效时间内无需二次登陆</code></pre><p>上述就是cookie的常用场景简述（当然了，实际情况下得考虑更多因素）。<br>一般来说，cookie中是不允许存放敏感信息的，如帐号，密码等。如果非要存储，一定要在cookie 中这只httpOnly，这样就无法通过js操作获取cookie了。<br>另外，在同域名操作时，总会默认带上该域名下所有的cookie。针对这种情况，在某些场景中是需要优化的：</p><p>比如以下场景：</p><pre><code>客户端在域名A下有cookie（这个可以是登陆时由服务端写入的）然后在域名A下有一个页面，页面中有很多依赖的静态资源（都是域名A的，譬如有20个静态资源）此时就有一个问题，页面加载，请求这些静态资源时，浏览器会默认带上cookie也就是说，这20个静态资源的http请求，每一个都得带上cookie，而实际上静态资源并不需要cookie验证此时就造成了较为严重的浪费，而且也降低了访问速度（因为内容更多了）</code></pre><p>针对这种场景，我们可以使用域名拆分的方案：将静态资源分组，分别存放到不同的服务器中。<br>而在移动端，如果请求的域名过多时，会降低请求速度（因为域名解析是很耗时的，而且移动端的带宽大都不如pc），这时我们可以使用dns-prefetch，让浏览器空闲时提前解析域名。<br>关于cookie 的操作大致可以如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1582103208942-51d8603a-aef1-436c-968a-804cff71baa1.png#align=left&display=inline&height=350&name=image.png&originHeight=527&originWidth=800&size=96045&status=done&style=none&width=531" alt="image.png"></p><h4 id="gzip压缩"><a href="#gzip压缩" class="headerlink" title="gzip压缩"></a>gzip压缩</h4><p>首先，明确<code>gzip</code>是一种压缩格式，需要浏览器支持才有效（不过一般现在浏览器都支持），<br>而且gzip压缩效率很好（高达70%左右）<br>然后gzip一般是由<code>apache</code>、<code>tomcat</code>等web服务器开启<br>当然服务器除了gzip外，也还会有其它压缩格式（如deflate，没有gzip高效，且不流行）<br>所以一般只需要在服务器上开启了gzip压缩，然后之后的请求就都是基于gzip压缩格式的，<br>非常方便。</p><h4 id="长连接与短连接"><a href="#长连接与短连接" class="headerlink" title="长连接与短连接"></a>长连接与短连接</h4><p>首先看<code>tcp/ip</code>层面的定义：</p><ul><li>长连接：一个tcp/ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）</li><li>短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接</li></ul><p>然后在http层面：</p><ul><li><code>http1.0</code>中，默认使用的是短连接，也就是说，浏览器没进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接</li><li>http1.1起，默认使用长连接，使用长连接会有这一行<code>Connection: keep-alive</code>，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输http的tcp连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接。</li></ul><p>注意： <strong>keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效。</strong></p><h4 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h4><p>http2.0不是https，它是http的下一代规范。<br>简述一下http2.0和http1.1的区别：</p><ul><li>http1.1中，每请求一个资源，都需要新开一个tcp/ip连接，所以对应的结果就是每一个资源都占用一个tcp/ip请求，而tcp/ip请求并发数量是有限制的，当请求资源数量一多，请求速度就会慢下来。</li><li>http2.0中，一个tcp/ip请求可以请求多个资源，也就是说，只要一次tcp/ip请求，就可以请求诺干个资源，分割成更小的帧请求，速度会有显著提升。</li></ul><p>所以，如果http2.0得到全面的使用，那么http1.1中的很多优化手段就不必在使用了，比如：使用雪碧图，静态资源多域名拆分等。<br>http2.0的特性：</p><ol><li>多路复用（即一个tcp/ip请求可以请求多个资源）。</li><li>首部压缩（http头部压缩，减少体积）。</li><li>二进制分帧（在应用层和传输层使用二进制分帧，改善传输性能，实现低延迟和高吞吐量）。</li><li>服务器推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）。</li><li>请求优先级（如果流被赋予了优先级，那么它就会基于这个优先级被处理，且由服务器决定使用多少资源来处理这个流）。</li></ol><h4 id="https"><a href="#https" class="headerlink" title="https"></a>https</h4><p>https是安全版本的http。譬如一些支付等操作都是基于https的，http的安全性太低。<br>简单来说，https和http的区别就是在请求建立连接之前，先建立ssl连接，确保之后的通信都是加密的，无法被轻易截取分析。<br>一般来说，如果要将网站升级成https，需要后端支持（后端需要申请证书等），然后https的开销也比http要大（因为需要额外建立安全链接以及加密等），所以一般来说http2.0配合https的体验更佳（因为http2.0更快了）。</p><pre><code>1、浏览器请求建立SSL链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如RSA加密，此时是明文传输。 2. 服务端从中选出一组加密算法与Hash算法，回复一个随机数–Server random，并将自己的身份信息以证书的形式发回给浏览器（证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息）3. 浏览器收到服务端的证书后    - 验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁头，否则会有提示    - 用户接收证书后（不管信不信任），浏览会生产新的随机数–Premaster secret，然后证书中的公钥以及指定的加密方法加密`Premaster secret`，发送给服务器。    - 利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key-`session key`    - 使用约定好的HASH算法计算握手消息，并使用生成的`session key`对消息进行加密，最后将之前生成的所有信息发送给服务端。 4. 服务端收到浏览器的回复    - 利用已知的加解密方式与自己的私钥进行解密，获取`Premaster secret`    - 和浏览器相同规则生成`session key`    - 使用`session key`解密浏览器发来的握手消息，并验证Hash是否与浏览器发来的一致    - 使用`session key`加密一段握手消息，发送给浏览器5. 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束。</code></pre><p><strong>之后所有的https通信数据将由之前浏览器生成的<code>session key</code>并利用对称加密算法进行加密。</strong><br><strong><img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1582123727413-3e3bbc49-a819-4229-8174-4bdcc8ced04b.png#align=left&display=inline&height=712&name=image.png&originHeight=773&originWidth=760&size=172844&status=done&style=none&width=700" alt="image.png"></strong></p><p><strong>图片来源于阮一峰的<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL/TSL协议</a></strong></p><h3 id="http缓存"><a href="#http缓存" class="headerlink" title="http缓存"></a>http缓存</h3><p>缓存可以被简单的划分为两类：强缓存（200 from cache）和协商缓存（304）。<br>区别：</p><ul><li>强缓存：如果浏览器判断本地缓存未过期的时候，将会直接使用本地缓存，不会发起请求。</li><li>协商缓存：浏览器会向服务器发起请求，在请求头部携带资源文件的缓存信息，如If-Modified-Since、ETag等，由服务器端判断，资源自从上次访问是否发生过变更，如果发生过变更，则返回状态码200，并将新的资源文件和缓存规则返回；如果未变更，返回304状态码，告诉浏览器使用本地缓存。</li></ul><h4 id="缓存头部概述"><a href="#缓存头部概述" class="headerlink" title="缓存头部概述"></a>缓存头部概述</h4><p>上面提到的强缓存和协商缓存，那么它们是如何进行区分的呢？<br>答案是通过不同的http头部控制。<br>这里列举一些常用的缓存头部：<br>用于强缓存控制的：</p><ul><li>http1.0: Pragma/Expires</li><li>http1.1: Cache-Control/Max-Age</li></ul><p>注意：<strong><code>Max-Age</code>不是一个头部，它是<code>Cache-Control</code>头部的值。</strong></p><p>用于协商缓存控制的：</p><ul><li>http1.0: Last-Modified/If-Modified-Since</li><li>http1.1：E-tag/If-None-Match</li></ul><p>再提一点，其实HTML页面中也有一个meta标签可以控制缓存方案-<code>Pragma</code></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>META</span> <span class="token attr-name">HTTP-EQUIV</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Pragma<span class="token punctuation">"</span></span> <span class="token attr-name">CONTENT</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>no-cache<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><p>不过，这种方案还是比较少用到，因为支持情况不佳，譬如缓存代理服务器肯定不支持，所以不推荐。</p><h4 id="头部的区别"><a href="#头部的区别" class="headerlink" title="头部的区别"></a>头部的区别</h4><h5 id="http1-0的缓存控制"><a href="#http1-0的缓存控制" class="headerlink" title="http1.0的缓存控制"></a>http1.0的缓存控制</h5><ul><li>Pragma：严格来说，它不属于专门的缓存控制头部，但是它设置<code>no-cache</code>时可以让本地强缓存失效（属于编译控制，来实现特定的指令，主要是因为兼容http1.0，所以以前又被大量应用）。</li><li>Expires：服务端配置的，属于强缓存，在规定的时间之前，浏览器端不会发起请求，而是使用本地缓存。注意，Expires一般对应服务器端时间，如<code>Expires：Fri, 30 Oct 1998 14:19:41</code>。</li><li>If-Modified-Since/Last-Modified：这两个是成堆出现的，属于协商缓存的内容。其中属于浏览器的头部内容是<code>If-Modified-Since</code>，而属于服务端的是<code>Last-Modified</code>。它的作用是，当服务器接收到请求时，如果二者匹配，则说明服务端资源未改变，可以使用本地缓存，只返回头部，状态码304。</li></ul><h5 id="http1-1的缓存控制"><a href="#http1-1的缓存控制" class="headerlink" title="http1.1的缓存控制"></a>http1.1的缓存控制</h5><ul><li>Cache-Control：缓存控制头部，属于强缓存，有no-cache、max-age等多个值。</li><li>Max-Age：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age是Cache-Control头部的值，不是独立的头部，譬如<code>Cache-Control: max-age=3600</code>，而且它值得是绝对时间，由浏览器自己计算。</li><li>If-None-Match/E-tag：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是<code>If-None-Match</code>，而服务端的是<code>E-tag</code>，同样，发出请求后，如果<code>If-None-Match</code>和<code>E-tag</code>匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于FileEtag INode Mtime Size生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。</li></ul><h4 id="Max-Age和Expires"><a href="#Max-Age和Expires" class="headerlink" title="Max-Age和Expires"></a>Max-Age和Expires</h4><p>Expires使用的是服务器端的时间<br>但是有时候会有这样一种情况-客户端时间和服务端不同步<br>那这样，可能就会出问题了，造成了浏览器本地的缓存无用或者一直无法过期<br>所以一般http1.1后不推荐使用<code>Expires</code><br>而<code>Max-Age</code>使用的是客户端本地时间的计算，因此不会有这个问题<br>因此推荐使用<code>Max-Age</code>。<br>注意，如果同时启用了<code>Cache-Control</code>与<code>Expires</code>，<code>Cache-Control</code>优先级高。</p><h4 id="E-tag和Last-Modified"><a href="#E-tag和Last-Modified" class="headerlink" title="E-tag和Last-Modified"></a>E-tag和Last-Modified</h4><p><code>Last-Modified</code>：</p><ul><li>表明服务端的文件最后何时改变的</li><li>它有一个缺陷就是只能精确到1s，</li><li>然后还有一个问题就是有的服务端的文件会周期性的改变，导致缓存失效</li></ul><p>而<code>E-tag</code>：</p><ul><li>是一种指纹机制，代表文件相关指纹</li><li>只有文件变才会变，也只要文件变就会变，</li><li>也没有精确时间的限制，只要文件一遍，立马E-tag就不一样了</li></ul><p>如果同时带有<code>E-tag</code>和<code>Last-Modified</code>，服务端会优先检查<code>E-tag</code>。<br>各大缓存头部的整体关系如下图：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1582125780799-6c37f8c2-f017-437c-b0a1-5883bc52f640.png#align=left&display=inline&height=361&name=image.png&originHeight=487&originWidth=800&size=56724&status=done&style=none&width=593" alt="image.png"></p><h2 id="解析页面"><a href="#解析页面" class="headerlink" title="解析页面"></a>解析页面</h2><p>前面有提到http交互，那么接下来就是浏览器获取到html，然后解析，渲染。</p><h3 id="流程简述"><a href="#流程简述" class="headerlink" title="流程简述"></a>流程简述</h3><p>浏览器内核拿到内容后，渲染步骤大致分为一下几步：</p><pre><code>1、解析HTML，构建DOM Tree2、解析CSS，构建CSS Rules Tree3、合并DOM Tree 和 CSS Rules Tree（其实是将CSS Rules Tree附在DOM Tree之上），生成render Tree。4、布局人的人 Tree（Layout/reflow），负责计算各元素的尺寸和位置的计算。5、绘制render Tree（paint），绘制页面像素信息。6、浏览器将各层的信息发送给GPU，由GPU将各层合层（composite），显示在屏幕上。</code></pre><p>如下图：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1582126229278-a9a28d86-1240-46bc-b731-9159edea5de0.png#align=left&display=inline&height=290&name=image.png&originHeight=313&originWidth=800&size=59355&status=done&style=none&width=741" alt="image.png"></p><h3 id="HTML解析-构建DOM"><a href="#HTML解析-构建DOM" class="headerlink" title="HTML解析 构建DOM"></a>HTML解析 构建DOM</h3><p>整个渲染步骤中，HTML解析是第一步。<br>简单的理解，这一步的流程是这样的：<strong>浏览器解析HTML，构建DOM树。</strong><br>但实际上，在分析整体构建时，却不能一笔带过，得稍微展开。<br>解析HTML到构建出DOM当然过程可以简述如下：<br><code>Bytes → characters → tokens → nodes → DOM</code><br>譬如假设有这样一个HTML页面：（以下部分的内容出自参考来源，修改了下格式）</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width,initial-scale<span class="token punctuation">=</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>style.css<span class="token punctuation">"</span></span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Critical Path<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>Hello <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>web performance<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span> students!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>awesome-photo.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p>浏览器的处理如下：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1582126699954-e7997952-47cc-42bd-a124-17b5228a4008.png#align=left&display=inline&height=393&name=image.png&originHeight=443&originWidth=800&size=156787&status=done&style=none&width=709" alt="image.png"><br>列举其中的一些重点过程：</p><ol><li>Conversion转换：浏览器将获得的HTML内容（Bytes）基于它的编码格式转换为字符串。</li><li>Tokeizing分词：浏览器按照HTML规范将这些字符串转换未不同的标记token，每一个token都有自己独特的含义和规则。</li><li>Lexing词法分析：分词的结果就是获得一堆token，此时将他们转换为对象，为他们定义它们的属性和规则。</li><li>DOM构建：因为HTML标记的就是不同标签之间的关系，这个关系就像树形结构一样。</li></ol><p>最终的DOM树如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1582127390688-259012c7-ea28-4f28-979c-3038be4bbeae.png#align=left&display=inline&height=302&name=image.png&originHeight=284&originWidth=665&size=80041&status=done&style=none&width=707" alt="image.png"></p><h3 id="生成CSS规则"><a href="#生成CSS规则" class="headerlink" title="生成CSS规则"></a>生成CSS规则</h3><p>同理，CSS规则树的生成也是类似。简述为：<br><code>Bytes → characters → tokens → nodes → CSSOM</code>。</p><pre><code>body { font-size: 16px }p { font-weight: bold }span { color: red }p span { display: none }img { float: right }</code></pre><p>最终生成的CSS Rules Tree：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1582127478001-17abbd25-fe2f-4132-bdf9-512c64f7edd7.png#align=left&display=inline&height=345&name=image.png&originHeight=299&originWidth=582&size=78490&status=done&style=none&width=671" alt="image.png"></p><h3 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h3><p>当DOM树和CSSOM都有了后，就要开始构建渲染树了<br>一般来说，渲染树和DOM树相对应的，但不是严格意义上的一一对应<br>因为有一些不可见的DOM元素不会插入到渲染树中，如head这种不可见的标签或者<code>display: none</code>等<br>整体来说可以看图：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1582127519945-fb1dc7a5-a137-4ce5-8051-37574d82a1eb.png#align=left&display=inline&height=326&name=image.png&originHeight=373&originWidth=800&size=163504&status=done&style=none&width=699" alt="image.png"></p><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>有了render树，接下来就是开始渲染，基本流程如下：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1582127560548-6cd4e861-a923-4f9f-928e-8688ee6244e5.png#align=left&display=inline&height=194&name=image.png&originHeight=220&originWidth=800&size=171754&status=done&style=none&width=707" alt="image.png"></p><p>图中重要的四个步骤就是：</p><pre><code>1. 计算CSS样式2. 构建渲染树3. 布局，主要定位坐标和大小，是否换行，各种position overflow z-index属性4. 绘制，将图像绘制出来</code></pre><p>然后，图中的线与箭头代表通过js动态修改了DOM或CSS，导致了重新布局（Layout）或渲染（Repaint）。<br>这里Layout和Repaint的概念是有区别的：</p><ul><li>Layout，也称为Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树</li><li>Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了</li></ul><p>注意：回流的成本要远高于重绘，因为回流会造成同级元素和子节点的回流。所以，一定要尽可能的避免回流。</p><h3 id="什么会造成回流"><a href="#什么会造成回流" class="headerlink" title="什么会造成回流"></a>什么会造成回流</h3><ul><li>页面渲染初始化</li><li>DOM结构改变，如删除某个节点</li><li>render Tree发生变化，如padding改变</li><li>窗口resize</li><li>最复杂的一种：获取元素的某个属性：<ul><li>offsetTop/Left/Width/Height</li><li>scrollTop/Left/Width/Height</li><li>clientTop/Left/Width/Height</li><li>width/height</li><li>调用了getComputedStyle()或者IE的currentStyle</li></ul></li></ul><p>回流一定会伴随着重绘，重绘却不一定造成回流，这是一个充分必要条件。</p><h5 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h5><ol><li>减少逐项更改样式，最好一次性更改，或者使用定义样式class一次性更改。</li><li>避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document。</li><li>避免多次调用读取offset等属性，必要的时候可以缓存到变量中。</li><li>将复杂的元素决定定位或者固定定位，使其脱离文档流，否则造成的回流代价太大。</li></ol><p><strong>注意：改变字体大小会引发回流</strong></p><h3 id="复合层与简单层"><a href="#复合层与简单层" class="headerlink" title="复合层与简单层"></a>复合层与简单层</h3><p>浏览器渲染的图层一般分为两大类：普通图层和复合图层。</p><ul><li>DOM中每一个节点都对应一个普通图层。</li><li>复合图层就是普通图层的合并。一个页面一般来说只要一个复合图层。</li></ul><h4 id="浏览器什么时候会创建复合图层"><a href="#浏览器什么时候会创建复合图层" class="headerlink" title="浏览器什么时候会创建复合图层"></a>浏览器什么时候会创建复合图层</h4><ul><li><p>3D 或者 CSS transform</p></li><li><p><video> 和 <canvas> 标签</p></li><li><p>CSS filters</p></li><li><p>元素覆盖时，比如使用了 z-index 属性</p></li></ul><h4 id="如何变成复合图层"><a href="#如何变成复合图层" class="headerlink" title="如何变成复合图层"></a>如何变成复合图层</h4><p>将一个元素变为复合图层，就是使用传说中的硬件加速。</p><ul><li>transform:translate3d(0,0,0)，或者translateZ(0)。</li><li>opacity属性/过度动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）</li><li>will-chang属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），will-change的作用就是告诉浏览器该元素会有那些发生变化的方法，让浏览器为该元素的变化做好优化准备，具体请<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/will-change" target="_blank" rel="noopener">移步</a>。</li></ul><h4 id="复合图层的作用"><a href="#复合图层的作用" class="headerlink" title="复合图层的作用"></a>复合图层的作用</h4><p>一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能<br>但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡。</p><h4 id="使用硬件加速的问题"><a href="#使用硬件加速的问题" class="headerlink" title="使用硬件加速的问题"></a>使用硬件加速的问题</h4><ol><li>内存。如果GPU加载了大量的纹理，那么很容易就会发生内容问题，这一点在移动端浏览器上尤为明显，所以，一定要牢记不要让页面的每个元素都使用硬件加速。</li><li>使用GPU渲染会影响字体的抗锯齿效果。这是因为GPU和CPU具有不同的渲染机制。即使最终硬件加速停止了，文本还是会在动画期间显示得很模糊。</li></ol><p>注意：使用硬件加速时，尽可能的使用index，防止浏览器默认给后续的元素创建复合层渲染。<br>具体的原理时这样的：<br><strong>webkit CSS3中，如果这个元素添加了硬件加速，并且index层级比较低，<br>那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且releative或absolute属性相同的），<br>会默认变为复合层渲染，如果处理不当会极大的影响性能</strong><br>简单点理解，其实可以认为是一个隐式合成的概念：<strong>如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层</strong>，这点需要特别注意</p><h4 id="QA-2"><a href="#QA-2" class="headerlink" title="QA"></a>QA</h4><p>Q：为什么开启transform的元素不会引起回流和重绘？<br>A：因为transform属性支持的位移函数translate()、缩放比例函数scale()、斜切函数skew()、旋转函数rotate()都支持线性映射的形式，也就是<code>matrix( )</code>表示的方式，简单来说就是所有<code>transform</code>实现的效果都可以对原坐标系中的点<code>[x,y]</code>按照如下的齐次矩阵进行计算得到变换后的点坐标<code>[x&#39;,y&#39;]</code>：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1582211853941-542e6ef7-9ecf-4ff9-85b8-95d867517878.png#align=left&display=inline&height=79&name=image.png&originHeight=104&originWidth=241&size=9375&status=done&style=none&width=184" alt="image.png"><br>齐次矩阵的系数是设定<code>transform</code>变换时传入的，是一个已知项，而使用三维的齐次矩阵是因为二维坐标的点在变换时会产生常数项（主要是平移变换），而如果以二维矩阵作为参数来计算时，以<code>x</code>坐标变换为例，结果的形式就是<code>x&#39;=ax+by</code>，其中是没有常量的，所以只能采用一个三维齐次矩阵来表示，但计算中的第三个坐标实际上并不需要使用。更多的关于变换的数学原理，感兴趣的读者可以自行查阅资料。<br>所以translform在动画过程中不是使用缓存，而是在图层合成时遍历当前层的点，然后利用上述方法计算出新的坐标点即可。它可以视为一种与图层内容无关的变换，图层中的元素首次生成的位图信息缓存可以被反复使用。比如一段平移动画，如果使用<code>绝对定位+改变left值</code>的方式来实现，就需要不断计算动画元素的布局并更新它的像素信息，但如果使用<code>translate</code>来实现，动画元素在文档流中的位置并不需要改变，无论后续平移到多远，都可以使用位图缓存中保存的初始位置信息，再加上变换矩阵的影响在层合并时计算出来，同样<strong>既不影响布局，也不需要重绘</strong>，这就是它高性能的原因。<br>Q：为什么使用opacity的元素不会引起回流和重绘？<br>A：<code>opacity</code>单词意思为透明度，直观视觉效果就是颜色变淡了，但最终显示的颜色其实仍然可以用<strong>RGB</strong>三个通道来表示，从数值运算的角度来看，它实际上表示了<strong>它采用一般混合策略和其他颜色进行混合时的比例</strong>，也就是：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1582212158471-ce8e20ce-10bc-464d-adc1-a221180fb791.png#align=left&display=inline&height=50&originHeight=50&originWidth=544&size=0&status=done&style=none&width=544" alt=""><br>例如在网页默认的白底色上<code>rgba(255,255,255)</code>显示一个包含透明度的<code>rgba(218,89,97,0.8)</code>颜色， 那么颜色的<strong>RGB</strong>分量都按照上述公式进行计算就得到<code>rgb(225,122,128)</code>,用取色器拾取一下渲染出来的点，结果和上述理论是一致的：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1582212170227-051b23df-08a3-4c3e-8d39-78730254c405.png#align=left&display=inline&height=648&name=image.png&originHeight=666&originWidth=525&size=220613&status=done&style=none&width=511" alt="image.png"><br>所以<code>opacity</code>这个属性本身就是用在重叠部分颜色处理的过程中使用的，对于分层的图原来说就可以看作是与图层内容无关的系数，因为合成过程中当前层中所有像素都需要经历上面的颜色混合公式，所以<code>opacity</code>的动画过程<strong>既不会影响布局，也不需要重绘。</strong>这样图层中保存的<strong>RGB</strong>像素数据的缓存在动画过程中也就不需要更新了，如果不使用<code>opacity</code>属性的话，每一帧对于变化部分都需要手动重计算<strong>RGB</strong>颜色值（这也就相当于是重绘了），因为这些区域的像素颜色一直都在变化，缓存也就没有意义。现在再来看看<code>opacity</code>的性能优势，就相对容易理解了。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><h5 id="opacity和transform动画的高性能是由于其数学原理决定了可以使用缓存信息，而并不是因为它被硬件加速了。"><a href="#opacity和transform动画的高性能是由于其数学原理决定了可以使用缓存信息，而并不是因为它被硬件加速了。" class="headerlink" title="opacity和transform动画的高性能是由于其数学原理决定了可以使用缓存信息，而并不是因为它被硬件加速了。"></a><code>opacity</code>和<code>transform</code>动画的高性能是由于其数学原理决定了可以使用缓存信息，而并不是因为它被<strong>硬件加速</strong>了。</h5><p>参考：<a href="https://www.cnblogs.com/huaweicloud/p/11867409.html" target="_blank" rel="noopener">高性能的Web动画和渲染原理</a><br>        <a href="https://www.cnblogs.com/ranyonsue/p/8296983.html" target="_blank" rel="noopener">使用CSS开启硬件加速提高性能</a><br>        <a href="https://segmentfault.com/a/1190000012925872#item-6-11" target="_blank" rel="noopener">复合图层和简单图层</a></p><h3 id="Chrome中的调试"><a href="#Chrome中的调试" class="headerlink" title="Chrome中的调试"></a>Chrome中的调试</h3><p>Chrome的开发者工具中，Performance中可以看到详细的渲染过程：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1582212896980-635456b9-ed30-431c-993d-5b3e41864b67.png#align=left&display=inline&height=322&name=image.png&originHeight=384&originWidth=800&size=245579&status=done&style=none&width=670" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1582213833661-5eaebd59-e5ec-4a25-aff7-2fa87e5dae04.png#align=left&display=inline&height=327&name=image.png&originHeight=388&originWidth=800&size=281621&status=done&style=none&width=675" alt="image.png"></p><h3 id="资源外链的下载"><a href="#资源外链的下载" class="headerlink" title="资源外链的下载"></a>资源外链的下载</h3><p>上面介绍了html解析，渲染流程。但实际上，在解析html时，会遇到一些资源连接，此时就需要进行单独处理了<br>简单起见，这里将遇到的静态资源分为一下几大类（未列举所有）：</p><ul><li>CSS样式资源</li><li>JS脚本资源</li><li>img图片类资源</li></ul><h4 id="当遇到外链时的处理"><a href="#当遇到外链时的处理" class="headerlink" title="当遇到外链时的处理"></a>当遇到外链时的处理</h4><p>当遇到上述的外链时，会单独开启一个线程去下载资源（http1.1中每一个资源的下载都对应一个tcp/ip连接）。</p><h4 id="遇到CSS资源外链"><a href="#遇到CSS资源外链" class="headerlink" title="遇到CSS资源外链"></a>遇到CSS资源外链</h4><p>CSS资源的处理有几个特点：</p><ul><li>CSS下载时异步，不会阻塞浏览器构建DOM树</li><li>但是会阻塞渲染，也就是在构建render时，会等到css下载解析完毕后才进行（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建）</li><li>有例外，<code>media query</code>声明的CSS是不会阻塞渲染的</li></ul><h4 id="遇到脚本资源"><a href="#遇到脚本资源" class="headerlink" title="遇到脚本资源"></a>遇到脚本资源</h4><p>JS脚本资源的处理有几个特点：</p><ul><li>阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML</li><li>浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其它资源（当然有并发上限），但是虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已</li><li>defer与async，普通的脚本是会阻塞浏览器解析的，但是可以加上defer或async属性，这样脚本就变成异步了，可以等到解析完毕后再执行</li></ul><p>注意，defer和async是有区别的： <strong>defer是延迟执行，而async是异步执行。</strong><br>简单的说（不展开）：</p><ul><li><code>async</code>是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在<code>onload</code>前，但不确定在<code>DOMContentLoaded</code>事件的前或后</li><li><code>defer</code>是延迟执行，在浏览器看起来的效果像是将脚本放在了<code>body</code>后面一样（虽然按规范应该是在<code>DOMContentLoaded</code>事件前，但实际上不同浏览器的优化效果不一样，也有可能在它后面）</li></ul><h4 id="遇到图片资源"><a href="#遇到图片资源" class="headerlink" title="遇到图片资源"></a>遇到图片资源</h4><p>遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方</p><h4 id="loaded和domcontentloaded"><a href="#loaded和domcontentloaded" class="headerlink" title="loaded和domcontentloaded"></a>loaded和domcontentloaded</h4><p>简单的对比：</p><ul><li>DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片(譬如如果有async加载的脚本就不一定完成)。等同于$(document).ready()</li><li>load 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了</li></ul><h3 id="CSS的可视化模型"><a href="#CSS的可视化模型" class="headerlink" title="CSS的可视化模型"></a>CSS的可视化模型</h3><p><strong>这一部分内容很多参考《精通CSS-高级Web标准解决方案》以及参考来源</strong><br>前面提到了整体的渲染概念，但实际上文档树中的元素是按什么渲染规则渲染的，是可以进一步展开的，此部分内容即： <strong>CSS的可视化格式模型</strong><br>先了解：</p><ul><li>CSS中规定每一个元素都有自己的盒子模型（相当于规定了这个元素如何显示）</li><li>然后可视化格式模型则是把这些盒子按照规则摆放到页面上，也就是如何布局</li><li>换句话说，盒子模型规定了怎么在页面里摆放盒子，盒子的相互作用等等</li></ul><p>说到底： <strong>CSS的可视化格式模型就是规定了浏览器在页面中如何处理文档树</strong><br><strong>关键字：</strong></p><pre><code>包含块（Containing Block）控制框（Controlling Box）BFC（Block Formatting Context）IFC（Inline Formatting Context）定位体系浮动...</code></pre><p>另外，CSS有三种定位机制：<code>普通流</code>，<code>浮动</code>，<code>绝对定位</code>，如无特别提及，下文中都是针对普通流中的。</p><h4 id="包含块-Containing-Block"><a href="#包含块-Containing-Block" class="headerlink" title="包含块(Containing Block)"></a>包含块(Containing Block)</h4><p>一个元素的box的定位和尺寸，会与某一矩形框有关，这个框就称之为包含块。<br>元素会为它的子孙元素创建包含块，但是，并不是说元素的包含块就是它的父元素，元素的包含块与它的祖先元素的样式等有关系<br>譬如：</p><ul><li>根元素是最顶端的元素，它没有父节点，它的包含块就是初始包含块</li><li>static和relative的包含块由它最近的块级、单元格或者行内块祖先元素的内容框（content）创建</li><li>fixed的包含块是当前可视窗口</li><li>absolute的包含块由它最近的position 属性为<code>absolute</code>、<code>relative</code>或者<code>fixed</code>的祖先元素创建<ul><li>如果其祖先元素是行内元素，则包含块取决于其祖先元素的<code>direction</code>特性</li><li>如果祖先元素不是行内元素，那么包含块的区域应该是祖先元素的内边距边界</li></ul></li></ul><h4 id="控制框-Controlling-Box"><a href="#控制框-Controlling-Box" class="headerlink" title="控制框(Controlling Box)"></a>控制框(Controlling Box)</h4><p>块级元素和块框以及行内元素和行框的相关概念<br><strong>块框:</strong></p><ul><li>块级元素会生成一个块框（<code>Block Box</code>），块框会占据一整行，用来包含子box和生成的内容</li><li>块框同时也是一个块包含框（<code>Containing Box</code>），里面要么只包含块框，要么只包含行内框（不能混杂），如果块框内部有块级元素也有行内元素，那么行内元素会被匿名块框包围</li></ul><p>关于<strong>匿名块框</strong>的生成，示例：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>DIV</span><span class="token punctuation">></span></span>Some text  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>P</span><span class="token punctuation">></span></span>More text<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>P</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>DIV</span><span class="token punctuation">></span></span></code></pre><p><code>div</code>生成了一个块框，包含了另一个块框<code>p</code>以及文本内容<code>Some text</code>，此时<code>Some text</code>文本会被强制加到一个匿名的块框里面，被<code>div</code>生成的块框包含（其实这个就是<code>IFC</code>中提到的行框，包含这些行内框的这一行匿名块形成的框，行框和行内框不同）<br>换句话说:<br><strong>如果一个块框在其中包含另外一个块框，那么我们强迫它只能包含块框，因此其它文本内容生成出来的都是匿名块框（而不是匿名行内框）</strong><br><strong>**行内框：</strong></p><ul><li>一个行内元素生成一个行内框</li><li>行内元素能排在一行，允许左右有其它元素</li></ul><p>关于<strong>匿名行内框</strong>的生成，示例：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>P</span><span class="token punctuation">></span></span>Some <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>EM</span><span class="token punctuation">></span></span>emphasized<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>EM</span><span class="token punctuation">></span></span> text<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>P</span><span class="token punctuation">></span></span></code></pre><p><code>P</code>元素生成一个块框，其中有几个行内框（如<code>EM</code>），以及文本<code>Some</code>，<code>text</code>，此时会专门为这些文本生成匿名行内框。<br><strong>display属性的影响</strong><br><code>display</code>的几个属性也可以影响不同框的生成：</p><ul><li><code>block</code>，元素生成一个块框</li><li><code>inline</code>，元素产生一个或多个的行内框</li><li><code>inline-block</code>，元素产生一个行内级块框，行内块框的内部会被当作块块来格式化，而此元素本身会被当作行内级框来格式化（这也是为什么会产生<code>BFC</code>）</li><li><code>none</code>，不生成框，不再格式化结构中，当然了，另一个<code>visibility: hidden</code>则会产生一个不可见的框</li></ul><p>总结：</p><ul><li>如果一个框里，有一个块级元素，那么这个框里的内容都会被当作块框来进行格式化，因为只要出现了块级元素，就会将里面的内容分块几块，每一块独占一行（出现行内可以用匿名块框解决）</li><li>如果一个框里，没有任何块级元素，那么这个框里的内容会被当成行内框来格式化，因为里面的内容是按照顺序成行的排列。</li></ul><h4 id="BFC-Block-Formatting-Context"><a href="#BFC-Block-Formatting-Context" class="headerlink" title="BFC(Block Formatting Context)"></a>BFC(Block Formatting Context)</h4><p>块级格式化上下文。<br>FC即格式上下文，它定义框内部的元素渲染规则，比较抽象，譬如：</p><pre><code>FC像是一个大箱子，里面装有很多元素箱子可以隔开里面的元素和外面的元素（所以外部并不会影响FC内部的渲染）内部的规则可以是：如何定位，宽高计算，margin折叠等等</code></pre><p>不同类型的框参与的FC类型不同，譬如块级框对应BFC，行内框对应IFC<br><strong>注意，并不是说所有的框都会产生FC，而是符合特定条件才会产生，只有产生了对应的FC后才会应用对应渲染规则</strong><br><strong>BFC规则：</strong></p><pre><code>在块格式化上下文中每一个元素左外边与包含块的左边相接触（对于从右到左的格式化，右外边接触右边）即使存在浮动也是如此（所以浮动元素正常会直接贴近它的包含块的左边，与普通元素重合）除非这个元素也创建了一个新的BFC</code></pre><p>总结几点BFC特点：</p><ol><li>内部<code>box</code>在垂直方向，一个接一个的放置</li><li>box的垂直方向由<code>margin</code>决定，属于同一个BFC的两个box间的margin会重叠</li><li>BFC区域不会与<code>float box</code>重叠（可用于排版)</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此</li><li>计算BFC的高度时，浮动元素也参与计算（不会浮动坍塌）</li></ol><p>如何触发BFC？</p><ol><li>根元素</li><li><code>float</code>属性不为<code>none</code></li><li><code>position</code>为<code>absolute</code>或<code>fixed</code></li><li><code>display</code>为<code>inline-block</code>, <code>flex</code>, <code>inline-flex</code>，<code>table</code>，<code>table-cell</code>，<code>table-caption</code></li><li><code>overflow</code>不为<code>visible</code></li></ol><p>这里提下，<code>display: table</code>，它本身不产生BFC，但是它会产生匿名框（包含<code>display: table-cell</code>的框），而这个匿名框产生BFC。<br>更多请自行在网上搜索。</p><h4 id="IFC-Inline-Formatting-Context"><a href="#IFC-Inline-Formatting-Context" class="headerlink" title="IFC(Inline Formatting Context)"></a>IFC(Inline Formatting Context)</h4><p>IFC即行内框产生的格式上下文<br><strong>IFC规则</strong></p><pre><code>在行内格式化上下文中框一个接一个地水平排列，起点是包含块的顶部。水平方向上的 margin，border 和 padding 在框之间得到保留框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐</code></pre><p><strong>行框</strong><br><strong>包含那些框的长方形区域，会形成一行，叫做行框</strong><br>行框的宽度由它的包含块和其中的浮动元素决定，高度的确定由行高度计算规则决定<br>行框的规则：</p><pre><code>如果几个行内框在水平方向无法放入一个行框内，它们可以分配在两个或多个垂直堆叠的行框中（即行内框的分割）行框在堆叠时没有垂直方向上的分割且永不重叠行框的高度总是足够容纳所包含的所有框。不过，它可能高于它包含的最高的框（例如，框对齐会引起基线对齐）行框的左边接触到其包含块的左边，右边接触到其包含块的右边。</code></pre><p><strong>结合补充下IFC规则：</strong></p><pre><code>浮动元素可能会处于包含块边缘和行框边缘之间尽管在相同的行内格式化上下文中的行框通常拥有相同的宽度（包含块的宽度），它们可能会因浮动元素缩短了可用宽度，而在宽度上发生变化同一行内格式化上下文中的行框通常高度不一样（如，一行包含了一个高的图形，而其它行只包含文本）当一行中行内框宽度的总和小于包含它们的行框的宽，它们在水平方向上的对齐，取决于 `text-align` 特性空的行内框应该被忽略即不包含文本，保留空白符，margin/padding/border非0的行内元素，以及其他常规流中的内容(比如，图片，inline blocks 和 inline tables)，并且不是以换行结束的行框，必须被当作零高度行框对待</code></pre><p>总结：</p><ul><li>行内元素总是会应用IFC渲染规则</li><li>行内元素会应用IFC规则渲染，譬如<code>text-align</code>可以用来居中等</li><li>块框内部，对于文本这类的匿名元素，会产生匿名行框包围，而行框内部就应用IFC渲染规则</li><li>行内框内部，对于那些行内元素，一样应用IFC渲染规则</li><li>另外，<code>inline-block</code>，会在元素外层产生IFC（所以这个元素是可以通过<code>text-align</code>水平居中的），当然，它内部则按照BFC规则渲染</li></ul><p>相比BFC规则来说，IFC可能更加抽象（因为没有那么条理清晰的规则和触发条件）<br>但总的来说，它就是行内元素自身如何显示以及在框内如何摆放的渲染规则，这样描述应该更容易理解。</p><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>当然还有有一些其它内容：</p><ul><li>譬如常规流，浮动，绝对定位等区别</li><li>譬如浮动元素不包含在常规流中</li><li>譬如相对定位，绝对定位，<code>Fixed</code>定位等区别</li><li>譬如<code>z-index</code>的分层显示机制等</li></ul><p>这里不一一展开，更多请参考：<a href="https://bbs.csdn.net/topics/340204423" target="_blank" rel="noopener">https://bbs.csdn.net/topics/340204423</a></p><h3 id="JS引擎解析过程"><a href="#JS引擎解析过程" class="headerlink" title="JS引擎解析过程"></a>JS引擎解析过程</h3><p>前面有提到遇到JS脚本时，会等到它的执行，实际上是需要引擎解析的，这里展开描述（介绍主干流程）。</p><h4 id="JS的解释阶段"><a href="#JS的解释阶段" class="headerlink" title="JS的解释阶段"></a>JS的解释阶段</h4><p>首先得明确： <strong>JS是解释型语言，所以它无需提前编译，而是由解释器实时运行</strong><br>引擎对JS的处理过程可以简述如下：</p><ol><li>读取代码，进行词法分析(Lexical analysis)，然后将代码分解为词元token。</li><li>对词元token进行语法分析(parsing)，然后将代码整理出语法树(syntax tree)。</li><li>使用翻译器(translator)，将代码转换为字节码(bytecode)</li><li>使用字节码解释器(bytecode interpreter)，将字节码转为机器码。</li></ol><p>最终计算机执行的就是机器码。<br>为了提高运行速度，现代浏览器一般采用即时编译（<code>JIT-Just In Time compiler</code>）。<br>即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（<code>inline cache</code>）。<br>这样整个程序的运行速度能得到显著提升。<br>而且，不同浏览器策略可能还不同，有的浏览器就省略了字节码的翻译步骤，直接转为机器码（如chrome的v8）<br>总结起来可以认为是： <strong>核心的<code>JIT</code>编译器将源码编译成机器码运行。</strong></p><h4 id="JS的预处理阶段"><a href="#JS的预处理阶段" class="headerlink" title="JS的预处理阶段"></a>JS的预处理阶段</h4><p>上述将的是解释器的整体过程，这里再提下在正式执行JS前，还会有一个预处理阶段<br>（譬如变量提升，分号补全等）<br>预处理阶段会做一些事情，确保JS可以正确执行，这里仅提部分：<br><strong>分号补全</strong><br>JS执行是需要分号的，但为什么以下语句却可以正常运行呢？</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span></code></pre><p>原因就是JS解释器有一个<a href="http://inimino.org/~inimino/blog/javascript_semicolons" target="_blank" rel="noopener">Semicolon Insertion</a>规则，它会按照一定规则，在适当的位置补充分号<br>譬如列举几条自动加分号的规则：</p><ul><li>当有换行符（包括含有换行符的多行注释），并且下一个<code>token</code>没法跟前面的语法匹配时，会自动补分号。</li><li>当有<code>}</code>时，如果缺少分号，会补分号。</li><li>程序源代码结束时，如果缺少分号，会补分号。</li></ul><p>于是，上述的代码就变成了</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>所以可以正常运行<br>当然了，这里有一个经典的例子：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span>    <span class="token punctuation">{</span>        a<span class="token punctuation">:</span> <span class="token string">'a'</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>由于分号补全机制，所以它变成了：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">{</span>        a<span class="token punctuation">:</span> <span class="token string">'a'</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>所以运行后是<code>undefined</code></p><h5 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h5><p>一般包括函数提升和变量提升<br>譬如：</p><pre class=" language-javascript"><code class="language-javascript">a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> a<span class="token punctuation">;</span></code></pre><p>经过变量提升后，就变成：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> a<span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里没有展开，其实展开也可以牵涉到很多内容的<br>譬如可以提下变量声明，函数声明，形参，实参的优先级顺序，以及es6中let有关的临时死区等。</p><h4 id="JS的执行阶段"><a href="#JS的执行阶段" class="headerlink" title="JS的执行阶段"></a>JS的执行阶段</h4><p>此阶段的内容中的图片来源：<a href="http://www.cnblogs.com/TomXu/archive/2012/01/12/2308594.html" target="_blank" rel="noopener">深入理解JavaScript系列（10）：JavaScript核心（晋级高手必读篇）</a><br>这里还有一篇文章可以帮助大家理解：<a href="https://www.yuque.com/walter-glskq/zf7grn/xhnw6t" target="_blank" rel="noopener">作用域与作用域链</a><br>解释器解释完语法规则后，就开始执行，然后整个执行流程中大致包含以下概念：</p><ul><li>执行上下文，执行堆栈概念（如全局上下文，当前活动上下文）</li><li>VO（变量对象）和AO（活动对象）</li><li>作用域链</li><li>this机制等</li></ul><p>这些概念如果深入讲解的话内容过多，因此这里仅提及部分特性<br><strong>执行上下文简单解释</strong></p><ul><li>JS有<code>执行上下文</code>）</li><li>浏览器首次载入脚本，它将创建<code>全局执行上下文</code>，并压入执行栈栈顶（不可被弹出）</li><li>然后每进入其它作用域就创建对应的执行上下文并把它压入执行栈的顶部</li><li>一旦对应的上下文执行完毕，就从栈顶弹出，并将上下文控制权交给当前的栈。</li><li>这样依次执行（最终都会回到全局执行上下文）</li></ul><p>譬如，如果程序执行完毕，被弹出执行栈，然后有没有被引用（没有形成闭包），那么这个函数中用到的内存就会被垃圾处理器自动回收：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1582215760520-0c77076a-b9cb-4faf-bbd7-5ad55a280dab.png#align=left&display=inline&height=121&name=image.png&originHeight=87&originWidth=463&size=12701&status=done&style=none&width=645" alt="image.png"><br>然后执行上下文与VO，作用域链，this的关系是：<br>每一个执行上下文，都有三个重要属性：</p><ul><li>变量对象(<code>Variable object，VO</code>)</li><li>作用域链(<code>Scope chain</code>)</li><li><code>this</code></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1582215788358-fef25608-d3dd-4e04-b095-25a7a7a1506d.png#align=left&display=inline&height=124&name=image.png&originHeight=249&originWidth=340&size=19930&status=done&style=none&width=170" alt="image.png">)<img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1582215790249-c0df6d34-c43b-46a3-95e4-6b833f98a441.png#align=left&display=inline&height=124&name=image.png&originHeight=249&originWidth=340&size=19930&status=done&style=none&width=170" alt="image.png">)<img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1582215794216-77f5ef5b-0e64-45c1-9c9e-edcd661ef061.png#align=left&display=inline&height=124&name=image.png&originHeight=249&originWidth=340&size=19930&status=done&style=none&width=170" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1582215805673-78c3d36c-89c4-44c8-952a-b89583bc24ca.png#align=left&display=inline&height=287&name=image.png&originHeight=249&originWidth=340&size=19930&status=done&style=none&width=392" alt="image.png"><br><strong>VO与AO</strong><br>VO是执行上下文的属性（抽象概念），但是<strong>只有全局上下文的变量对象允许通过VO的属性名称来间接访问（因为在全局上下文里，全局对象自身就是变量对象）</strong><br>AO（<code>activation object</code>)，当函数被调用者激活，AO就被创建了<br>可以理解为：</p><ul><li>在函数上下文中：<code>VO === AO</code></li><li>在全局上下文中：<code>VO === this === global</code></li></ul><p>总的来说，VO中会存放一些变量信息（如声明的变量，函数，<code>arguments</code>参数等等）<br><strong>作用域链</strong><br>它是执行上下文中的一个属性，原理和原型链很相似，作用很重要。<br>譬如流程简述：</p><pre><code>在函数上下文中，查找一个变量foo如果函数的VO中找到了，就直接使用否则去它的父级作用域链中（__parent__）找如果父级中没找到，继续往上找直到全局上下文中也没找到就报错</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1582215843494-1199245e-1308-4681-8caa-accf79b10687.png#align=left&display=inline&height=549&name=image.png&originHeight=426&originWidth=221&size=42937&status=done&style=none&width=285" alt="image.png"></p><p><strong>this指针</strong><br>这也是JS的核心知识之一，由于内容过多，这里就不展开，仅提及部分<br>注意：<strong>this是执行上下文环境的一个属性，而不是某个变量对象的属性</strong><br>因此:</p><ul><li>this是没有一个类似搜寻变量的过程</li><li>当代码中使用了this，这个 this的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻</li><li>this的值只取决中进入上下文时的情况</li></ul><p>所以经典的例子：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> baz <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span><span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token punctuation">{</span>    baz<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span>    foo<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>baz<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> foo <span class="token operator">=</span> bar<span class="token punctuation">.</span>foo<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 进入环境：global</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 200，严格模式中会报错，Cannot read property 'baz' of undefined</span><span class="token comment" spellcheck="true">// 进入环境：global bar</span>bar<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 100</span></code></pre><p>就要明白了上面this的介绍，上述例子很好理解<br>更多参考：<br><a href="http://www.cnblogs.com/TomXu/archive/2012/01/17/2310479.html" target="_blank" rel="noopener">深入理解JavaScript系列（13）：This? Yes,this!</a></p><h4 id="回收机制"><a href="#回收机制" class="headerlink" title="回收机制"></a>回收机制</h4><p>JS有垃圾处理器，所以无需手动回收内存，而是由垃圾处理器自动处理。<br>一般来说，垃圾处理器有自己的回收策略。<br>譬如对于那些执行完毕的函数，如果没有外部引用（被引用的话会形成闭包），则会回收。（当然一般会把回收动作切割到不同的时间段执行，防止影响性能）<br>常用的两种垃圾回收规则是：</p><ul><li>标记清除</li><li>引用计数</li></ul><p>Javascript引擎基础GC方案是（<code>simple GC</code>）：<code>mark and sweep</code>（标记清除），简单解释如下：</p><ol><li>遍历所有可访问的对象。</li><li>回收已不可访问的对象。</li></ol><p>譬如：（出自javascript高程）<br>当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。&gt; 从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。</p><blockquote><p>而当变量离开环境时，则将其标记为“离开环境”。<br>垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。<br>然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包，也就是说在环境中的以及相关引用的变量会被去除标记）。<br>而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。<br>最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p></blockquote><p>关于引用计数，简单点理解：<br><strong>跟踪记录每个值被引用的次数，当一个值被引用时，次数<code>+1</code>，减持时<code>-1</code>，下次垃圾回收器会回收次数为<code>0</code>的值的内存（当然了，容易出循环引用的bug）</strong><br><strong>GC的缺陷</strong><br>和其他语言一样，javascript的GC策略也无法避免一个问题： <strong>GC时，停止响应其他操作</strong><br>这是为了安全考虑。<br>而Javascript的GC在<code>100ms</code>甚至以上<br>对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。<br>这就是引擎需要优化的点： <strong>避免GC造成的长时间停止响应。</strong><br><strong>GC优化策略</strong><br>这里介绍常用到的：<strong>分代回收（Generation GC）</strong><br>目的是通过区分“临时”与“持久”对象:</p><ul><li>多回收“临时对象”区（<code>young generation</code>）</li><li>少回收“持久对象”区（<code>tenured generation</code>）</li><li>减少每次需遍历的对象，从而减少每次GC的耗时。</li></ul><p>像node v8引擎就是采用的分代回收（和java一样，作者是java虚拟机作者。）<br>更多可以参考：<br><a href="https://zhuanlan.zhihu.com/p/33816534" target="_blank" rel="noopener">V8 内存浅析</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="可以提到跨域"><a href="#可以提到跨域" class="headerlink" title="可以提到跨域"></a>可以提到跨域</h3><p>譬如发出网络请求时，会用AJAX，如果接口跨域，就会遇到跨域问题<br>可以参考：<br><a href="https://segmentfault.com/a/1190000012469713" target="_blank" rel="noopener">ajax跨域，这应该是最全的解决方案了</a></p><h3 id="可以提到web安全"><a href="#可以提到web安全" class="headerlink" title="可以提到web安全"></a>可以提到web安全</h3><p>譬如浏览器在解析HTML时，有<code>XSSAuditor</code>，可以延伸到web安全相关领域<br>可以参考：<br><a href="https://segmentfault.com/a/1190000012693772" target="_blank" rel="noopener">AJAX请求真的不安全么？谈谈Web安全与AJAX的关系。</a></p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>如可以提到<code>viewport</code>概念，讲讲物理像素，逻辑像素，CSS像素等概念<br>如熟悉Hybrid开发的话可以提及一下Hybrid相关内容以及优化</p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>感谢<a href="https://segmentfault.com/a/1190000013662126" target="_blank" rel="noopener">撒网要见鱼</a>的分享。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多页面打包配置</title>
      <link href="/2020/02/12/Webpack/07/"/>
      <url>/2020/02/12/Webpack/07/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack4-0-七-：多页面打包配置"><a href="#webpack4-0-七-：多页面打包配置" class="headerlink" title="webpack4.0(七)：多页面打包配置"></a>webpack4.0(七)：多页面打包配置</h1><p>webpack.config.js</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token punctuation">{</span> CleanWebpackPlugin <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'clean-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> AddAssetHtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'add-asset-html-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @param { Object }  * @return { Object } */</span><span class="token keyword">const</span> makeHtml <span class="token operator">=</span> <span class="token punctuation">(</span>configs<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> pluginsDll <span class="token operator">=</span> <span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">CleanWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">;</span>    Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>configs<span class="token punctuation">.</span>entry<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>key <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>        pluginsDll<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>            <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                filename<span class="token punctuation">:</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.html`</span></span><span class="token punctuation">,</span>                template<span class="token punctuation">:</span><span class="token string">'./src/index.html'</span><span class="token punctuation">,</span>                chunks<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'lodash'</span><span class="token punctuation">,</span><span class="token string">'react'</span><span class="token punctuation">,</span>key<span class="token punctuation">]</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">const</span> files <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readdirSync</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">'../dll'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    files<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>file <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token regex">/.*\.dll.js$/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            pluginsDll<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>                <span class="token keyword">new</span> <span class="token class-name">AddAssetHtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                    filepath<span class="token punctuation">:</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">'../dll'</span><span class="token punctuation">,</span>file<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token regex">/.*\.manifest.json$/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>DllReferencePlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                manifest<span class="token punctuation">:</span> <span class="token function">require</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">'../dll'</span><span class="token punctuation">,</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> pluginsDll<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> config <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span><span class="token punctuation">{</span>        index<span class="token punctuation">:</span><span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>        list<span class="token punctuation">:</span><span class="token string">'./src/list.js'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span><span class="token punctuation">{</span>        path<span class="token punctuation">:</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">'../dist'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    module<span class="token punctuation">:</span><span class="token punctuation">{</span>        rules<span class="token punctuation">:</span><span class="token punctuation">[</span>            <span class="token punctuation">{</span>                test<span class="token punctuation">:</span><span class="token regex">/\.jsx?$/</span><span class="token punctuation">,</span>                loader<span class="token punctuation">:</span><span class="token string">'babel-loader'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>config<span class="token punctuation">.</span>plugins <span class="token operator">=</span> <span class="token function">makeHtml</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> config<span class="token punctuation">;</span></code></pre><p>webpack.dll.js</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    mode<span class="token punctuation">:</span><span class="token string">"production"</span><span class="token punctuation">,</span>    entry<span class="token punctuation">:</span><span class="token punctuation">{</span>        react<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'react'</span><span class="token punctuation">,</span><span class="token string">'react-dom'</span><span class="token punctuation">,</span><span class="token string">'react-router-dom'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        lodash<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'lodash-es'</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span><span class="token punctuation">{</span>        filename<span class="token punctuation">:</span><span class="token string">'[name].dll.js'</span><span class="token punctuation">,</span>        path <span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">'../dll'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        library<span class="token punctuation">:</span><span class="token string">'_dll_[name]'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span><span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>DllPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            name<span class="token punctuation">:</span> <span class="token string">"_dll_[name]"</span><span class="token punctuation">,</span>            path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">"../dll/[name].manifest.json"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DllPlugin和DllReferencePlugin</title>
      <link href="/2020/02/11/Webpack/06/"/>
      <url>/2020/02/11/Webpack/06/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack4-0-六-：DllPlugin和DllReferencePlugin"><a href="#webpack4-0-六-：DllPlugin和DllReferencePlugin" class="headerlink" title="webpack4.0(六)：DllPlugin和DllReferencePlugin"></a>webpack4.0(六)：DllPlugin和DllReferencePlugin</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在项目开发的时候，我们可能会发现有时候我们在打包的时候，构建速度很慢，尤其是一些我们使用的第三方库，每次都会被打包进去，大大延长了构建时间。那么我们能不能将这些稳定的库单独打包出来，这样既可以加快构建速度，还可以减少bundle的体积？</p><h3 id="DllPlugin和DllReferencePlugin"><a href="#DllPlugin和DllReferencePlugin" class="headerlink" title="DllPlugin和DllReferencePlugin"></a>DllPlugin和DllReferencePlugin</h3><p>答案是可以的。<code>DLLPlugin</code> 和 <code>DLLReferencePlugin</code> 用某种方法实现了拆分 bundles，同时还大大提升了构建的速度。<br>这个插件是在一个额外的独立的 webpack 设置中创建一个只有 dll 的 bundle(dll-only-bundle)。 这个插件会生成一个名为 <code>manifest.json</code> 的文件，这个文件是用来让 <code>DllReferencePlugin</code> 映射到相关的依赖上去的。</p><h4 id="DllPlugin"><a href="#DllPlugin" class="headerlink" title="DllPlugin"></a>DllPlugin</h4><p>该插件接受三个参数：</p><ul><li><code>context</code> (optional): manifest 文件中请求的上下文(context)(默认值为 webpack 的上下文(context))</li><li><code>name</code>: 暴露出的 DLL 的函数名 ( <code>[hash]</code> &amp; <code>[name]</code> )</li><li><code>path</code>: manifest json 文件的<strong>绝对路径</strong> (输出文件)</li></ul><p>结果会在给定的 <code>path</code> 路径下创建一个名为 <code>manifest.json</code> 的文件。 这个文件包含了从 <code>require</code> 和 <code>import</code> 的request到模块 id 的映射。 <code>DLLReferencePlugin</code> 也会用到这个文件。<br>webpack.dll.js：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    mode<span class="token punctuation">:</span><span class="token string">"production"</span><span class="token punctuation">,</span>    entry<span class="token punctuation">:</span><span class="token punctuation">{</span>        react<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'react'</span><span class="token punctuation">,</span><span class="token string">'react-dom'</span><span class="token punctuation">,</span><span class="token string">'react-router-dom'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        lodash<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'lodash-es'</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span><span class="token punctuation">{</span>        filename<span class="token punctuation">:</span><span class="token string">'[name].dll.js'</span><span class="token punctuation">,</span>        path <span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">'./dll'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        library<span class="token punctuation">:</span><span class="token string">'_dll_[name]'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span><span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>DllPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            name<span class="token punctuation">:</span> <span class="token string">"_dll_[name]"</span><span class="token punctuation">,</span>            path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">"./dll/[name].manifest.json"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h4 id="DllReferencePlugin"><a href="#DllReferencePlugin" class="headerlink" title="DllReferencePlugin"></a>DllReferencePlugin</h4><p>这个插件是在 webpack 主配置文件中设置的， 这个插件把只有 dll 的 bundle(们)(dll-only-bundle(s)) 引用到需要的预编译的依赖。该插件接受以下参数：</p><ul><li><code>context</code>: (<strong>绝对路径</strong>) manifest (或者是内容属性)中请求的上下文</li><li><code>manifest</code>: 包含 <code>content</code> 和 <code>name</code> 的对象，或者在编译时(compilation)的一个用于加载的 JSON manifest 绝对路径</li><li><code>content</code> (optional): 请求到模块 id 的映射 (默认值为 <code>manifest.content</code>)</li><li><code>name</code> (optional): dll 暴露的地方的名称 (默认值为 <code>manifest.name</code>) (可参考 <a href="https://www.webpackjs.com/configuration/externals/" target="_blank" rel="noopener"><code>externals</code></a>)</li><li><code>scope</code> (optional): dll 中内容的前缀</li><li><code>sourceType</code> (optional): dll 是如何暴露的 (<a href="https://www.webpackjs.com/configuration/output/#output-librarytarget" target="_blank" rel="noopener">libraryTarget</a>)</li></ul><blockquote><p>这里，我们引入一个新的插件：add-asset-html-webpack-plugin。它可以将一些资源文件绑定到html上。<br>这里用它就是将上面打包好的第三方库绑定到html上。</p></blockquote><p>webpack.config.js:</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> AddAssetHtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'add-asset-html-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> files <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readdirSync</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">'./dll'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>files<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> pluginsDll <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        template<span class="token punctuation">:</span> <span class="token string">'./src/index.html'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>files<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>file <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token regex">/.*\.dll.js$/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        pluginsDll<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>            <span class="token keyword">new</span> <span class="token class-name">AddAssetHtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                filepath<span class="token punctuation">:</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">'./dll'</span><span class="token punctuation">,</span>file<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token regex">/.*\.manifest.json$/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>DllReferencePlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            manifest<span class="token punctuation">:</span> <span class="token function">require</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">'./dll'</span><span class="token punctuation">,</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span> <span class="token string">'./src/app.js'</span><span class="token punctuation">,</span>    mode<span class="token punctuation">:</span> <span class="token string">"production"</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token punctuation">{</span>        filename<span class="token punctuation">:</span> <span class="token string">'bundle.js'</span><span class="token punctuation">,</span>        path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    resolve<span class="token punctuation">:</span><span class="token punctuation">{</span>        extensions<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'.js'</span><span class="token punctuation">,</span><span class="token string">'.jsx'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        mainFiles<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'main'</span><span class="token punctuation">,</span><span class="token string">'index'</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    devServer<span class="token punctuation">:</span><span class="token punctuation">{</span>        contentBase<span class="token punctuation">:</span><span class="token string">'./dist'</span><span class="token punctuation">,</span>        open<span class="token punctuation">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>        hotOnly<span class="token punctuation">:</span><span class="token boolean">true</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    module<span class="token punctuation">:</span> <span class="token punctuation">{</span>        rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                test<span class="token punctuation">:</span> <span class="token regex">/\.jsx?$/</span><span class="token punctuation">,</span>                exclude<span class="token punctuation">:</span> <span class="token regex">/node_modules/</span><span class="token punctuation">,</span>                use<span class="token punctuation">:</span> <span class="token string">'babel-loader'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span> pluginsDll<span class="token punctuation">}</span></code></pre><p>上面的代码中，我们使用fs模块获取dll文件夹下所有的文件，通过循环遍历，将资源全部挂载到html上。<br>这样，当打包的时候，如果本地的dll文件下有了第三方库的文件，打包的时候就不会再次向node_module上去取。大大加快了构建速度。</p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>babel</title>
      <link href="/2020/02/09/Webpack/05/"/>
      <url>/2020/02/09/Webpack/05/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack4-0-四-：babel"><a href="#webpack4-0-四-：babel" class="headerlink" title="webpack4.0(四)：babel"></a>webpack4.0(四)：babel</h1><h2 id="什么是babel"><a href="#什么是babel" class="headerlink" title="什么是babel"></a>什么是babel</h2><p>ES6是ECMAScript在2015年发布的下一代JavaScript语法，它引入了一些新的语法和API，但是这些新的语法和API只有在最新的浏览器中才会得到支持，就算是现在仍然有一部分浏览器不支持ES6。所以我们需要一个转换工具，将ES6+的语法转换为ES5的语法。而babel就是这样一个转换工具。</p><blockquote><p>本文的babel讲解基于babel7。</p></blockquote><h2 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h2><p>babel在执行编译的时候，会从项目根目录下的<code>.babelrc</code>中或者<code>babel-loader</code>的options中读取其配置。<code>.babelrc</code>是一个json格式的文件，其中主要是对预设（presets）和 插件（plugins）的配置。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>    <span class="token string">"presets"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>         <span class="token punctuation">[</span>            <span class="token string">"@babel/preset-env"</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                <span class="token string">"targets"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>                    <span class="token string">"edge"</span><span class="token punctuation">:</span> <span class="token string">"17"</span><span class="token punctuation">,</span>                    <span class="token string">"firefox"</span><span class="token punctuation">:</span> <span class="token string">"60"</span><span class="token punctuation">,</span>                    <span class="token string">"chrome"</span><span class="token punctuation">:</span> <span class="token string">"67"</span><span class="token punctuation">,</span>                    <span class="token string">"safari"</span><span class="token punctuation">:</span> <span class="token string">"11.1"</span><span class="token punctuation">,</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token string">"useBuiltIns"</span><span class="token punctuation">:</span><span class="token string">"usage"</span><span class="token comment" spellcheck="true">//只转换已使用的模块</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token string">"plugins"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h3 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h3><p>关于babel-loader的具体配置，请查看<a href="https://www.npmjs.com/package/babel-loader" target="_blank" rel="noopener">官方文档</a>。</p><blockquote><p>webpack 4.x | babel-loader 8.x | babel 7.x</p></blockquote><p>安装：<code>npm install -D babel-loader @babel/core @babel/preset-env webpack</code><br>配置：<br>在webpack.config.js中：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">:</span> <span class="token punctuation">{</span>        rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                test<span class="token punctuation">:</span> <span class="token regex">/\.js$/</span><span class="token punctuation">,</span>                exclude<span class="token punctuation">:</span> <span class="token regex">/node_modules/</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//对于第三方的插件 无需做多余处理</span>                use<span class="token punctuation">:</span> <span class="token punctuation">{</span>                    loader<span class="token punctuation">:</span> <span class="token string">'babel-loader'</span><span class="token punctuation">,</span>                    options<span class="token punctuation">:</span> <span class="token punctuation">{</span>                        presets<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'@babel/preset-env'</span><span class="token punctuation">]</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span></code></pre><p>关于<code>@babel/preset-env</code>的配置：<a href="https://babeljs.io/docs/en/babel-preset-env" target="_blank" rel="noopener">请移步</a>。<br>其实<code>babel-loader</code>只是babel和webpack沟通的桥梁，真正可以将ES6+语法转换为ES5语法的还是<code>``@babel/preset-env</code>。<br>按照上述配置，已经可以将ES6+的语法转换为ES5了。但是<code>@babel/preset-env</code>只是将语法翻译成ES5 ，在低版本的浏览器中，不支持的API，如Promise、map等，仍然没有被补充进去。所以我们需要使用一个工具在低版本的浏览器中补充这些新的API。<br>而<code>@babel/polyfill</code> 和 <code>@babel/runtime</code>正是用来做这些工作的。</p><h3 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="@babel/polyfill"></a>@babel/polyfill</h3><p>安装：<code>npm install --save @babel/polyfill</code>。<br>使用：在项目的入口文件中第一行引入即可：<code>import &quot;@babel/polyfill&quot;;</code>。由于<code>@babel/polyfill</code>很大，所以在配合webpack使用的时候，最好在babelrc文件中添加一项配置：<code>useBuiltIns: &#39;usage&#39;</code>。这样在打包编译的时候，就不会将为使用的ES6+语法也给打包进去了。</p><h3 id="babel-plugin-transform-runtime"><a href="#babel-plugin-transform-runtime" class="headerlink" title="babel-plugin-transform-runtime"></a>babel-plugin-transform-runtime</h3><p>安装：具体配置<a href="https://babeljs.io/docs/en/babel-plugin-transform-runtime" target="_blank" rel="noopener">请移步</a><br><code>npm install --save-dev @babel/plugin-transform-runtime</code><br><code>npm install --save @babel/runtime</code>。<br>配置：<br>.babelrc：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>  <span class="token string">"plugins"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">[</span>      <span class="token string">"@babel/plugin-transform-runtime"</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token string">"absoluteRuntime"</span><span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token string">"corejs"</span><span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token string">"helpers"</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token string">"regenerator"</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token string">"useESModules"</span><span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token string">"version"</span><span class="token punctuation">:</span> <span class="token string">"7.0.0-beta.0"</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h3 id="babel-polyfill-和-babel-plugin-transform-runtime的区别"><a href="#babel-polyfill-和-babel-plugin-transform-runtime的区别" class="headerlink" title="@babel/polyfill 和 babel-plugin-transform-runtime的区别"></a>@babel/polyfill 和 babel-plugin-transform-runtime的区别</h3><ul><li>前者的原理是当运行环境中并没有实现的一些方法，babel-polyfill会做兼容。后者是将ES6语法转换为ES5的语法，不管浏览器支不支持ES6的语法，都会编译，所以会有很多的冗余的代码。</li><li>前者是在全局环境一种添加方法，会造成全局变量的污染。后者它不会污染全局对象和内置对象的原型，比如说我们需要Promise，我们只需要import Promise from ‘babel-runtime/core-js/promise’即可，这样不仅避免污染全局对象，而且可以减少不必要的代码。</li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>codeSplitting</title>
      <link href="/2020/02/07/Webpack/04/"/>
      <url>/2020/02/07/Webpack/04/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack4-0-三-：codeSplitting"><a href="#webpack4-0-三-：codeSplitting" class="headerlink" title="webpack4.0(三)：codeSplitting"></a>webpack4.0(三)：codeSplitting</h1><p>代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。</p><p>当我们在做项目的时候，都会引入一些第三方的库来帮助我们开发，例如：lodash、underscore等等，但是这些库在我们打包的时候，会被默认打包到bundle.js中，极大的增加了js的体积，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1580283884792-a88740a5-d4ca-4e91-a690-d8d5e4fb5342.png#align=left&display=inline&height=173&name=image.png&originHeight=346&originWidth=902&size=59759&status=done&style=none&width=451" alt="image.png"><br>直接把我们的js体积提升到了2.4M，这时我们需要将其从main.js中分割出来，减小main.js的体积。</p><p>常见的有三种方式进行代码分割：</p><ul><li>在entry手动的配置代码分割。</li><li>使用<code>SplitChunksPlugin</code>进行公共代码提取和分割。</li><li>动态导入。</li></ul><h3 id="entry手动分割"><a href="#entry手动分割" class="headerlink" title="entry手动分割"></a>entry手动分割</h3><pre class=" language-javascript"><code class="language-javascript">entry<span class="token punctuation">:</span> <span class="token punctuation">{</span>    index<span class="token punctuation">:</span><span class="token string">'./index.js'</span><span class="token punctuation">,</span>    math<span class="token punctuation">:</span><span class="token string">'./math.js'</span><span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><p>执行打包之后，会被打包成不同的文件。<br>缺点：</p><ol><li>如果不同的模块中引入有重复的模块，那么重复的模块就会被多次打包。</li><li>不够灵活，不能将核心逻辑进行动态的拆分。</li></ol><h3 id="SplitChunksPlugin"><a href="#SplitChunksPlugin" class="headerlink" title="SplitChunksPlugin"></a>SplitChunksPlugin</h3><p><code>SplitChunksPlugin</code>插件可以将相同的模块提取到一起，并且还可以将我们使用的第三方插件单独提取出来，优化打包之后的bundle.js的体积。<br>具体使用：具体配置请查看<a href="https://www.webpackjs.com/plugins/split-chunks-plugin/#defaults" target="_blank" rel="noopener">官方文档</a>。</p><pre class=" language-javascript"><code class="language-javascript">optimization<span class="token punctuation">:</span> <span class="token punctuation">{</span>  splitChunks<span class="token punctuation">:</span> <span class="token punctuation">{</span>    chunks<span class="token punctuation">:</span> <span class="token string">"all"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//进行代码分割的时候，all：针对所有的导入  async:只针对异步导入 initial:针对同步代码导入。</span>    minSize<span class="token punctuation">:</span> <span class="token number">30000</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//设置最小阀值，只有大于该阀值，才会进行代码分割。</span>    minChunks<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//在分割模块之前共享一个模块的最小块数（设置代码最少被引用次数）</span>    maxAsyncRequests<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//按需加载时的最大并行请求数 超过就不会在做代码分割打包</span>    maxInitialRequests<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//一个入口点的最大并行请求数  超过就不会做代码分割</span>    automaticNameDelimiter<span class="token punctuation">:</span> <span class="token string">'~'</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//打包生成之后，默认情况下，webpack将使用块的来源和名称来生成名称，比如vendor ~main.js。</span>    name<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//使得cacheGroups中打包生成的文件名称</span>    cacheGroups<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//缓存组 打包分组</span>      vendors<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//配置同步导入 </span>        test<span class="token punctuation">:</span> <span class="token regex">/[\\/]node_modules[\\/]/</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//只有node_module中的才会进入</span>        priority<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//值越大 优先级越高</span>        filename<span class="token punctuation">:</span> <span class="token string">'vendors.js'</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// minChunks: 2,</span>        priority<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>        reuseExistingChunk<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">// 如果模块已经被打包了，在此遇到的时候 直接忽略，直接使用以打包好的模块。</span>        filename<span class="token punctuation">:</span><span class="token string">'default.js'</span>      <span class="token punctuation">}</span>          <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="动态导入"><a href="#动态导入" class="headerlink" title="动态导入"></a>动态导入</h3><p>动态导入有两种方式：</p><ul><li>使用ECMAScript提案的import()语法</li><li>使用webpack特定的语法：require.ensure()</li></ul><p>第一种方式：使用webpackChunkName</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">getComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment" spellcheck="true">/* webpackChunkName:"lodash" */</span> <span class="token string">"lodash"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token keyword">default</span><span class="token punctuation">:</span>_ <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        div<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'hello'</span><span class="token punctuation">,</span><span class="token string">'world'</span><span class="token punctuation">,</span><span class="token string">'lodash'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> div<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">getComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>打包之后，会在dist目录下生成一个<code>vendors~lodash.js</code>文件，表示它是vendors下面的一个文件。之所以前面会带一个vendors，这是因为cacheGroup有一个默认配置，如果想要去除，将vendors和default配置为false即可。<br>由于 <code>import()</code> 会返回一个 promise，因此它可以和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener"><code>async</code> 函数</a>一起使用。但是，需要使用像 Babel 这样的预处理器和<a href="https://babeljs.io/docs/plugins/syntax-dynamic-import/#installation" target="_blank" rel="noopener">Syntax Dynamic Import Babel Plugin</a>。</p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpackDevServer</title>
      <link href="/2020/01/28/Webpack/02/"/>
      <url>/2020/01/28/Webpack/02/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack4-0-二-：webpackDevServer"><a href="#webpack4-0-二-：webpackDevServer" class="headerlink" title="webpack4.0(二)：webpackDevServer"></a>webpack4.0(二)：webpackDevServer</h1><p>在开发中我们还需要一个本地文件的服务器，并且当我们保存代码的时候会自动进行打包，并且还支持 Source Map，以方便代码调试等功能，因此我们现在需要使用到 devServer了。</p><h3 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h3><p>首先我们需要安装：<code>webpack-dev-server</code>:</p><pre class=" language-javascript"><code class="language-javascript">全局安装：npm install <span class="token operator">-</span>g webpack<span class="token operator">-</span>dev<span class="token operator">-</span>server局部安装：npm install <span class="token operator">--</span>save<span class="token operator">-</span>dev webpack<span class="token operator">-</span>dev<span class="token operator">-</span>server</code></pre><p>在webpack4之后，同时需要安装：<code>webpack-cli</code></p><pre class=" language-javascript"><code class="language-javascript">npm install webpack<span class="token operator">-</span>cli <span class="token operator">-</span>D</code></pre><p>最后我们运行<code>webpack-dev-server</code>，就可以启动一个本地服务器，默认端口号是8080，访问<code>http://localhost:8080/</code>即可。</p><blockquote><p>注意：使用webpack-dev-server打包的文件保存在电脑内存当中，可以提高访问速度。</p></blockquote><p>当然，这个默认的配置是可以修改的，在<code>webpack.config.js</code>中：</p><pre class=" language-javascript"><code class="language-javascript">devServer<span class="token punctuation">:</span><span class="token punctuation">{</span>    contentBase<span class="token punctuation">:</span> <span class="token string">'./dist'</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//指定服务器默认打开的文件夹</span>  open<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//是否自动打开浏览器窗口</span>  port<span class="token punctuation">:</span> <span class="token string">"8081"</span><span class="token comment" spellcheck="true">//配置端口号</span><span class="token punctuation">}</span></code></pre><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>实时预览。使用<code>webpack --watch</code>，监听文件系统的变化，实现自动打包。当项目的入口文件或者依赖文件发生变动时，它会重新构建，构建完成之后会刷新页面。但是如果修改的不是入口文件或者依赖文件，它是不会重新构建的。</p><h3 id="webpack-dev-middleware"><a href="#webpack-dev-middleware" class="headerlink" title="webpack-dev-middleware"></a>webpack-dev-middleware</h3><p>新建一个服务端，并且将webpack处理过的文件传送给服务器。<br>原理：使用webpack和其对应的配置文件，生成一个编译器，使用该中间件，在服务器上监听文件变化，重新打包。<br>使用express建立本地服务器：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//server.js</span><span class="token keyword">const</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> middleware <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack-dev-middleware'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> config <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./webpack.config.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> complier <span class="token operator">=</span> <span class="token function">webpack</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//编译器</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">middleware</span><span class="token punctuation">(</span>complier<span class="token punctuation">,</span> <span class="token punctuation">{</span>    publicPath<span class="token punctuation">:</span> config<span class="token punctuation">.</span>output<span class="token punctuation">.</span>publicPath<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span></code></pre><p>然后访问3000端口即可。</p><h3 id="HMR"><a href="#HMR" class="headerlink" title="HMR"></a>HMR</h3><p>除了以上方法可以实现在入口文件或者依赖文件发生变动时进行重新打包加载页面之外，使用模块热替换技术也可以实现在不刷新页面的情况下，使用已更新的模块替换旧模块。<br>模块热替换技术默认是不开启的，我们可以通过以下方法开启：</p><ol><li>在启动devServer的时候带上<code>--inline</code> 或者 <code>--inline hot</code>即可。</li><li>在devServer中配置：</li></ol><pre class=" language-javascript"><code class="language-javascript">devServer<span class="token punctuation">:</span> <span class="token punctuation">{</span>  contentBase<span class="token punctuation">:</span> <span class="token string">'./dist'</span><span class="token punctuation">,</span>  open<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  port<span class="token punctuation">:</span> <span class="token number">8080</span><span class="token punctuation">,</span>  hot<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//配置HMR 阻止浏览器自动刷新</span>  hotOnly<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//即便HMR不生效 也不让浏览器自动刷新</span><span class="token punctuation">}</span><span class="token punctuation">,</span> plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>HotModuleReplacementPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span></code></pre><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><p>dev-server使用了非常强大的包：<code>http-proxy-middleware</code>，具体用法请查看<a href="https://www.npmjs.com/package/http-proxy-middleware" target="_blank" rel="noopener">使用文档</a>。<br>举个🌰：如果在<code>http://localhost:3000</code>上有后端开发服务器，我们可以这样设置代理：</p><pre class=" language-javascript"><code class="language-javascript">devServer<span class="token punctuation">:</span><span class="token punctuation">{</span>    proxy<span class="token punctuation">:</span><span class="token punctuation">{</span>      <span class="token string">"/api"</span><span class="token punctuation">:</span><span class="token string">"http://localhost:3000/"</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>将请求到 <code>/api/users</code> 现在会被代理到请求 <code>http://localhost:3000/api/users</code>。<br>如果不想始终传递 <code>/api</code> ，则需要重写路径：</p><pre class=" language-javascript"><code class="language-javascript">devServer<span class="token punctuation">:</span><span class="token punctuation">{</span>    proxy<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"/api"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>      target<span class="token punctuation">:</span> <span class="token string">"http://localhost:3000"</span><span class="token punctuation">,</span>      pathRewrite<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">"^/api"</span> <span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>默认情况下，不接受运行在 HTTPS 上，且使用了无效证书的后端服务器。如果你想要接受，修改配置如下：</p><pre class=" language-javascript"><code class="language-javascript">devServer<span class="token punctuation">:</span><span class="token punctuation">{</span>    proxy<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"/api"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>      target<span class="token punctuation">:</span> <span class="token string">"http://localhost:3000"</span><span class="token punctuation">,</span>      pathRewrite<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">"^/api"</span> <span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">}</span><span class="token punctuation">,</span>      secure<span class="token punctuation">:</span> <span class="token boolean">false</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>有时你不想代理所有的请求。可以基于一个函数的返回值绕过代理。<br>在函数中你可以访问请求体、响应体和代理选项。必须返回 <code>false</code> 或路径，来跳过代理请求。<br>例如：对于浏览器请求，你想要提供一个 HTML 页面，但是对于 API 请求则保持代理。你可以这样做：</p><pre class=" language-javascript"><code class="language-javascript">proxy<span class="token punctuation">:</span> <span class="token punctuation">{</span>  <span class="token string">"/api"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    target<span class="token punctuation">:</span> <span class="token string">"http://localhost:3000"</span><span class="token punctuation">,</span>    bypass<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> proxyOptions<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span>headers<span class="token punctuation">.</span>accept<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"html"</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Skipping proxy for browser request."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"/index.html"</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如果想要代理多个目标路径大同一目标呢服务器上，则可以使用数组或者多个对象的形式：</p><pre class=" language-javascript"><code class="language-javascript">proxy<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>  context<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/auth"</span><span class="token punctuation">,</span> <span class="token string">"/api"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  target<span class="token punctuation">:</span> <span class="token string">"http://localhost:3000"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">//或者</span>proxy<span class="token punctuation">:</span> <span class="token punctuation">{</span>  <span class="token string">"/api"</span><span class="token punctuation">:</span><span class="token punctuation">{</span>      <span class="token string">"target"</span><span class="token punctuation">:</span><span class="token string">"http://localhost:3000/"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token string">"/auth"</span><span class="token punctuation">:</span><span class="token punctuation">{</span>      <span class="token string">"target"</span><span class="token punctuation">:</span><span class="token string">"http://localhost:4000/"</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器进程与线程</title>
      <link href="/2020/01/19/JavaScript/process-thread/"/>
      <url>/2020/01/19/JavaScript/process-thread/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器进程和线程"><a href="#浏览器进程和线程" class="headerlink" title="浏览器进程和线程"></a>浏览器进程和线程</h1><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><p>浏览器是多进程的。每一个Tab页就是一个独立的进程。</p><ul><li>浏览器进程（主进程）：个人理解为“管家”的角色，它控制着浏览器的各个任务，页面展示、网络请求、历史回退、前进等等</li><li>第三方插件进程：管理第三方插件</li><li>GPU线程：用于3D绘制</li><li>渲染进程：浏览器内核，多线程。主要负责页面渲染、脚本执行、事件循环等。对前端来说，最重要的进程。</li></ul><h4 id="浏览器多进程优势："><a href="#浏览器多进程优势：" class="headerlink" title="浏览器多进程优势："></a>浏览器多进程优势：</h4><ul><li>防止单个页面或者插件崩溃影响整个浏览器的运行。</li><li>可以充分利用浏览器多核的优势。</li><li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性。</li></ul><h1 id="浏览器内核（渲染进程）"><a href="#浏览器内核（渲染进程）" class="headerlink" title="浏览器内核（渲染进程）"></a>浏览器内核（渲染进程）</h1><p>渲染进程是多线程的。它包含一下几大线程：</p><ul><li>GUI线程<ul><li>它负责页面的渲染、布局、解析HTML、CSS、渲染DOM树。</li><li>当页面发生重绘或者回流的时候，就会触发该线程</li><li>它和JS引擎线程互斥</li></ul></li><li>JS引擎线程<ul><li>负责程序的解析和执行</li></ul></li><li>事件触发线程<ul><li>它控制事件循环，管理着一个事件<code>任务队列</code>TaskQueue</li><li>当异步任务满足条件时，会将该异步任务的回调函数放入到JS引擎线程所在的<code>执行栈</code>中执行</li></ul></li><li>定时触发器线程<ul><li>setTimeOut 和 setInterval 所在的线程</li><li>定时器任务的计时不是由JS引擎计时的，而是由该线程控制</li><li>当定时任务计时完成之后，会通知事件触发线程</li><li>W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。</li></ul></li><li>异步http请求线程<ul><li>一个独立的ajax请求线程</li><li>当请求完成之后，会通知事件触发线程</li></ul></li></ul><h4 id="为什么GUI线程和JS引擎线程互斥"><a href="#为什么GUI线程和JS引擎线程互斥" class="headerlink" title="为什么GUI线程和JS引擎线程互斥"></a>为什么GUI线程和JS引擎线程互斥</h4><p>因为JS是可以操作DOM的，如果使用JS操作DOM的同时，GUI线程也在渲染DOM，那么渲染完成之后的元素可能就不是之前的元素了</p><h4 id="为什么JS引擎是单线程"><a href="#为什么JS引擎是单线程" class="headerlink" title="为什么JS引擎是单线程"></a>为什么JS引擎是单线程</h4><ul><li>创建JavaScript语言的时候，多进程多线程的架构并不流行，硬件支持度不高</li><li>多进程多线程操作需要加锁，操作成本较高，较为复杂</li><li>如果多个线程同时操作一个DOM，那么结果会是不可预料的</li><li>线程之间资源共享</li></ul><h1 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h1><ul><li>JS的任务分为同步任何和异步任务的</li><li>同步任务都在JS引擎的执行栈上执行</li><li>事件触发线程管理一个任务队列，TaskQueue，当异步任务满足条件时，事件触发线程会将其放到任务队列当中，当主线程（JS引擎线程）执行完执行栈中的任务之后，会读取任务队列中的任务，如果有，就将可执行的异步任务的回调函数推入到执行栈中，开始执行。如果没有，则再次向事件触发线程发起询问，直到有为止。</li></ul><p><img src="http://cdn.yangkunxiao.cn/EventLoop.png#align=left&display=inline&height=706&originHeight=706&originWidth=1278&status=done&style=none&width=1278" alt=""></p><p>代码解释：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> timerCallback <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timerCallback'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> httpCallback <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'httpCallback'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 同步任务</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'同步任务1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 同步任务</span><span class="token comment" spellcheck="true">// 通知定时器线程 1s 后将 timerCallback 交由事件触发线程处理</span><span class="token comment" spellcheck="true">// 1s 后事件触发线程将 timerCallback 加入到事件队列中</span><span class="token function">setTimeout</span><span class="token punctuation">(</span>timerCallback<span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 同步任务</span><span class="token comment" spellcheck="true">// 通知异步http请求线程发送网络请求，请求成功后将 httpCallback 交由事件触发线程处理</span><span class="token comment" spellcheck="true">// 请求成功后事件触发线程将 httpCallback 加入到事件队列中</span>$<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'www.xxxx.com'</span><span class="token punctuation">,</span>httpCallback<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 同步任务</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'同步任务2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//...</span><span class="token comment" spellcheck="true">// 所有同步任务执行完后</span><span class="token comment" spellcheck="true">// 询问事件触发线程在事件事件队列中是否有需要执行的回调函数</span><span class="token comment" spellcheck="true">// 如果没有，一直询问，直到有为止</span><span class="token comment" spellcheck="true">// 如果有，将回调事件加入执行栈中，开始执行回调代码</span></code></pre><p>总结：</p><ul><li>JS引擎线程只执行执行栈中的事件</li><li>执行栈中的代码执行完毕，就会读取事件队列中的事件</li><li>事件队列中的回调事件，是由各自线程插入到事件队列中的</li><li>如此循环</li></ul><h4 id="宏任务、微任务"><a href="#宏任务、微任务" class="headerlink" title="宏任务、微任务"></a>宏任务、微任务</h4><p>宏任务：可以理解为浏览器级别的任务。主代码块，setTimeout，setInterval等，都属于宏任务</p><p>微任务：JS引擎级别的任务。Promise，process.nextTick等，属于<code>微任务</code>。</p><p>执行顺序：</p><ul><li>当前代码块对应的宏任务</li><li>当前宏任务结束之后，下一个宏任务开始之前，执行当前对列的微任务</li><li>GUI引擎渲染</li><li>下一个宏任务</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Koa2洋葱模型</title>
      <link href="/2020/01/16/Koa2/%20Onion-Model/"/>
      <url>/2020/01/16/Koa2/%20Onion-Model/</url>
      
        <content type="html"><![CDATA[<h1 id="浅解析洋葱模型"><a href="#浅解析洋葱模型" class="headerlink" title="浅解析洋葱模型"></a>浅解析洋葱模型</h1><p>koa2最大的特点就是独特的中间件控制流程。koa2基于NodeV7.6.0，可以直接使用async/await来替代generator，使得代码彻底摆脱“回调地狱”，可读性更佳。<br><a name="KlEWq"></a></p><h3 id="洋葱模型"><a href="#洋葱模型" class="headerlink" title="洋葱模型"></a>洋葱模型</h3><p>以下是一张中间件的“神图”，它可以清晰的表示出：从代码请求到响应的过程中，中间件的工作流程。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1579140335664-560c41e9-c60c-4004-9c8d-8991f1396ccf.png#align=left&display=inline&height=347&name=image.png&originHeight=694&originWidth=1034&size=342796&status=done&style=none&width=517" alt="image.png"><br><a name="FNydJ"></a></p><h4 id="小demo"><a href="#小demo" class="headerlink" title="小demo"></a>小demo</h4><p>先看个小🌰吧：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> Koa <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Koa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'koa服务器已启动'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1 3 5 4 2</span></code></pre><p>启动demo，访问服务器地址，控制台就会输出答案： 1、3、5、4、2 。<br />从这个🌰中，我们可以看出，当程序执行遇到await next() 的时候，会暂停执行当前代码块，进入下一个中间件，等下一个中间件执行完之后再回过头来继续处理。<br><a name="QoOvG"></a></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>当在一个中间件中调用await next()时，当前中间件就会把程序的控制权交给下一个中间件。当下游没有中间件等待执行的时候，程序就会回溯上游，执行上游中间件等待执行的行为。<br><a name="7htbI"></a></p><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>koa2的源码只有四个文件，详情请查看<a href="https://github.com/koajs/koa" target="_blank" rel="noopener">Koa2源码</a></p><ul><li>application.js：入口文件。</li><li>context.js：应用上下文文件。</li><li>request.js：请求处理文件。</li><li>response.js：响应处理文件。</li></ul><p>先从入口文件看起：<br><a name="M2Hls"></a></p><h4 id="application-js"><a href="#application-js" class="headerlink" title="application.js"></a>application.js</h4><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/**     * Shorthand for:     *     *    http.createServer(app.callback()).listen(...)     *     * @param {Mixed} ...     * @return {Server}     * @api public     */</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">'listen'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在入口文件中，我们可以看到，其实我们经常使用的<code>app.listen(port)</code>，只是一个“语法糖”，它只是使用来 <code>this.callback()</code> 来生成<code>node</code>的<code>httpServer</code>的回调函数。我们来看<code>this.callback()</code></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/**     * Return a request handler callback     * for node's native http server.     *     * @return {Function}     * @api public     */</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>middleware<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">listenerCount</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>onerror<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> handleRequest <span class="token operator">=</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> ctx <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> handleRequest<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在这段代码中，首先使用<code>compose</code>将中间件组合起来，<code>compose</code>就是一个柯里化函数，它接受中间件数组，返回一个函数，在返回函数中，接受应用上下文<code>ctx和next</code>，返回一个promise对象。<br /><a href="https://github.com/koajs/compose/blob/master/index.js" target="_blank" rel="noopener">compose源码</a>：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token string">'use strict'</span><span class="token comment" spellcheck="true">/** * Expose compositor. */</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> compose<span class="token comment" spellcheck="true">/** * Compose `middleware` returning * a fully valid middleware comprised * of all those which are passed. * * @param {Array} middleware * @return {Function} * @api public */</span><span class="token keyword">function</span> compose <span class="token punctuation">(</span>middleware<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>middleware<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Middleware stack must be an array!'</span><span class="token punctuation">)</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> fn <span class="token keyword">of</span> middleware<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> fn <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Middleware must be composed of functions!'</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/**   * @param {Object} context   * @return {Promise}   * @api public   */</span>  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>context<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// last called middleware #</span>    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">return</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">function</span> dispatch <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> index<span class="token punctuation">)</span> <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'next() called multiple times'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      index <span class="token operator">=</span> i      <span class="token keyword">let</span> fn <span class="token operator">=</span> middleware<span class="token punctuation">[</span>i<span class="token punctuation">]</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">===</span> middleware<span class="token punctuation">.</span>length<span class="token punctuation">)</span> fn <span class="token operator">=</span> next      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fn<span class="token punctuation">)</span> <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> dispatch<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在<code>compose</code>函数中，最重要的就是使用<code>diapatch()</code>函数，遍历中间件数组，然后将<code>ctx和dispatch(i + 1)</code>传递给中间件的方法中。它做到了以下两点：</p><ul><li>将ctx应用文对象一直传递下去。</li><li>将下一个中间件函数作为未来的next的返回值。</li></ul><p>在<code>this.callback()</code>中也使用了<code>createContext()</code> 和 <code>handleRequest()</code>方法，我们来看下它们做来什么。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/**     * Handle request in callback.     *     * @api private     */</span>    <span class="token function">handleRequest</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> fnMiddleware<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> res <span class="token operator">=</span> ctx<span class="token punctuation">.</span>res<span class="token punctuation">;</span>        res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">404</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> onerror <span class="token operator">=</span> err <span class="token operator">=</span><span class="token operator">></span> ctx<span class="token punctuation">.</span><span class="token function">onerror</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> handleResponse <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">respond</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">onFinished</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> onerror<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">fnMiddleware</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>handleResponse<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>onerror<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Initialize a new context.     *     * @api private     */</span>    <span class="token function">createContext</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> context <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> request <span class="token operator">=</span> context<span class="token punctuation">.</span>request <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> response <span class="token operator">=</span> context<span class="token punctuation">.</span>response <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span>app <span class="token operator">=</span> request<span class="token punctuation">.</span>app <span class="token operator">=</span> response<span class="token punctuation">.</span>app <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span>req <span class="token operator">=</span> request<span class="token punctuation">.</span>req <span class="token operator">=</span> response<span class="token punctuation">.</span>req <span class="token operator">=</span> req<span class="token punctuation">;</span>        context<span class="token punctuation">.</span>res <span class="token operator">=</span> request<span class="token punctuation">.</span>res <span class="token operator">=</span> response<span class="token punctuation">.</span>res <span class="token operator">=</span> res<span class="token punctuation">;</span>        request<span class="token punctuation">.</span>ctx <span class="token operator">=</span> response<span class="token punctuation">.</span>ctx <span class="token operator">=</span> context<span class="token punctuation">;</span>        request<span class="token punctuation">.</span>response <span class="token operator">=</span> response<span class="token punctuation">;</span>        response<span class="token punctuation">.</span>request <span class="token operator">=</span> request<span class="token punctuation">;</span>        context<span class="token punctuation">.</span>originalUrl <span class="token operator">=</span> request<span class="token punctuation">.</span>originalUrl <span class="token operator">=</span> req<span class="token punctuation">.</span>url<span class="token punctuation">;</span>        context<span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> context<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>在<code>createContext()</code>中，返回一个应用上下文对象<code>context</code>。在<code>handleRequest()</code>中，将应用上下文ctx和中间件进行绑定。<br />在Koa2中，我们使用中间件的时候需要使用<code>app.use()</code>来注册中间件，那么<code>app.use()</code>到底做来什么呢？</p><pre class=" language-javascript"><code class="language-javascript"> <span class="token comment" spellcheck="true">/**     * Use the given middleware `fn`.     *     * Old-style middleware will be converted.     *     * @param {Function} fn     * @return {Application} self     * @api public     */</span><span class="token function">use</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> fn <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'middleware must be a function!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isGeneratorFunction</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">deprecate</span><span class="token punctuation">(</span><span class="token string">'Support for generators will be removed in v3. '</span> <span class="token operator">+</span>              <span class="token string">'See the documentation for examples of how to convert old middleware '</span> <span class="token operator">+</span>              <span class="token string">'https://github.com/koajs/koa/blob/master/docs/migration.md'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    fn <span class="token operator">=</span> <span class="token function">convert</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">'use %s'</span><span class="token punctuation">,</span> fn<span class="token punctuation">.</span>_name <span class="token operator">||</span> fn<span class="token punctuation">.</span>name <span class="token operator">||</span> <span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>middleware<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>去除注释和验证，它只做了两件事：</p><ul><li>将中间件函数push到中间件数组(栈)。</li><li>返回koa实例对象。<pre class=" language-javascript"><code class="language-javascript"><span class="token function">use</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>middleware<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><p><a name="er16I"></a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所谓“洋葱模型”，就是当执行中间件函数的时候，如果碰到<code>await next()</code>，就会执行下一个中间件（上面说过，中间件注册的时候，会把下一个中间件当作未来的next()函数），这里next()就是下一个中间件函数。</p>]]></content>
      
      
      <categories>
          
          <category> Koa2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Koa2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Koa2基础</title>
      <link href="/2020/01/16/Koa2/base/"/>
      <url>/2020/01/16/Koa2/base/</url>
      
        <content type="html"><![CDATA[<h1 id="Koa2学习笔记"><a href="#Koa2学习笔记" class="headerlink" title="Koa2学习笔记"></a>Koa2学习笔记</h1><p><a name="1wfVW"></a></p><h2 id="Koa2简介"><a href="#Koa2简介" class="headerlink" title="Koa2简介"></a>Koa2简介</h2><p>Koa是一款新的web框架，它是由Express原班人马打造，相比与Express，Koa更加mini、简洁、健壮。它没有绑定任何中间件，如果我们需要，我们完全可以手撸任何中间件。而且，Koa2通过使用async/await，使得代码的可读性更佳。<br><a name="XZjHi"></a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Koa2依赖于nodeV7.6.0或者ES2015及更高的版本和async的支持。</p><pre class=" language-javascript"><code class="language-javascript">#初始化<span class="token keyword">package</span><span class="token punctuation">.</span>jsonnpm init#安装npm7npm install <span class="token number">7</span>#安装koa2npm install koa</code></pre><p><a name="2FIV5"></a></p><h3 id="async-await-小demo"><a href="#async-await-小demo" class="headerlink" title="async/await 小demo"></a>async/await 小demo</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'test async'</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>time<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">getSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">'something'</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//async await简单案例</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> res1 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> res2 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res1<span class="token punctuation">,</span>res2<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>2s之后，依次打印<code>test async something</code>。<br />await必须存在于async函数之内，且await后面的代码会被“阻塞”，等待await后面的promise执行。</p><ul><li>可以让异步逻辑用同步写法实现</li><li>await返回的需要是promise对象</li><li>可以通过多层 async function 的同步写法代替传统的callback嵌套<br><a name="O7S0g"></a><h3 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h3></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> Koa <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Koa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//入门🌰</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> <span class="token string">'hello kaka'</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello koa'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span></code></pre><p>启动demo，<code>node app.js</code>，打开<a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a>，即可看到:<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1579095453796-e8cb2c09-b080-429f-a755-a6cd34c2899e.png#align=left&display=inline&height=128&name=image.png&originHeight=256&originWidth=2130&size=92159&status=done&style=none&width=1065" alt="image.png"><br><a name="3vqTK"></a></p><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p><a name="kcrwS"></a></p><h3 id="kao中间件开发与使用"><a href="#kao中间件开发与使用" class="headerlink" title="kao中间件开发与使用"></a>kao中间件开发与使用</h3><p>中间件的类型有一下四种：</p><ul><li>应用级中间件</li><li>路由级中间件</li><li>错误处理中间件</li><li>第三方中间件<br><a name="TRa97"></a><h4 id="洋葱模型"><a href="#洋葱模型" class="headerlink" title="洋葱模型"></a>洋葱模型</h4>当一个中间件调用 next() 则该函数暂停并将控制传递给定义的下一个中间件。<br />当在下游没有更多的中间件执行后，堆栈将展开并且每个中间件恢复执行其上游行为。<br />看🌰：</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> Koa <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Koa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//洋葱模型</span><span class="token comment" spellcheck="true">// #1</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// #2</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">await</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'koa服务器已启动'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1 3 5 4 2</span></code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1579098156840-d6938d82-0e6c-4268-bd66-8e6cf529ae30.png#align=left&display=inline&height=457&name=image.png&originHeight=914&originWidth=1194&size=499102&status=done&style=none&width=597" alt="image.png"><br /></p><p><a name="8UENn"></a></p><h4 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h4><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//middleware/logger.js</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token keyword">async</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    ctx<span class="token punctuation">.</span>state<span class="token punctuation">.</span>commondata <span class="token operator">=</span> <span class="token string">'我是应用级中间件'</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"应用级中间件"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">await</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><a name="PwNgl"></a></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//app.js</span><span class="token keyword">const</span> Koa <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> logger <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./middleware/logger'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Koa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//应用级中间件</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>logger<span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'koa服务器已启动'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><a name="zy98m"></a></p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p><a name="JZ0Uj"></a></p><h3 id="原生实现"><a href="#原生实现" class="headerlink" title="原生实现"></a>原生实现</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> Koa <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Koa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> bodyparser <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa-bodyparser'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">bodyparser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @param { string } 文件名 * @return { promise } 返回文件 *  */</span><span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> pagePath <span class="token operator">=</span> <span class="token template-string"><span class="token string">`./html/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>page<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>pagePath<span class="token punctuation">)</span>        fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>pagePath<span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * @param { string } 访问路由 * @return { string }  html*/</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getHtml</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> page <span class="token operator">=</span> <span class="token string">'404.html'</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token string">'/'</span><span class="token punctuation">:</span>            <span class="token punctuation">{</span>                page <span class="token operator">=</span> <span class="token string">'index.html'</span><span class="token punctuation">;</span>                <span class="token keyword">break</span>            <span class="token punctuation">}</span>        <span class="token keyword">case</span> <span class="token string">'/list'</span><span class="token punctuation">:</span>            <span class="token punctuation">{</span>                page <span class="token operator">=</span> <span class="token string">'list.html'</span><span class="token punctuation">;</span>                <span class="token keyword">break</span>            <span class="token punctuation">}</span>        <span class="token keyword">default</span><span class="token punctuation">:</span>            <span class="token punctuation">{</span>                page <span class="token operator">=</span> <span class="token string">'404.html'</span><span class="token punctuation">;</span>                <span class="token keyword">break</span>            <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">let</span> html <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">render</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> html<span class="token punctuation">}</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//读取文件是异步</span>    <span class="token keyword">let</span> html <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getHtml</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> html<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"server is running at http://127.0.0.1:3000"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>启动demo之后，访问<a href="http://localhost:3000/，" target="_blank" rel="noopener">http://localhost:3000/</a>即可<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/705088/1579097257575-a5314b89-8a2d-465b-80a2-89b043ea75c2.png#align=left&display=inline&height=297&name=image.png&originHeight=594&originWidth=2136&size=160514&status=done&style=none&width=1068" alt="image.png"><br><a name="Vkn9O"></a></p><h3 id="koa-router"><a href="#koa-router" class="headerlink" title="koa-router"></a>koa-router</h3><p>安装对应的koa-router中间件：<br /><code>npm install koa-router</code><br /><a href="https://github.com/yangkunxiao/koa2/blob/master/demo05.js" target="_blank" rel="noopener">demo源码</a></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> Koa <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> bodyparser <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa-bodyparser'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> Router <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa-router'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Koa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//设置路由前缀 </span>    prefix<span class="token punctuation">:</span><span class="token string">'/kaka'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>router<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span>next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>router<span class="token punctuation">.</span><span class="token function">routes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>router<span class="token punctuation">.</span><span class="token function">allowedMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"server is running at http://127.0.0.1:3000"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><a name="OQeoY"></a></p><h2 id="请求数据处理"><a href="#请求数据处理" class="headerlink" title="请求数据处理"></a>请求数据处理</h2><p><a name="LLtOO"></a></p><h3 id="Get请求"><a href="#Get请求" class="headerlink" title="Get请求"></a>Get请求</h3><p>在koa中，获取GET请求数据源头是koa中request对象中的query方法或querystring方法，query返回是格式化好的参数对象，querystring返回的是请求字符串，由于ctx对request的API有直接引用的方式，所以获取GET请求数据有两个途径。</p><ul><li>是从上下文中直接获取</li><li>是从上下文的request对象中获取</li></ul><p>看🌰: <a href="https://github.com/yangkunxiao/koa2/blob/master/demo03.js" target="_blank" rel="noopener">源码</a></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> Koa <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Koa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> bodyParse <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa-bodyparser'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使用中间件koa-bodyparser</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">bodyParse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> request <span class="token operator">=</span> ctx<span class="token punctuation">.</span>request<span class="token punctuation">;</span>    <span class="token keyword">const</span> url <span class="token operator">=</span> ctx<span class="token punctuation">.</span>url<span class="token punctuation">;</span>    <span class="token keyword">const</span> method <span class="token operator">=</span> request<span class="token punctuation">.</span>method<span class="token punctuation">;</span>    <span class="token keyword">const</span> query <span class="token operator">=</span> request<span class="token punctuation">.</span>query<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//返回的是格式化好的参数对象。</span>    <span class="token keyword">const</span> querystring <span class="token operator">=</span> request<span class="token punctuation">.</span>querystring<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//返回的是请求字符串。</span>    <span class="token comment" spellcheck="true">//直接从ctx中获取query</span>    <span class="token keyword">const</span> ctx_query <span class="token operator">=</span> ctx<span class="token punctuation">.</span>query<span class="token punctuation">;</span>    <span class="token keyword">const</span> ctx_querystring <span class="token operator">=</span> ctx<span class="token punctuation">.</span>querystring<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>method <span class="token operator">===</span> <span class="token string">'GET'</span> <span class="token operator">&amp;&amp;</span> url <span class="token operator">===</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> <span class="token template-string"><span class="token string">`        &lt;h1>Koa2 request post demo&lt;/h1>        &lt;form method="POST"  action="/">            &lt;p>userName&lt;/p>            &lt;input name="userName" /> &lt;br/>            &lt;p>age&lt;/p>            &lt;input name="age" /> &lt;br/>            &lt;p>webSite&lt;/p>            &lt;input name='webSite' />&lt;br/>            &lt;button type="submit">submit&lt;/button>        &lt;/form>        `</span></span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">'/'</span> <span class="token operator">&amp;&amp;</span> ctx<span class="token punctuation">.</span>method <span class="token operator">===</span> <span class="token string">'POST'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// const postDate = await handlePostData(ctx);</span>        <span class="token keyword">const</span> postDate <span class="token operator">=</span> ctx<span class="token punctuation">.</span>request<span class="token punctuation">.</span>body<span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> postDate<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//其它请求显示404页面</span>        ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> <span class="token string">'&lt;h1>404!&lt;/h1>'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> <span class="token punctuation">{</span>        url<span class="token punctuation">,</span>        methods<span class="token punctuation">,</span>        query<span class="token punctuation">,</span>        querystring<span class="token punctuation">,</span>        ctx_query<span class="token punctuation">,</span>        ctx_querystring    <span class="token punctuation">}</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span></code></pre><p><a name="8dDci"></a></p><h3 id="Post请求"><a href="#Post请求" class="headerlink" title="Post请求"></a>Post请求</h3><p>对于POST请求的处理，koa2没有封装获取参数的方法，需要通过解析上下文context中的原生node.js请求对象req，将POST表单数据解析成query string，再将query string 解析成JSON格式。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//使用node中的方式处理post请求数据</span><span class="token keyword">function</span> <span class="token function">handlePostData</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> querystring <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>            ctx<span class="token punctuation">.</span>req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                querystring <span class="token operator">+</span><span class="token operator">=</span> data<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>            ctx<span class="token punctuation">.</span>req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">let</span> bodyParse <span class="token operator">=</span> <span class="token function">parseStringData</span><span class="token punctuation">(</span>querystring<span class="token punctuation">)</span>                <span class="token function">resolve</span><span class="token punctuation">(</span>bodyParse<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">parseStringData</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> item <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> stringList <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'&amp;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token keyword">of</span> stringList<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        item<span class="token punctuation">[</span>value<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'='</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">decodeURIComponent</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'='</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> item<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="aKKyJ"></a></p><h3 id="使用koa-parser中间件"><a href="#使用koa-parser中间件" class="headerlink" title="使用koa-parser中间件"></a>使用koa-parser中间件</h3><p>对于POST请求的处理，koa-bodyparser中间件可以把koa2上下文的formData数据解析到ctx.request.body中<br />安装：<code>npm install koa-parser</code>。<br />使用：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> bodyParse <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa-bodyparser'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使用中间件koa-bodyparser</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">bodyParse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><a name="f0a8J"></a></p><h2 id="静态资源处理"><a href="#静态资源处理" class="headerlink" title="静态资源处理"></a>静态资源处理</h2><p><a name="QGNys"></a></p><h3 id="koa-static中间件"><a href="#koa-static中间件" class="headerlink" title="koa-static中间件"></a>koa-static中间件</h3><p>安装：<code>npm install koa-static</code></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> Koa <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa-static'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Koa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">static</span><span class="token punctuation">(</span>    path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">'./static'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span> <span class="token keyword">async</span> <span class="token punctuation">(</span> ctx <span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> <span class="token string">'hello world'</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'static-use-middleware is starting at port 3000'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><a name="ZkFRd"></a></p><h2 id="cookie-session"><a href="#cookie-session" class="headerlink" title="cookie/session"></a>cookie/session</h2><p><a name="VybS8"></a></p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>koa提供了直接操作cookie的方法：</p><ul><li>ctx.cookies.get(name, [options]) 读取上下文请求中的cookie</li><li>ctx.cookies.set(name, value, [options]) 在上下文中写入cookie</li></ul><p>使用：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> Koa <span class="token operator">=</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Koa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * domain：写入cookie所在的域名     * path：写入cookie所在的路径     * maxAge：Cookie最大有效时长     * expires：cookie失效时间     * httpOnly:是否只用http请求中获得     * overwirte：是否允许重写    */</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ctx<span class="token punctuation">.</span>cookies<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>            <span class="token string">"name"</span><span class="token punctuation">,</span><span class="token string">"ykx"</span><span class="token punctuation">,</span><span class="token punctuation">{</span>                domain<span class="token punctuation">:</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span>                maxAge<span class="token punctuation">:</span><span class="token number">1000</span><span class="token operator">*</span><span class="token number">60</span><span class="token operator">*</span><span class="token number">60</span><span class="token operator">*</span><span class="token number">24</span><span class="token operator">*</span><span class="token number">30</span><span class="token punctuation">,</span>                expires<span class="token punctuation">:</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token string">'2020-12-30'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                httpOnly<span class="token punctuation">:</span><span class="token boolean">false</span><span class="token punctuation">,</span>                overwrite<span class="token punctuation">:</span><span class="token boolean">true</span>            <span class="token punctuation">}</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> <span class="token string">'cookie is ready'</span>   <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>cookies<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">const</span> str <span class="token operator">=</span> ctx<span class="token punctuation">.</span>cookies<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> str<span class="token punctuation">;</span>       <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> <span class="token string">'cookies is none'</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><a name="OvJpf"></a></p><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>koa原生只提供了操作cookie的方法，但是没有session操作。所以对sessino的操作需要自己实现或者使用第三方插件。<br />将session存储到数据库，需要使用第三方插件：</p><ul><li>koa-session-minimal 适用于koa2 的session中间件，提供存储介质的读写接口 。</li><li>koa-mysql-session 为koa-session-minimal中间件提供MySQL数据库的session数据读写操作。</li></ul><p>安装：</p><pre class=" language-javascript"><code class="language-javascript">npm install koa<span class="token operator">-</span>session<span class="token operator">-</span>minimal koa<span class="token operator">-</span>mysql<span class="token operator">-</span>session <span class="token operator">--</span>save</code></pre><p>过程：</p><ul><li>生成session，并存储到数据库。</li><li>使用插件操作数据库，并将sessionId和对应的数据存储到数据库。</li><li>将数据库的sessionId写入到页面的cookie中。</li><li>根据页面cookie携带的sessionId取出数据库中对应的数据。</li></ul><p>看代码：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> Koa <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> session <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"koa-session-minimal"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> MysqlSession <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"koa-mysql-session"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Koa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 配置存储session信息的mysql</span><span class="token keyword">let</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MysqlSession</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    user<span class="token punctuation">:</span> <span class="token string">'root'</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//数据库用户</span>    password<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//密码</span>    database<span class="token punctuation">:</span> <span class="token string">'test'</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//数据库名称</span>    host<span class="token punctuation">:</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//数据库地址</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 存放sessionId的cookie配置</span><span class="token keyword">let</span> cookie <span class="token operator">=</span> <span class="token punctuation">{</span>    maxAge<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// cookie有效时长</span>    expires<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// cookie失效时间</span>    path<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 写cookie所在的路径</span>    domain<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 写cookie所在的域名</span>    httpOnly<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 是否只用于http请求中获取</span>    overwrite<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 是否允许重写</span>    secure<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>    sameSite<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>    signed<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">session</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    key<span class="token punctuation">:</span> <span class="token string">'SESSION_ID'</span><span class="token punctuation">,</span>    store<span class="token punctuation">,</span>    cookie<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 设置session</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">'/set'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ctx<span class="token punctuation">.</span>session <span class="token operator">=</span> <span class="token punctuation">{</span>            user_id<span class="token punctuation">:</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">36</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            count<span class="token punctuation">:</span> <span class="token number">0</span>        <span class="token punctuation">}</span>        ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> ctx<span class="token punctuation">.</span>session    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 读取session信息</span>        ctx<span class="token punctuation">.</span>session<span class="token punctuation">.</span>count <span class="token operator">=</span> ctx<span class="token punctuation">.</span>session<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span>        ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> ctx<span class="token punctuation">.</span>session    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'[demo] session is starting at port 3000'</span><span class="token punctuation">)</span></code></pre><p><a name="QgQlX"></a></p><h2 id="模版引擎ejs"><a href="#模版引擎ejs" class="headerlink" title="模版引擎ejs"></a>模版引擎ejs</h2><p><a name="KPvdu"></a></p><h3 id="ejs"><a href="#ejs" class="headerlink" title="ejs"></a>ejs</h3><p>具体使用请查看<a href="https://ejs.bootcss.com/" target="_blank" rel="noopener">官方文档</a><br><a name="3zFI3"></a></p><h3 id="koa2使用ejs"><a href="#koa2使用ejs" class="headerlink" title="koa2使用ejs"></a>koa2使用ejs</h3><p>安装：</p><pre class=" language-javascript"><code class="language-javascript">#安装koa模版使用中间件npm install koa<span class="token operator">-</span>views <span class="token operator">--</span>save#安装ejs模版引擎npm install ejs <span class="token operator">--</span>save</code></pre><p>使用：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> Koa <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> views <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa-views'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Koa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//加载ejs模版 设置模版文件夹</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">views</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">'./views'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">{</span>    extension<span class="token punctuation">:</span><span class="token string">'ejs'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> title <span class="token operator">=</span> <span class="token string">'hello ejs'</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//渲染模版</span>    <span class="token keyword">await</span> ctx<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token string">'index'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>        title    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'server is starting at 127.0.0.1:3000'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>views下的模版：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>title<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">=</span> title <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span>    <span class="token operator">&lt;</span>h1<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">=</span> title <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>EJS Welcome to <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">=</span> title <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span></code></pre><p><a name="M5CLj"></a></p><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p><a name="b2vUY"></a></p><h4 id="busboy"><a href="#busboy" class="headerlink" title="busboy"></a>busboy</h4><p>busboy用来解析Post请求，读取原生node的req中的文件流。具体使用请<a href="https://www.npmjs.com/package/busboy" target="_blank" rel="noopener">移步</a>。<br />安装：<br /><code>npm install busboy --save</code><br />使用：<a href="https://github.com/yangkunxiao/koa2/blob/master/demo12.js" target="_blank" rel="noopener">源码</a><br />app.js</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//文件上传</span><span class="token keyword">const</span> Koa <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> Views <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa-views'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> Router <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa-router'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> upload <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./util/syncUpload.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa-static'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Koa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">Views</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname <span class="token operator">+</span> <span class="token string">'/views'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    extension<span class="token punctuation">:</span> <span class="token string">'ejs'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">static</span><span class="token punctuation">(</span><span class="token string">'static'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>router<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token keyword">async</span> ctx <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">await</span> ctx<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token string">'upload'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>router<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">'/upload'</span><span class="token punctuation">,</span> <span class="token keyword">async</span> ctx <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">upload</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token punctuation">{</span>        path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'static'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> <span class="token string">'&lt;img src="'</span> <span class="token operator">+</span> res<span class="token punctuation">.</span>path <span class="token operator">+</span> <span class="token string">'" style="max-width: 100%">'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>router<span class="token punctuation">.</span><span class="token function">routes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>router<span class="token punctuation">.</span><span class="token function">allowedMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span></code></pre><p>ejs上传模版：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html lang<span class="token operator">=</span><span class="token string">"en"</span><span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"viewport"</span> content<span class="token operator">=</span><span class="token string">"width=device-width, initial-scale=1.0"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>meta http<span class="token operator">-</span>equiv<span class="token operator">=</span><span class="token string">"X-UA-Compatible"</span> content<span class="token operator">=</span><span class="token string">"ie=edge"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>title<span class="token operator">></span>文件上传<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span>    <span class="token operator">&lt;</span>form action<span class="token operator">=</span><span class="token string">"/upload"</span> method<span class="token operator">=</span><span class="token string">"post"</span> enctype<span class="token operator">=</span><span class="token string">"multipart/form-data"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>label <span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"file"</span><span class="token operator">></span>文件<span class="token operator">&lt;</span><span class="token operator">/</span>label<span class="token operator">></span>        <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"file"</span> name<span class="token operator">=</span><span class="token string">"file"</span> id<span class="token operator">=</span><span class="token string">"file"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"submit"</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>form<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span></code></pre><p>node上传处理文件</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> BusBoy <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'busboy'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 获取上传文件的后缀名 * @param  {string} fileName 获取上传文件的后缀名 * @return {string}          文件后缀名 */</span><span class="token keyword">function</span> <span class="token function">getFileSuffixName</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> nameList <span class="token operator">=</span> fileName<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> nameList<span class="token punctuation">[</span>nameList<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 同步创建文件目录 * @param { string } filePath 文件上传路径 * @return { boolean }         返回结果 */</span><span class="token keyword">function</span> <span class="token function">mkdirPath</span><span class="token punctuation">(</span>dirname<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fs<span class="token punctuation">.</span><span class="token function">existsSync</span><span class="token punctuation">(</span>dirname<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    fs<span class="token punctuation">.</span><span class="token function">mkdirSync</span><span class="token punctuation">(</span>dirname<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 同步上传文件 * @param { ctx } Object 上下文对象 * @param { options } Object 配置参数 * @return { promise }   返回上传结果的promise */</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> options<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> req <span class="token operator">=</span> ctx<span class="token punctuation">.</span>req<span class="token punctuation">;</span>        <span class="token keyword">let</span> res <span class="token operator">=</span> ctx<span class="token punctuation">.</span>res<span class="token punctuation">;</span>        <span class="token keyword">let</span> busboy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BusBoy</span><span class="token punctuation">(</span><span class="token punctuation">{</span> headers<span class="token punctuation">:</span> req<span class="token punctuation">.</span>headers <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">{</span>            success<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>            path<span class="token punctuation">:</span> <span class="token keyword">null</span>        <span class="token punctuation">}</span>        busboy<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'file'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>fieldname<span class="token punctuation">,</span> file<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> encoding<span class="token punctuation">,</span> mimetype<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'File ['</span> <span class="token operator">+</span> fieldname <span class="token operator">+</span> <span class="token string">']: filename: '</span> <span class="token operator">+</span> filename <span class="token operator">+</span> <span class="token string">'encoding: '</span> <span class="token operator">+</span> encoding <span class="token operator">+</span> <span class="token string">'mimetype: '</span> <span class="token operator">+</span> mimetype<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">let</span> fileName <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.'</span> <span class="token operator">+</span> <span class="token function">getFileSuffixName</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// let filePath = mkdirPath(options.path) &amp;&amp; (options.path + '/' + filename);</span>            <span class="token keyword">let</span> filePath <span class="token operator">=</span> filename<span class="token punctuation">;</span>            file<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> data <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'File ['</span> <span class="token operator">+</span> filename <span class="token operator">+</span> <span class="token string">'] got '</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token string">' bytes'</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            file<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'File ['</span> <span class="token operator">+</span> filename <span class="token operator">+</span> <span class="token string">'] finished '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                result<span class="token punctuation">.</span>success <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                result<span class="token punctuation">.</span>path <span class="token operator">=</span> filePath<span class="token punctuation">;</span>                <span class="token function">resolve</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            file<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token function">reject</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 解析表单中其他字段信息</span>            busboy<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'field'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>fieldname<span class="token punctuation">,</span> val<span class="token punctuation">,</span> fieldnameTruncated<span class="token punctuation">,</span> valTruncated<span class="token punctuation">,</span> encoding<span class="token punctuation">,</span> mimetype<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// console.log('表单字段数据 [' + fieldname + ']: value: ' + inspect(val));</span>                <span class="token comment" spellcheck="true">// result.formData[fieldname] = inspect(val);</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 解析结束事件</span>            busboy<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'finish'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'文件上传结束'</span><span class="token punctuation">)</span>                <span class="token function">resolve</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 解析错误事件</span>            busboy<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'文件上传出错'</span><span class="token punctuation">)</span>                <span class="token function">reject</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            file<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>fs<span class="token punctuation">.</span><span class="token function">createWriteStream</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        req<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>busboy<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Koa2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Koa2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片优化</title>
      <link href="/2020/01/13/Optimize/img/"/>
      <url>/2020/01/13/Optimize/img/</url>
      
        <content type="html"><![CDATA[<h1 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h1><h3 id="为什么要做图片优化？"><a href="#为什么要做图片优化？" class="headerlink" title="为什么要做图片优化？"></a>为什么要做图片优化？</h3><p>Google官方的最佳实践中关于图片优化有下面这样一段描述：</p><blockquote><p>对于网页来说，在所下载的字节数中，图片往往会占很大比例。因此，优化图片通常可以卓有成效地减少字节数和改进性能：浏览器需要下载的字节数越少，对客户端带宽的争用就越少，浏览器下载内容并在屏幕上呈现内容的速度就越快。</p></blockquote><p>我们可以通过一些第三方方法来看一下在一个网站中，图片所占比例的大小：使用<a href="https://webpagetest.org/" target="_blank" rel="noopener">webTest</a>网站，可以清楚的看到一个网站首屏加载时，图片所占比例的大小。而且电商网站中，图片所占比例占比是最大的。</p><p>通过优化图片可以减少客户端下载的字节数，改进网页性能。</p><h3 id="图片类型和使用场景"><a href="#图片类型和使用场景" class="headerlink" title="图片类型和使用场景"></a>图片类型和使用场景</h3><p>一般常用的图片格式有那么几种：JPEG/JPG、PNG、WebP、Base64、SVG。</p><blockquote><p>JPEG和JPG格式有什么区别？</p></blockquote><p>没有区别，全名、正式扩展名是JPEG。但因DOS、Windows 95等早期系统采用的8.3命名规则只支持最长3字符的扩展名，为了兼容采用了.jpg。也因历史习惯和兼容性考虑，.jpg目前更流行。</p><h4 id="JPEG-JPG"><a href="#JPEG-JPG" class="headerlink" title="JPEG/JPG"></a>JPEG/JPG</h4><p>特点：有损压缩，体积小，加载快，不支持透明。</p><p>适用场景：适用于呈现色彩丰富的图片，在我们日常开发中，JPG 图片经常作为大的背景图、轮播图或 Banner 图出现。</p><h4 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h4><p>特点：无损压缩，体积大，质量高，支持透明。</p><p>适用场景：PNG 在处理线条和颜色对比度方面有优势，主要用它来呈现小的 Logo、颜色简单且对比强烈的图片或背景等</p><h4 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h4><p>特点：文本文件，体积线，不失真，兼容性好。</p><p>适用场景：将 SVG 写入独立文件后引入 HTML</p><p>​    <code>&lt;img src=&quot;文件名.svg&quot; alt=&quot;&quot;&gt;</code></p><h4 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h4><p>特点：文本文件、依赖编码、小图标解决方案。</p><p>适用场景：小图标，更新频率非常低，作为雪碧图的补充。</p><h4 id="WebP"><a href="#WebP" class="headerlink" title="WebP"></a>WebP</h4><blockquote><p>WebP 是 Google 专为 Web 开发的一种旨在加快图片加载速度的图片格式，它支持有损压缩和无损压缩。</p></blockquote><p>特点：全能，但是有兼容性问题。</p><p>适用场景：限制我们使用 WebP 的最大问题不是“这个图片是否适合用 WebP 呈现”，而是“浏览器是否允许 WebP”。</p><h3 id="图片优化方案"><a href="#图片优化方案" class="headerlink" title="图片优化方案"></a>图片优化方案</h3><h4 id="减少图片体积"><a href="#减少图片体积" class="headerlink" title="减少图片体积"></a>减少图片体积</h4><p>使用WebP的方式，都可以在不降低图片质量的条件下，减少图片体积的。</p><blockquote><p>WebP 的优势是它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。</p></blockquote><p><a href="https://cloudconvert.com/" target="_blank" rel="noopener">cloudconvert</a>可以在线转换WebP图片。</p><p>在淘宝首页，就有一些图片就是WebP类型的。淘宝是根据浏览器是否支持WebP来动态的设置图片url的。</p><p>那么如何判断浏览器是否支持WebP呢？</p><p>Google官方文档是这样处理的（先加载一个WebP图片，如果能获取到图片的宽度和高度，就说明是支持WebP的，反之则不支持）：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">check_webp_feature</span><span class="token punctuation">(</span>feature<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> kTestImages <span class="token operator">=</span> <span class="token punctuation">{</span>        lossy<span class="token punctuation">:</span> <span class="token string">"UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"</span><span class="token punctuation">,</span>        lossless<span class="token punctuation">:</span> <span class="token string">"UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA=="</span><span class="token punctuation">,</span>        alpha<span class="token punctuation">:</span> <span class="token string">"UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA=="</span><span class="token punctuation">,</span>        animation<span class="token punctuation">:</span> <span class="token string">"UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA"</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    img<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token punctuation">(</span>img<span class="token punctuation">.</span>width <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>img<span class="token punctuation">.</span>height <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">callback</span><span class="token punctuation">(</span>feature<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    img<span class="token punctuation">.</span>onerror <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">callback</span><span class="token punctuation">(</span>feature<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    img<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">"data:image/webp;base64,"</span> <span class="token operator">+</span> kTestImages<span class="token punctuation">[</span>feature<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>原理：对每一种格式的webp(有损，无损，alpha通道，动态)生成一个很小像素的图片，在浏览器中渲染，如果没有问题，就代表支持webp。</p><p>还有一种方法，就是让服务器来判断浏览器是否支持WebP格式：服务器通过HTTP请求头的Accept字段，来判断返回什么格式的图片。当 Accept 字段包含 image/webp 时，就返回 WebP 格式的图片，否则返回原图。</p><p>利用SVGO压缩svg文件的大小。</p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><h4 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h4><p>懒加载的原理是：将图片的url赋值给img的data-url（可自定义）属性，监听滚动事件，当图片进入可视区域时，将data-url的值赋值给img的url属性，这时才真正发出图片的http请求。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 简单的节流函数</span><span class="token comment" spellcheck="true">//fun 要执行的函数</span><span class="token comment" spellcheck="true">//delay 延迟</span><span class="token comment" spellcheck="true">//time  在time时间内必须执行一次</span><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span>fun<span class="token punctuation">,</span> delay<span class="token punctuation">,</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> timeout<span class="token punctuation">,</span>        startTime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">,</span>            args <span class="token operator">=</span> arguments<span class="token punctuation">,</span>            curTime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果达到了规定的触发时间间隔，触发 handler</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>curTime <span class="token operator">-</span> startTime <span class="token operator">>=</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>            fun<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>            startTime <span class="token operator">=</span> curTime<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 没达到触发间隔，重新设定定时器</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>fun<span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 实际想绑定在 scroll 事件上的 handler</span><span class="token keyword">function</span> <span class="token function">lazyload</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> n<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> imgNum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>img<span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">offset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>top <span class="token operator">&lt;</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token function">$</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token function">$</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">scrollTop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>img<span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"src"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">"default.jpg"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">var</span> src <span class="token operator">=</span> img<span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"data-src"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                img<span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"src"</span><span class="token punctuation">,</span> src<span class="token punctuation">)</span><span class="token punctuation">;</span>                n <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 采用了节流函数</span>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'scroll'</span><span class="token punctuation">,</span> <span class="token function">throttle</span><span class="token punctuation">(</span>lazyload<span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="响应式图片"><a href="#响应式图片" class="headerlink" title="响应式图片"></a>响应式图片</h4><blockquote><p>一种可以在不同的屏幕尺寸和分辨率的设备上都能良好工作以及其他特性的图片.</p></blockquote><h4 id="艺术方向"><a href="#艺术方向" class="headerlink" title="艺术方向"></a>艺术方向</h4><p>当你想为不同布局提供不同剪裁的图片——比如在桌面布局上显示完整的、横向图片，而在手机布局上显示一张剪裁过的、突出重点的纵向图片，可以用  元素来实现。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>picture<span class="token operator">></span>  <span class="token operator">&lt;</span>source media<span class="token operator">=</span><span class="token string">"(max-width: 799px)"</span> srcset<span class="token operator">=</span><span class="token string">"elva-480w-close-portrait.jpg"</span><span class="token operator">></span>  <span class="token operator">&lt;</span>source media<span class="token operator">=</span><span class="token string">"(min-width: 800px)"</span> srcset<span class="token operator">=</span><span class="token string">"elva-800w.jpg"</span><span class="token operator">></span>  <span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token string">"elva-800w.jpg"</span> alt<span class="token operator">=</span><span class="token string">"Chris standing up holding his daughter Elva"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>picture<span class="token operator">></span></code></pre><h4 id="分辨率切换"><a href="#分辨率切换" class="headerlink" title="分辨率切换"></a>分辨率切换</h4><p>当你想要为窄屏提供更小的图片时，因为小屏幕不需要像桌面端显示那么大的图片；以及你想为高/低分辨率屏幕提供不同分辨率的图片时，都可以通过 vector graphics (SVG images)、 srcset 以及 sizes 属性来实现。</p><p>分辨率切换：不同的尺寸</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>img srcset<span class="token operator">=</span>"elva<span class="token operator">-</span>fairy<span class="token operator">-</span>320w<span class="token punctuation">.</span>jpg 320w<span class="token punctuation">,</span>             elva<span class="token operator">-</span>fairy<span class="token operator">-</span>480w<span class="token punctuation">.</span>jpg 480w<span class="token punctuation">,</span>             elva<span class="token operator">-</span>fairy<span class="token operator">-</span>800w<span class="token punctuation">.</span>jpg 800w"     sizes<span class="token operator">=</span>"<span class="token punctuation">(</span>max<span class="token operator">-</span>width<span class="token punctuation">:</span> 320px<span class="token punctuation">)</span> 280px<span class="token punctuation">,</span>            <span class="token punctuation">(</span>max<span class="token operator">-</span>width<span class="token punctuation">:</span> 480px<span class="token punctuation">)</span> 440px<span class="token punctuation">,</span>            800px"     src<span class="token operator">=</span><span class="token string">"elva-fairy-800w.jpg"</span> alt<span class="token operator">=</span><span class="token string">"Elva dressed as a fairy"</span><span class="token operator">></span></code></pre><p>分辨率切换: 相同的尺寸, 不同的分辨率</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>img srcset<span class="token operator">=</span>"elva<span class="token operator">-</span>fairy<span class="token operator">-</span>320w<span class="token punctuation">.</span>jpg<span class="token punctuation">,</span>             elva<span class="token operator">-</span>fairy<span class="token operator">-</span>480w<span class="token punctuation">.</span>jpg <span class="token number">1</span><span class="token punctuation">.</span>5x<span class="token punctuation">,</span>             elva<span class="token operator">-</span>fairy<span class="token operator">-</span>640w<span class="token punctuation">.</span>jpg 2x"     src<span class="token operator">=</span><span class="token string">"elva-fairy-640w.jpg"</span> alt<span class="token operator">=</span><span class="token string">"Elva dressed as a fairy"</span><span class="token operator">></span></code></pre><p>一般情况下当我们给<code>img</code>设置固定的宽的时候,为了在不同的<code>dpr</code>设备上显示相同的大小，可以配合<code>x</code>来，例如<code>1.5x</code>代表dpr为1.5的设备</p><h4 id="srcset-sizes-新特性"><a href="#srcset-sizes-新特性" class="headerlink" title="srcset/sizes/ 新特性"></a>srcset/sizes/<picture> 新特性</h4><blockquote><p>已经被新版本的现代浏览器和移动浏览器所支 持（包括Edge，而不是IE）。</p></blockquote><ul><li><code>srcset</code>语法: “图片路径 物理像素, 图片路径 物理像素, …..”。</li><li><code>size</code>: “媒体查询 css像素”。</li><li><code>src</code>: 当浏览器不支持上面的属性的时候，默认加载这里。</li></ul><p>加载的流程如下：</p><ul><li>查看设备宽度</li><li>查看sizes中哪一个媒体查询条件为真。</li><li>查看给予该媒体查询的槽大小。</li><li>加载srcset列表中引用的<strong>最接近</strong>所选的槽大小的图像</li></ul><p>一般 <code>1px = 1w</code>。</p><h3 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h3><h4 id="雪碧图"><a href="#雪碧图" class="headerlink" title="雪碧图"></a>雪碧图</h4><h4 id="base64编码内联小图片"><a href="#base64编码内联小图片" class="headerlink" title="base64编码内联小图片"></a>base64编码内联小图片</h4><h4 id="cdn加速"><a href="#cdn加速" class="headerlink" title="cdn加速"></a>cdn加速</h4>]]></content>
      
      
      <categories>
          
          <category> Optimize </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Optimize </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP缓存</title>
      <link href="/2020/01/10/Interview/02/"/>
      <url>/2020/01/10/Interview/02/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h1><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>HTTP报文：作为浏览器和服务器通讯时发送和响应的数据块。浏览器向服务器发送数据时会发送请求报文（Request），服务器响应浏览器的请求时，会发送响应报文（Response）。</p><p>请求报文：包含请求方法、统一资源定位符（URL）、协议版本号、MIME信息等。</p><p>响应报文：包含协议版本号、响应状态码等信息。</p><h3 id="缓存规则解析"><a href="#缓存规则解析" class="headerlink" title="缓存规则解析"></a>缓存规则解析</h3><p>当用户第一次访问页面的时候，浏览器的缓存数据库是没有缓存的，需要向服务器直接请求数据，服务器将会把资源和缓存规则返回给浏览器，浏览器将把资源和缓存规则进行缓存。具体如图所示:</p><p><img src="http://cdn.yangkunxiao.cn/HttpCache2.png#alt=http-cache1" alt=""></p><h4 id="强缓存-from-disk-cache-200"><a href="#强缓存-from-disk-cache-200" class="headerlink" title="强缓存(from disk cache 200)"></a>强缓存(from disk cache 200)</h4><p>已存在缓存时，请求资源流程如下：</p><p><img src="http://cdn.yangkunxiao.cn/http-strong-cache.png#alt=http-strong-cache" alt=""></p><p>从中可以看出，强缓存如果缓存数据库中已存在数据且未失效，那么将不会和服务器进行交互，直接从资源数据库中取。</p><p>对于强缓存来说，响应头将会有两个字端来标识失效规则：<code>Expires/Cache-Control</code>。</p><p>Expires：Http1.0。它的值为服务端返回的到期时间。即下一次请求时的时间小于该时间的时候，直接使用缓存数据。</p><p>Cache-Control：Http1.1 。Cache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。</p><p><code>private</code>：客户端可以缓存。</p><p><code>public</code>： 客户端和代理服务器都可缓存。</p><p><code>max-age=xxx</code>：缓存的内容将在 xxx 秒后失效。</p><p><code>no-cache</code>：需要使用对比缓存来验证缓存数据。</p><p><code>no-store</code>：所有内容都不会缓存，强制缓存，对比缓存都不会触发。</p><h4 id="对比缓存-304"><a href="#对比缓存-304" class="headerlink" title="对比缓存(304)"></a>对比缓存(304)</h4><p>已存在缓存数据时，请求资源的流程：</p><p><img src="http://cdn.yangkunxiao.cn/http-negotiate-cache.png#alt=http--cache" alt=""></p><p>对比缓存，顾名思义，需要进行比较判断是否可以使用缓存。</p><p>浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。</p><p>再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。</p><p>在对比缓存生效时，状态码为304，并且报文大小和请求时间大大减少。</p><p>原因是，服务端在进行标识比较后，只返回header部分，通过状态码通知客户端使用缓存，不再需要将报文主体部分返回给客户端。</p><p><code>If-Modified-Since/Last-Modified</code>:Http1.0 。浏览器在访问服务器的时候，服务器返回的响应报头中会携带<code>Last-Modified</code>字端，告诉浏览器文件最后修改的时间。当浏览器在此访问服务器的时候，会携带<code>If-Modified-Since</code>，告诉服务器上次文件修改的时间，服务器收到该字段之后，和服务器文件资源的最后修改时间做对比，判断资源是否有改动。若改动过，则返回200，并将整个资源返回。若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。<code>Last-Modified</code>，顾名思义，指的是文件最后的修改时间，而且只能精确到<code>1s</code>以内</p><p><code>If-None-Match/E-tag</code>：Http1.1 。服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于<code>FileEtag INode Mtime Size</code>生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。</p><p><img src="http://cdn.yangkunxiao.cn/HttpCache3.png#alt=http-cache" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>块级作用域的函数声明和函数声明</title>
      <link href="/2020/01/04/JavaScript/block-scope/"/>
      <url>/2020/01/04/JavaScript/block-scope/</url>
      
        <content type="html"><![CDATA[<h1 id="块级作用域的变量声明和函数声明"><a href="#块级作用域的变量声明和函数声明" class="headerlink" title="块级作用域的变量声明和函数声明"></a>块级作用域的变量声明和函数声明</h1><p>最近在一个讨论群看到一个面试题：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>  a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//10</span></code></pre><p>what？不应该是：function a(){} 、function a(){} 吗？</p><p>最后一位牛人给出了他的理解，这里本人只是作出验证，加深理解。</p><blockquote><p>接下来的环境默认都是chrome环境，支持ES6。<br>下文提出的默认变量指的是没有使用 var、let、const定义的变量。</p></blockquote><h3 id="块级作用域的默认变量"><a href="#块级作用域的默认变量" class="headerlink" title="块级作用域的默认变量"></a>块级作用域的默认变量</h3><p>我们先看这样一个🌰：</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//ReferenceError: a is not defined</span><span class="token punctuation">{</span>    a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//10</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//10</span></code></pre><p>可能有些人会像我一样感到诧异：为什么第一个a打印出来的不是undefined？<code>a = 10</code>默认不是 <code>var a = 10</code>吗？应该会提升到全局作用域的顶端的啊。</p><p>那好，让我们把<code>window.a</code>打印出来看看：</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//undefined</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//undefined  、a is not defined</span>    a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//10 10</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//10 10</span></code></pre><p>结论：我们可以清晰的看到，在块级作用域中默认声明的变量，只有执行了声明代码，变量才会被挂载到全局作用域上。</p><p>让我们在看看使用<code>var</code>声明的变量的情况：</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//undefined  undefined</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//undefined  、undefined</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//10 10</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//10 10</span></code></pre><p>结论：对比上一个例子，我们可以得出，使用<code>var</code>声明的变量会在编译阶段被提升到全局作用域上，不过它只是将声明提升，赋值操作并未提升上去。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>在块级作用域中默认声明的变量，只有代码执行到声明语句之后，才可以进行访问，否则会报错。</li><li>块级作用域中默认声明的变量会被提升到全局作用域。</li></ul><h3 id="块级作用域的函数声明"><a href="#块级作用域的函数声明" class="headerlink" title="块级作用域的函数声明"></a>块级作用域的函数声明</h3><p>在块级作用域中的函数声明和变量是不同的。不多说，直接撸代码：</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//undefined</span><span class="token punctuation">{</span>    <span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>回到第一个例子，如果块级作用域里面是一个默认变量，则第一行代码会直接报错，而函数声明则会打印<code>undefined</code>。</p><p>其实在阮一峰老师的<a href="">ECMAScript6入门</a>中关于这一点就做了明确说明：</p><p><img src="http://cdn.yangkunxiao.cn/qw7bBH.png#align=left&display=inline&height=528&originHeight=528&originWidth=1192&status=done&style=none&width=1192" alt=""></p><p>块级作用域函数，就像预先在全局作用域中使用<code>var</code>声明了一个变量，且默认值为<code>undefined</code>。</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//undefined undefined</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//undefined function a(){}</span>  <span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//function a(){} function a(){}</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//function a(){} function a(){}</span></code></pre><p>在这个例子中，第一行输出大概是比较符合预期的。至于第二行<code>window.a=undefoned</code>，而<code>a=function a(){}</code> ，上面在阮一峰老师的文章中说过，声明函数a会被提升到全局作用域，且在其块级作用域中，也会被提升到顶层。而<code>window.a</code>为什么会为<code>undefined</code>呢？因为只有<code>window.a</code>只有等块级作用域中函数声明的定义的那行代码执行过之后，才会被映射到全局作用域。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul><li>块级作用域函数在编译阶段将函数声明提升到全局作用域，并且会在全局声明一个变量，值为undefined。同时，也会被提升到对应的块级作用域顶层。</li><li>块级作用域函数只有定义声明函数的那行代码执行过后，才会被映射到全局作用域。</li></ul><h3 id="块级作用域中有同名的变量和函数声明"><a href="#块级作用域中有同名的变量和函数声明" class="headerlink" title="块级作用域中有同名的变量和函数声明"></a>块级作用域中有同名的变量和函数声明</h3><p>看🌰：</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//undefined undefined</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//undefined function a(){}</span>    <span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//function a(){}  10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//function a(){}  function a(){}</span></code></pre><p>在这里，首先，块级作用域函数a的声明会被提升到全局作用域，第一行打印比较符合预期。然后在块级作用域中，由于声明函数a提升到块级作用域顶端，所以打印<code>a = function a(){}</code>，而<code>window.a</code>由于并没有执行函数定义的那一行代码，所以仍然为<code>undefined</code>。当执行到声明函数定义的时候，就会把函数a映射到全局作用域中。当执行<code>a = 10</code>的时候，JS引擎会进行LHS查找，此时，声明函数已经被同时提升到全局作用域和块级作用域顶端了，由于<code>遮蔽效果</code>，此时查找a只会找到块级作用域内的a，并不会找到全局作用域的a，这时，a已经被定义，<code>a = 10</code>只会执行赋值操作，并不会进行提升。</p><p>我们再来看🌰2。它会更加抽象，准备好了没？</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//undefined undefined</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//undefined function a(){}</span>       a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//10  10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//10 10</span></code></pre><p>有了上面例子的铺垫，相信大家对前两行的打印结果不会有任何疑问了吧？</p><p>那好，我们直接进行下一步，执行<code>a = 10</code>，我们知道，此时，在块级作用域中函数声明已经被提升到顶层，那么此时执行a，就是相当于赋值，将函数声明a赋值为数字a，可以理解吗？如果有疑问，可以看🌰1。然后，执行到函数声明语句，此时，虽然这一行代码是函数声明语句，但是a，已经为数字10了，所以，执行<code>function a(){}</code>之后，a的值10就会被赋值给全局作用域上的a，所以下面打印的<code>window.a,a</code>都为10！！！</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul><li>块级作用域函数只有执行函数声明语句的时候，才会重写对应的全局作用域上的同名变量。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步编程</title>
      <link href="/2020/01/03/JavaScript/async/"/>
      <url>/2020/01/03/JavaScript/async/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript异步编程"><a href="#JavaScript异步编程" class="headerlink" title="JavaScript异步编程"></a>JavaScript异步编程</h1><p>JavaScript异步编程</p><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>Promise是异步编程的一种实现方式，它比传统的解决方案更加合适、强大。所谓Promise，就是一种容器，容器里面保存着未来才会发生的事情（一般是异步操作）的结果。</p><p>Promise是一个对象，它提供一系列的API可以将异步操作的事情以同步的形式表现出来，比起”回调地狱”，它看起来更加合适、强大。它具有以下几大特点：</p><ul><li><code>Promise</code>的状态不受任何外界的影响。Promise的异步操作有三种状态：    <code>pending</code>(执行中)、<code>fulfilled</code>(已成功)、<code>rejected</code>(已失败)。只有异步操作的结果才能够决定<code>Promise</code>状态的走向。</li><li><code>Promise</code>的状态一旦改变，变不可再次变动。它的状态变化只有两种情况：<code>pending</code> =&gt; <code>fulfilled</code>、<code>pengding</code> =&gt; <code>rejected</code>。状态一旦发生变化，就不再改变，称之为 <code>resolved</code>(已定型)。</li></ul><p>Promise一旦新建之后，就会立即执行。而then指定的回调函数只有同步操作执行完之后才会执行。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//成功回调</span>  <span class="token comment" spellcheck="true">//todo</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//失败回调</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//todo</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p><p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 <code>pending</code> 变为 <code>resolved</code>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 <code>pending</code> 变为 <code>rejected</code>），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。但是一般默认不指定<code>rejected</code>状态的回调函数，而是使用<code>catch</code>。</p><p><code>finally</code>不管<code>promise</code>最终的执行结果如何，都会执行。</p><p><code>all</code>：方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><p><code>Promise.all()</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例</p><p>举个🌰：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        msg<span class="token punctuation">:</span> <span class="token string">'p1'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        msg<span class="token punctuation">:</span> <span class="token string">'p2'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> p3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        msg<span class="token punctuation">:</span> <span class="token string">'p3'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">,</span>p3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">[</span>res1<span class="token punctuation">,</span>res2<span class="token punctuation">,</span>res3<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res1<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res2<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行结果：p1 p2 p3</span></code></pre><p><code>p</code>的状态由p1,p2,p3决定：</p><ul><li><p>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p></li><li><p>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p></li></ul><p><code>race</code>：该方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>只要只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p><p><code>allSettled</code>：该方法由<code>ES2020</code>引入。<code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束。</p><p><code>any</code>：<code>Promise.any()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。该方法目前是一个第三阶段的<a href="https://github.com/tc39/proposal-promise-any" target="_blank" rel="noopener">提案</a> 。</p><p><code>resolve</code>：<code>Promise.resolve()</code>将现有对象转为 Promise 对象。</p><ul><li><p>参数是一个<code>Promise</code>实例：那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p></li><li><p>参数是一个 <code>thenable</code> 实例：<code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。：</p></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> thenable <span class="token operator">=</span> <span class="token punctuation">{</span>  then<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><code>Promise.resolve</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then</code>方法。</p><ul><li>参数不是具有<code>then</code>方法的对象，或根本就不是对象：如果参数是一个原始值，或者是一个不具有<code>then</code>方法的对象，则<code>Promise.resolve</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Hello</span></code></pre><p><code>reject</code>：<code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p><h4 id="Generator-yield"><a href="#Generator-yield" class="headerlink" title="Generator/yield"></a>Generator/yield</h4><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p><p>Generator 函数有多种理解角度。语法上，Generator 函数是一个状态机，封装了多个内部状态。</p><p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个<code>遍历器对象生成函数</code>。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p><p>形式上，Generator 函数是一个普通函数，但是有两个特征:</p><p>1、<code>function</code>关键字与函数名之间有一个星号；</p><p>2、函数体内部使用<code>yield</code>表达式，定义不同的内部状态</p><blockquote><p>Generator 函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行。</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">helloWorldGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">yield</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>  <span class="token keyword">yield</span> <span class="token string">'world'</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token string">'ending'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">let</span> hwg <span class="token operator">=</span> <span class="token function">helloWorldGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>hwg<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//{ value:hello,done:false }</span>hwg<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//{ value:world,done:false }</span>hwg<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//{ value:ending,done:true }</span>hwg<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//{ value:undefined,done:true }</span></code></pre><p>总结：调用Generator函数，会返回一个遍历器对象，它是函数内部的指针，以后每调用一次next函数，就会返回一个带有value和done属性的对象。<code>next</code>方法可以带一个参数，该参数就会被当作上一个<code>yield</code>表达式的返回值。<code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</p><p>Generator 函数返回的遍历器对象，还有一个<code>return</code>方法，可以返回给定的值，并且终结遍历 Generator 函数。</p><h4 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h4><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。它是Generator的语法糖。<code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>。</p><p><code>async</code>函数对 Generator 函数的改进，体现在以下几点。</p><ul><li>内置执行器。</li></ul><p>Generator 函数的执行必须靠执行器。而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。</p><ul><li>返回值是 Promise</li></ul><p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p><p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p><p><code>async</code>函数返回一个 Promise 对象。<code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。</p><p><code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</p><p>举个🌰：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">timeFn</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//Promise 新建后就会立即执行。</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        msg<span class="token punctuation">:</span><span class="token string">'hello'</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fun</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//Promise的写法</span>  <span class="token comment" spellcheck="true">// timeFn(time).then(res => {</span>  <span class="token comment" spellcheck="true">//     console.log(res);</span>  <span class="token comment" spellcheck="true">// })</span>  <span class="token comment" spellcheck="true">//async await的写法</span>  <span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">timeFn</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span></code></pre><p>程序会在3s之后打印{msg:’hello’}</p><p><code>await</code>：正常情况下，<code>await</code>命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义<code>then</code>方法的对象），那么<code>await</code>会将其等同于 Promise 对象。</p><p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 Promise 对象被<code>reject</code>。</p><p><code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</p><p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 等同于</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//spawn 自动执行器</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript块级作用域的默认变量和声明函数</title>
      <link href="/2020/01/03/JavaScript/block-scope-function/"/>
      <url>/2020/01/03/JavaScript/block-scope-function/</url>
      
        <content type="html"><![CDATA[<h1 id="块级作用域的变量声明和函数声明"><a href="#块级作用域的变量声明和函数声明" class="headerlink" title="块级作用域的变量声明和函数声明"></a>块级作用域的变量声明和函数声明</h1><p>最近在一个讨论群看到一个面试题：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>  a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//10</span></code></pre><p>what？不应该是：function a(){} 、function a(){} 吗？</p><p>最后一位牛人给出了他的理解，这里本人只是作出验证，加深理解。</p><blockquote><p>接下来的环境默认都是chrome环境，支持ES6。</p><p>下文提出的默认变量指的是没有使用 var、let、const定义的变量。</p></blockquote><h3 id="块级作用域的默认变量"><a href="#块级作用域的默认变量" class="headerlink" title="块级作用域的默认变量"></a>块级作用域的默认变量</h3><p>我们先看这样一个🌰：</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//ReferenceError: a is not defined</span><span class="token punctuation">{</span>    a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//10</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//10</span></code></pre><p>可能有些人会像我一样感到诧异：为什么第一个a打印出来的不是undefined？<code>a = 10</code>默认不是 <code>var a = 10</code>吗？应该会提升到全局作用域的顶端的啊。</p><p>那好，让我们把<code>window.a</code>打印出来看看：</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//undefined</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//undefined  、a is not defined</span>    a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//10 10</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//10 10</span></code></pre><p>结论：我们可以清晰的看到，在块级作用域中默认声明的变量，只有执行了声明代码，变量才会被挂载到全局作用域上。</p><p>让我们在看看使用<code>var</code>声明的变量的情况：</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//undefined  undefined</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//undefined  、undefined</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//10 10</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//10 10</span></code></pre><p>结论：对比上一个例子，我们可以得出，使用<code>var</code>声明的变量会在编译阶段被提升到全局作用域上，不过它只是将声明提升，赋值操作并未提升上去。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>在块级作用域中默认声明的变量，只有代码执行到声明语句之后，才可以进行访问，否则会报错。</li><li>块级作用域中默认声明的变量会被提升到全局作用域。</li></ul><h3 id="块级作用域的函数声明"><a href="#块级作用域的函数声明" class="headerlink" title="块级作用域的函数声明"></a>块级作用域的函数声明</h3><p>在块级作用域中的函数声明和变量是不同的。不多说，直接撸代码：</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//undefined</span><span class="token punctuation">{</span>    <span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>回到第一个例子，如果块级作用域里面是一个默认变量，则第一行代码会直接报错，而函数声明则会打印<code>undefined</code>。</p><p>其实在阮一峰老师的<a href="[http://es6.ruanyifeng.com/#docs/let#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F](http://es6.ruanyifeng.com/#docs/let#块级作用域)">ECMAScript6入门</a>中关于这一点就做了明确说明：</p><p><img src="http://cdn.yangkunxiao.cn/qw7bBH.png" alt=""></p><p>块级作用域函数，就像预先在全局作用域中使用<code>var</code>声明了一个变量，且默认值为<code>undefined</code>。</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//undefined undefined</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//undefined function a(){}</span>  <span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//function a(){} function a(){}</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//function a(){} function a(){}</span></code></pre><p>在这个例子中，第一行输出大概是比较符合预期的。至于第二行<code>window.a=undefoned</code>，而<code>a=function a(){}</code> ，上面在阮一峰老师的文章中说过，声明函数a会被提升到全局作用域，且在其块级作用域中，也会被提升到顶层。而<code>window.a</code>为什么会为<code>undefined</code>呢？因为只有<code>window.a</code>只有等块级作用域中函数声明的定义的那行代码执行过之后，才会被映射到全局作用域。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul><li>块级作用域函数在编译阶段将函数声明提升到全局作用域，并且会在全局声明一个变量，值为undefined。同时，也会被提升到对应的块级作用域顶层。</li><li>块级作用域函数只有定义声明函数的那行代码执行过后，才会被映射到全局作用域。</li></ul><h3 id="块级作用域中有同名的变量和函数声明"><a href="#块级作用域中有同名的变量和函数声明" class="headerlink" title="块级作用域中有同名的变量和函数声明"></a>块级作用域中有同名的变量和函数声明</h3><p>看🌰：</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//undefined undefined</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//undefined function a(){}</span>    <span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//function a(){}  10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//function a(){}  function a(){}</span></code></pre><p>在这里，首先，块级作用域函数a的声明会被提升到全局作用域，第一行打印比较符合预期。然后在块级作用域中，由于声明函数a提升到块级作用域顶端，所以打印<code>a = function a(){}</code>，而<code>window.a</code>由于并没有执行函数定义的那一行代码，所以仍然为<code>undefined</code>。当执行到声明函数定义的时候，就会把函数a映射到全局作用域中。当执行<code>a = 10</code>的时候，JS引擎会进行LHS查找，此时，声明函数已经被同时提升到全局作用域和块级作用域顶端了，由于<code>遮蔽效果</code>，此时查找a只会找到块级作用域内的a，并不会找到全局作用域的a，这时，a已经被定义，<code>a = 10</code>只会执行赋值操作，并不会进行提升。</p><p>我们再来看🌰2。它会更加抽象，准备好了没？</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//undefined undefined</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//undefined function a(){}</span>       a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//10  10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//10 10</span></code></pre><p>有了上面例子的铺垫，相信大家对前两行的打印结果不会有任何疑问了吧？</p><p>那好，我们直接进行下一步，执行<code>a = 10</code>，我们知道，此时，在块级作用域中函数声明已经被提升到顶层，那么此时执行a，就是相当于赋值，将函数声明a赋值为数字a，可以理解吗？如果有疑问，可以看🌰1。然后，执行到函数声明语句，此时，虽然这一行代码是函数声明语句，但是a，已经为数字10了，所以，执行<code>function a(){}</code>之后，a的值10就会被赋值给全局作用域上的a，所以下面打印的<code>window.a,a</code>都为10！！！</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul><li>块级作用域函数只有执行函数声明语句的时候，才会重写对应的全局作用域上的同名变量。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈JS变量提升(2020新年第一更)</title>
      <link href="/2020/01/01/JavaScript/variableHoisting/"/>
      <url>/2020/01/01/JavaScript/variableHoisting/</url>
      
        <content type="html"><![CDATA[<h1 id="浅谈JS变量提升（2020新年第一章）"><a href="#浅谈JS变量提升（2020新年第一章）" class="headerlink" title="浅谈JS变量提升（2020新年第一章）"></a>浅谈JS变量提升（2020新年第一章）</h1><p>首先，先丢出来一道题：</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果我们不了解JavaScript中的变量提升和函数声明提升，那我们的答案可能就是这样的：</p><pre class=" language-javascript"><code class="language-javascript">undefinedReferenceError<span class="token punctuation">:</span> b is not defined<span class="token operator">...</span></code></pre><p>那么正确的答案是什么呢？我们首先把这段代码还原：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>好了，这下看一看执行结果是什么呢？</p><pre class=" language-javascript"><code class="language-javascript"><span class="token string">"function"</span><span class="token string">"function"</span><span class="token string">"number"</span><span class="token string">"a is not a function"</span></code></pre><h2 id="为什么会发生提升？"><a href="#为什么会发生提升？" class="headerlink" title="为什么会发生提升？"></a>为什么会发生提升？</h2><p>首先我们需要知道一点编译原理的知识。JavaScript的源代码在运行的时候，会经过两个阶段：编译和执行。而且，编译阶段往往就在执行阶段的前几微秒甚至更短的时间内。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><h4 id="词法解析"><a href="#词法解析" class="headerlink" title="词法解析"></a>词法解析</h4><p>这个阶段会先把字符组成的字符串解析成一个个有意义的代码块，这些代码块也被称为词法单元。如 <code>var a = 1;</code> 会被解析成： <code>var 、a、=、1、;</code> ，空格是否会被解析成词法单元，就要看空格在这个语言中有意义。</p><h4 id="语法解析"><a href="#语法解析" class="headerlink" title="语法解析"></a>语法解析</h4><p>这个阶段会把词法解析生成的词法单元流解析成有元素逐级嵌套所组成的程序语法树，AST。至于AST的结构是如何构成的，这里有几个网站，大家可以去试试: <a href="https://esprima.org/demo/parse.html#" target="_blank" rel="noopener">网站1</a>、<a href="https://resources.jointjs.com/demos/javascript-ast" target="_blank" rel="noopener">网站2</a>。</p><h4 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h4><p>这个阶段就是将语法解析阶段生成的AST转译成可执行的代码。</p><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><h4 id="LHS查询"><a href="#LHS查询" class="headerlink" title="LHS查询"></a>LHS查询</h4><p>在编译的过程中，先将标识符和函数声明给提升到其对应的作用域的顶端。标识符解析的时候，会进行LHS查询，在LHS查询的时候，如果标识符一直找不到声明的位置，那么最终就会在全局环境生成一个全局变量。</p><blockquote><p>LHS ： 指的是赋值操作的左端。<br>标识符解析：请查看我的另外一篇文章。</p></blockquote><h4 id="RHS查询"><a href="#RHS查询" class="headerlink" title="RHS查询"></a>RHS查询</h4><p>说到LHS查询，就不得不提对应的RHS查询，相信大家已经看出RHS的意思了把，它指的是赋值操作的源头。RHS查询的时候，如果找不到对应的标识符，就会抛出一个异常：ReferenceError。</p><h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><p>函数提升和变量提升还有点不一样。函数提升，只会提升函数声明，而不会提升函数表达式。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//fn is not a function </span><span class="token comment" spellcheck="true">//函数表达式</span><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//函数声明</span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>这里我把代码还原，我们来看一下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//函数声明</span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">var</span> fn<span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>这下明白为什么执行函数fn的时候，会报错了吧。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>现在，大家是不是对变量和函数声明的提升机制已经有一定的了解了？那么让我们在深度实战一下。</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>        f <span class="token operator">=</span> a<span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"yideng1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在非严格模式下，代码块中，只有使用 <code>var</code> 声明的变量和函数声明是可以提升的，但是函数声明只能将函数的名字提升出去。 </p><pre class=" language-javascript"><code class="language-javascript"><span class="token string">"undefined"</span><span class="token string">"undefined"</span><span class="token string">"function"</span></code></pre><p>在严格模式下：代码块中，只有使用 <code>var</code> 声明的变量可以提升出去。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token string">"undefined"</span><span class="token string">"f is not defined "</span></code></pre><p>再来看一个题：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//function</span>    <span class="token comment" spellcheck="true">// var f = 3;</span>    f <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//number</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//function</span>    <span class="token comment" spellcheck="true">// var s = 3;</span>    s <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//function </span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上述代码中，函数f是具名函数，函数s是函数表达式。具名函数中，可以在函数内部改变函数名，而函数表达式，如果有函数名，则它的函数名只能作用在其自身作用域中，且不可改变改变函数名。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS变量提升</title>
      <link href="/2020/01/01/JavaScript/variable-hoisting/"/>
      <url>/2020/01/01/JavaScript/variable-hoisting/</url>
      
        <content type="html"><![CDATA[<h1 id="浅谈JS变量提升（2020新年第一章）"><a href="#浅谈JS变量提升（2020新年第一章）" class="headerlink" title="浅谈JS变量提升（2020新年第一章）"></a>浅谈JS变量提升（2020新年第一章）</h1><p>首先，先丢出来一道题：</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果我们不了解JavaScript中的变量提升和函数声明提升，那我们的答案可能就是这样的：</p><pre class=" language-javascript"><code class="language-javascript">undefinedReferenceError<span class="token punctuation">:</span> b is not defined<span class="token operator">...</span></code></pre><p>那么正确的答案是什么呢？我们首先把这段代码还原：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>好了，这下看一看执行结果是什么呢？</p><pre class=" language-javascript"><code class="language-javascript"><span class="token string">"function"</span><span class="token string">"function"</span><span class="token string">"number"</span><span class="token string">"a is not a function"</span></code></pre><h2 id="为什么会发生提升？"><a href="#为什么会发生提升？" class="headerlink" title="为什么会发生提升？"></a>为什么会发生提升？</h2><p>首先我们需要知道一点编译原理的知识。JavaScript的源代码在运行的时候，会经过两个阶段：编译和执行。而且，编译阶段往往就在执行阶段的前几微秒甚至更短的时间内。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><h4 id="词法解析"><a href="#词法解析" class="headerlink" title="词法解析"></a>词法解析</h4><p>这个阶段会先把字符组成的字符串解析成一个个有意义的代码块，这些代码块也被称为词法单元。如 <code>var a = 1;</code> 会被解析成： <code>var 、a、=、1、;</code> ，空格是否会被解析成词法单元，就要看空格在这个语言中有意义。</p><h4 id="语法解析"><a href="#语法解析" class="headerlink" title="语法解析"></a>语法解析</h4><p>这个阶段会把词法解析生成的词法单元流解析成有元素逐级嵌套所组成的程序语法树，AST。至于AST的结构是如何构成的，这里有几个网站，大家可以去试试: <a href="https://esprima.org/demo/parse.html#" target="_blank" rel="noopener">网站1</a>、<a href="https://resources.jointjs.com/demos/javascript-ast" target="_blank" rel="noopener">网站2</a>。</p><h4 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h4><p>这个阶段就是将语法解析阶段生成的AST转译成可执行的代码。</p><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><h4 id="LHS查询"><a href="#LHS查询" class="headerlink" title="LHS查询"></a>LHS查询</h4><p>在编译的过程中，先将标识符和函数声明给提升到其对应的作用域的顶端。标识符解析的时候，会进行LHS查询，在LHS查询的时候，如果标识符一直找不到声明的位置，那么最终就会在全局环境生成一个全局变量。</p><blockquote><p>LHS ： 指的是赋值操作的左端。<br>标识符解析：请查看我的另外一篇文章。</p></blockquote><h4 id="RHS查询"><a href="#RHS查询" class="headerlink" title="RHS查询"></a>RHS查询</h4><p>说到LHS查询，就不得不提对应的RHS查询，相信大家已经看出RHS的意思了把，它指的是赋值操作的源头。RHS查询的时候，如果找不到对应的标识符，就会抛出一个异常：ReferenceError。</p><h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><p>函数提升和变量提升还有点不一样。函数提升，只会提升函数声明，而不会提升函数表达式。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//fn is not a function </span><span class="token comment" spellcheck="true">//函数表达式</span><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//函数声明</span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>这里我把代码还原，我们来看一下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//函数声明</span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">var</span> fn<span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>这下明白为什么执行函数fn的时候，会报错了吧。</p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>块级作用域是在ES6中提出的一个概念，ES5中是没有块级作用域的，只有全局作用域和函数作用域。<br>我们还是先看个案例：</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//undefined</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//undefined</span><span class="token keyword">var</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>        yideng <span class="token operator">=</span> a<span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"yideng1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//undefined</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//function</span></code></pre><p>还是把这段代码还原一下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a<span class="token punctuation">,</span>flag<span class="token punctuation">,</span>fn<span class="token punctuation">;</span><span class="token operator">...</span><span class="token operator">...</span></code></pre><p>或许有人会问：为什么a和函数fn会被提到最顶端？变量a和函数fn都是在块级作用域中，其中a是通过var进行声明的，函数fn是一个函数声明。而非严格模式下，块级作用域是阻挡不了var声明的变量和函数声明的提升的。但是，声明函数。<br>更进一步</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>    a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//5 5</span>    a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//5 0</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//5 5</span></code></pre><p>大家看到这个答案是不是很疑惑？当我第一次看到这个答案的时候，内心也是一万个🦙奔腾而过。<br>我们上面说过，块级作用域中，只有var声明的变量和函数声明可以直接提到全局作用域。块级作用域中的不实用var声明的变量，也会提升到全局作用域，但是只有在块级作用域中运行之后，才会反射到全局作用域上。<br>而且块级作用域和函数作用域完全不同：函数作用域会在执行完毕之后，重写window。而块级作用域之后进行一次有意义的重写。所谓有意义的重写，就是在外层作用域没有声明和赋值。<br>在块级作用域中，函数声明会提升到当前作用域顶层，至于会不会重写外层变量，那就要看是否有实际意义。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>现在，大家是不是对变量和函数的提升机制已经有一定的了解了？那么让我们在深度实战一下。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//'use strict'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>        f <span class="token operator">=</span> a<span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"yideng1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在ES6非严格模式下，代码块中，只有使用 <code>var</code> 声明的变量和函数声明是可以提升的，但是函数声明只能将函数的名字提升出去。<br>ES5非严格模式下，各个浏览器表现不一样。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token string">"undefined"</span><span class="token string">"undefined"</span><span class="token string">"function"</span></code></pre><p>在ES6严格模式下：代码块中，只有使用 <code>var</code> 声明的变量可以提升出去。<br>ES5严格模式下，直接报错。因为ES5函数不允许在块级作用域中声明函数。函数的声明只能在函数作用域或者顶级作用域中。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token string">"undefined"</span><span class="token string">"ReferenceError:f is not defined "</span><span class="token comment" spellcheck="true">//报错</span></code></pre><p>再来看一个题：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//function</span>    <span class="token comment" spellcheck="true">// var f = 3;</span>    f <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//number</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//function</span>    <span class="token comment" spellcheck="true">// var s = 3;</span>    s <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//function </span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上述代码中，函数f是具名函数，函数s是函数表达式。具名函数中，可以在函数内部改变函数名，而函数表达式，如果有函数名，则它的函数名只能作用在其自身作用域中，且不可改变改变函数名。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web Worker(2019最后一更)</title>
      <link href="/2019/12/31/JavaScript/webWorker/"/>
      <url>/2019/12/31/JavaScript/webWorker/</url>
      
        <content type="html"><![CDATA[<h1 id="web-Worker的使用"><a href="#web-Worker的使用" class="headerlink" title="web Worker的使用"></a>web Worker的使用</h1><h2 id="web-Worker"><a href="#web-Worker" class="headerlink" title="web Worker"></a>web Worker</h2><h3 id="什么是web-Worker"><a href="#什么是web-Worker" class="headerlink" title="什么是web Worker"></a>什么是web Worker</h3><p>JavaScript是单线程的。所有的任务只能在同一个线程中进行，一次只能执行一个任务，后面的只能等待。而且现在计算机大多都是多核的，单线程不能有效的利用计算机的资源。<br />web Worker是HTML5 提出的JavaScript多线程解决方案。我们可以将一些大计算量的操作交给web worker去运算，而不必“冻结”页面。</p><h3 id="web-Worker的作用"><a href="#web-Worker的作用" class="headerlink" title="web Worker的作用"></a>web Worker的作用</h3><p>为JavaScript创建多线程。允许主线程创建子线程，将主线程的复杂的任务分配给子线程去执行。在主线程运行的同时，子线程也在后台执行，二者互不影响。等子线程处理完成之后，再将结果传递给主线程。这样，子线程分担了主线程的负载，让主线程的运行“顺畅”起来，不会被阻塞。</p><h3 id="web-Worker的使用限制"><a href="#web-Worker的使用限制" class="headerlink" title="web Worker的使用限制"></a>web Worker的使用限制</h3><ul><li>同源限制。分配的worker线程的脚本文件，必须和主线程同源。</li><li>DOM限制。worker线程所在的脚本文件，无法读取主线程所在的网页的DOM对象。但是可以使用 <code>location</code> 和 <code>navigator</code> 对象。</li><li>主线程和子线程通讯。主线程和worker线程不在同一个上下文对象，所以必须使用消息进行通讯。</li><li>脚本限制。worker线程中不允许使用 <code>alert</code> 和 <code>confirm</code> 。但是可以使用 <code>XMLHttpRequest</code> 对象。</li><li>文件限制。worker线程不能读取本地文件，它所加载的脚本文件，必须来源于网络。</li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><p>主线程新建worker线程：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//new Worker(jsUrl, options);</span><span class="token keyword">let</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token string">'child.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>Worker</code> 构造函数的参数是一个脚本文件，该脚本文件就是要Worker线程的脚本文件。该文件必须来自网络，否则则会失败。Worker接收第二个参数，该参数是对象形式，它的一个作用就是指定Worker的名称。</p><h4 id="主线程和子线程通讯"><a href="#主线程和子线程通讯" class="headerlink" title="主线程和子线程通讯"></a>主线程和子线程通讯</h4><p>主线程调用 <code>worker.postMessage()</code> 方法，向子线程传递数据。</p><pre class=" language-javascript"><code class="language-javascript">worker<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">'准备好了吗？开始通信!'</span><span class="token punctuation">)</span>；<span class="token comment" spellcheck="true">//or</span>worker<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  type<span class="token punctuation">:</span> <span class="token string">'common'</span><span class="token punctuation">,</span>  message<span class="token punctuation">:</span> <span class="token string">"准备好了吗？开始通信!"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="主线程指定监听事件"><a href="#主线程指定监听事件" class="headerlink" title="主线程指定监听事件"></a>主线程指定监听事件</h4><p>主线程使用 <code>worker.onmessage()</code> 方法，监听从子线程发送的数据：</p><pre class=" language-javascript"><code class="language-javascript">worker<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'主线程收到子线程发的消息！！！'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>主线程中可以监听worker是否发生错误。如果发生错误，worker就会触发主线程的 <code>onerror</code> 方法。</p><pre class=" language-javascript"><code class="language-javascript">worker<span class="token punctuation">.</span>onerror <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//e.lineno ：错误代码的行数</span>  <span class="token comment" spellcheck="true">//e.filename ：发生错误的文件</span>  <span class="token comment" spellcheck="true">//e.message ：错误详细信息</span><span class="token punctuation">}</span></code></pre><h4 id="终止执行"><a href="#终止执行" class="headerlink" title="终止执行"></a>终止执行</h4><p>当任务完成以后，主线程可以通过 <code>worker.terminate()</code> 方法，终止worker的执行。</p><pre class=" language-javascript"><code class="language-javascript">worker<span class="token punctuation">.</span><span class="token function">terminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="worker线程"><a href="#worker线程" class="headerlink" title="worker线程"></a>worker线程</h3><h4 id="worker监听函数"><a href="#worker监听函数" class="headerlink" title="worker监听函数"></a>worker监听函数</h4><p>在worker中，使用监听函数，来获取主线程发送的数据：</p><pre class=" language-javascript"><code class="language-javascript">self<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`子线程接收消息：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>e<span class="token punctuation">.</span>data<span class="token punctuation">.</span>message<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>    self<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`我收到你发的消息了! 你发的消息是：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>e<span class="token punctuation">.</span>data<span class="token punctuation">.</span>message<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>上述代码中， <code>self</code> 代表子线程自身，即子线程的全局对象。</p><h4 id="worker线程加载脚本"><a href="#worker线程加载脚本" class="headerlink" title="worker线程加载脚本"></a>worker线程加载脚本</h4><p>如果我们在worker中需要引入其他脚本文件的时候，可以使用 <code>importScripts()</code>  方法导入。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">importScripts</span><span class="token punctuation">(</span><span class="token string">'underscore.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>导入之后，就可以在worker线程中使用了。</p><h4 id="关闭worker"><a href="#关闭worker" class="headerlink" title="关闭worker"></a>关闭worker</h4><p>当worker执行完毕之后，可以将其关闭：</p><pre class=" language-javascript"><code class="language-javascript">self<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础</title>
      <link href="/2019/12/24/Webpack/01/"/>
      <url>/2019/12/24/Webpack/01/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack4-0-一-：基础"><a href="#webpack4-0-一-：基础" class="headerlink" title="webpack4.0(一)：基础"></a>webpack4.0(一)：基础</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="context"><a href="#context" class="headerlink" title="context"></a>context</h4><p>基础目录，绝对路径，用户设置从配置文件中解析入口文件和加载器。<br>如：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    context<span class="token punctuation">:</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span>'js<span class="token punctuation">)</span><span class="token punctuation">,</span>  entry<span class="token punctuation">:</span><span class="token string">'./main.js'</span><span class="token punctuation">}</span></code></pre><p>等同于：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  entry<span class="token punctuation">:</span>'<span class="token punctuation">.</span><span class="token operator">/</span>js<span class="token operator">/</span>main<span class="token punctuation">.</span>js<span class="token punctuation">}</span></code></pre><p>context配置可以不要，默认为当前目录下查找。但是如果要使用的话，建议添加第二个参数，用于告诉webpack是从当前目录下哪个文件夹中查找。</p><h4 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h4><p>webpack中有多种定义入口的形式。</p><h5 id="单入口写法"><a href="#单入口写法" class="headerlink" title="单入口写法"></a>单入口写法</h5><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> config <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span><span class="token string">'./src/main.js'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> config<span class="token punctuation">;</span></code></pre><h5 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h5><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> config <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span><span class="token punctuation">{</span>    main<span class="token punctuation">:</span><span class="token string">'./src/main.js'</span><span class="token punctuation">,</span>    venders<span class="token punctuation">:</span><span class="token string">'./src/venders.js'</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> config<span class="token punctuation">;</span></code></pre><h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><p>配置<code>output</code>可以指定webpack如何向硬盘中写入，注意的是：webpack可以配置多个入口文件，但是只有一个输出配置。</p><p>在webpack中，output最低的配置要求就是：</p><ul><li>filename：用于指定输出的文件名</li><li>path：用于指定输出文件的路径</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> path <span class="token keyword">from</span> <span class="token string">'path'</span><span class="token punctuation">;</span><span class="token keyword">const</span> config <span class="token operator">=</span> <span class="token punctuation">{</span>  output<span class="token punctuation">:</span><span class="token punctuation">{</span>    filename<span class="token punctuation">:</span><span class="token string">'[name].js'</span><span class="token punctuation">,</span>    path<span class="token punctuation">:</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">'dist'</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> config<span class="token punctuation">;</span></code></pre><h4 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h4><p><code>mode</code>模块用于告诉webpack使用相应的模式进行优化。</p><ul><li>development：开发环境。会将 <code>process.env.NODE_ENV</code> 的值设为 <code>development</code>。启用 <code>NamedChunksPlugin</code> 和 <code>NamedModulesPlugin</code>。</li><li>production：生产环境。会将 <code>process.env.NODE_ENV</code> 的值设为 <code>production</code>。启用 <code>FlagDependencyUsagePlugin</code>, <code>FlagIncludedChunksPlugin</code>, <code>ModuleConcatenationPlugin</code>, <code>NoEmitOnErrorsPlugin</code>, <code>OccurrenceOrderPlugin</code>, <code>SideEffectsFlagPlugin</code> 和 <code>UglifyJsPlugin</code>。</li></ul><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  mode<span class="token punctuation">:</span> <span class="token string">'production'</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h4 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h4><p>我们都知道webpack可以对资源进行打包的。但是webpack只能处理js模块，对于其他模块的处理，就需要用loader对模块的源代码进行转换。loader可以使你在import或者“加载”模块的时候，进行预编译。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 <code>import</code> CSS文件！</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  module<span class="token punctuation">:</span><span class="token punctuation">{</span>    rules<span class="token punctuation">:</span><span class="token punctuation">[</span>      <span class="token punctuation">{</span>        test<span class="token punctuation">:</span><span class="token regex">/\.css$/</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'style-loader'</span><span class="token punctuation">,</span><span class="token string">'css-loader'</span><span class="token punctuation">]</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="编写一个loader"><a href="#编写一个loader" class="headerlink" title="编写一个loader"></a>编写一个loader</h5><p>loader工具库：<code>loader-utils</code>、配合<code>schema-utils</code>，</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> getOptions <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'loader-utils'</span><span class="token punctuation">;</span><span class="token keyword">import</span> validateOptions <span class="token keyword">from</span> <span class="token string">'schema-utils'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//loader的API请参考：https://webpack.docschina.org/api/loaders/</span></code></pre><p>所谓 loader 只是一个导出为函数的 JavaScript 模块。</p><ul><li>新建一个js文件：</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//loader-utils 它提供了许多有用的工具，但最常用的一种工具是获取传递给 loader 的选项</span><span class="token keyword">const</span> loadersUtils <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'loader-utils'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这是最简单的一个loader</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//content是文件内容</span>  <span class="token keyword">const</span> options <span class="token operator">=</span> loadersUtils<span class="token punctuation">.</span><span class="token function">getOptions</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> <span class="token string">'--------content'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>options<span class="token punctuation">,</span> <span class="token string">'--------options'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//同步loader</span>    <span class="token comment" spellcheck="true">// return '{};' + content</span>    <span class="token comment" spellcheck="true">/**     * this.callback() 参数：     * error:Error | null，当loader出错时向外跑出一个Error     * content:经过loader处理过的内容     * sourceMap：为方便调试生成的编译后内容的source map     * ast：本次编译生成的AST静态语法树，之后执行的loader可以直接使用这个AST，可以省去重复生成AST的过程     *      */</span>    <span class="token comment" spellcheck="true">// this.callback(null, '{};' + content)</span>   <span class="token comment" spellcheck="true">//异步 使用promise</span>    <span class="token keyword">function</span> <span class="token function">timeout</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token function">resolve</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> time<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// let data = await timeout(1000);</span>    <span class="token comment" spellcheck="true">// return data</span>    <span class="token keyword">const</span> callback <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">async</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">timeout</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">callback</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><ul><li>在<code>webpack.config.js</code>中使用该loader：</li></ul><pre class=" language-javascript"><code class="language-javascript">rules<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>  test<span class="token punctuation">:</span> <span class="token regex">/\.js$/</span><span class="token punctuation">,</span>  exclude<span class="token punctuation">:</span> <span class="token regex">/node_modules/</span><span class="token punctuation">,</span>  use<span class="token punctuation">:</span> <span class="token punctuation">{</span>    loader<span class="token punctuation">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'./loaders/index.js'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    options<span class="token punctuation">:</span> <span class="token punctuation">{</span>        test<span class="token punctuation">:</span> <span class="token number">1</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><ul><li>如果有多个loader，可以在<code>webpack.config.js</code>中这样配置：</li></ul><pre><code>resolveLoader:{    modules:[        &#39;node_modules&#39;,        path.resolve(__dirname,&#39;loaders&#39;)//loaders代表你存放loaders的文件夹    ]}</code></pre><h4 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h4><p><img src="http://cdn.yangkunxiao.cn/sZosgl.jpg#align=left&display=inline&height=1610&originHeight=1610&originWidth=1150&status=done&style=none&width=1150" alt=""></p><p>webpack事件流：</p><ul><li>首先，<code>webpack</code>会读取你在命令行和<code>webpack.config.js</code>的配置，初始化本次构建的参数，并且执行配置中的插件实例化，生产<code>compiler</code>传入<code>apply</code>方法中，为<code>webpack事件流</code>挂上自定义钩子。</li><li>接下来到了解析入口文件阶段，<code>webpack</code>会根据<code>entry</code>依次读取入口文件。</li><li><code>webpack</code>开始编译(<code>conpilation</code>)，对于每一个入口文件，都会先根据用户自定义的<code>loader</code>对文件内容进行编译(<code>buildModule</code>)，我们可以从传入事件回调的<code>compliation</code>上拿到<code>module</code>的<code>resource</code>、<code>loader</code>等信息。之后，再将编译好的文件内容使用<code>acorn</code>解析生成AST(静态语法树，<code>normalModuleLoader</code>)。分析文件的依赖关系，并依次拉取依赖模块，并重复以上过程。最后将require语法替换为<code>__webpack_require__</code>来模拟模块化操作。</li><li>emit阶段，所有文件的编译及转化都已经完成，包含了最终输出的资源，我们可以在传入事件回调的<code>compilation.assets</code> 上拿到所需数据，其中包括即将输出的资源、代码块<code>Chunk</code>等等信息。</li></ul><p>我们将webpack事件流理解为webpack构建过程中的一系列事件，他们分别表示着不同的构建周期和状态，我们可以像在浏览器上监听click事件一样监听事件流上的事件，并且为它们挂载事件回调。我们也可以自定义事件并在合适时机进行广播，这一切都是使用了webpack自带的模块 <code>Tapable</code> 进行管理的。我们不需要自行安装 <code>Tapable</code> ，在webpack被安装的同时它也会一并被安装，如需使用，我们只需要在文件里直接 <code>require</code> 即可。</p><p>Tapable的原理其实就是我们在前端进阶过程中都会经历的EventEmit，通过发布者-订阅者模式实现，它的部分核心代码可以概括成下面这样：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">SyncHook</span><span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>hooks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 订阅事件</span>    <span class="token function">tap</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>hooks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 发布</span>    <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>hooks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>hook <span class="token operator">=</span><span class="token operator">></span> <span class="token function">hook</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>具体请参考：<a href="https://juejin.im/post/5abf33f16fb9a028e46ec352" target="_blank" rel="noopener">https://juejin.im/post/5abf33f16fb9a028e46ec352</a></p><h4 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h4><p>resolve.alias 是通过别名来将原导入路径映射成一个新的导入路径。比如如下配置：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  entry<span class="token punctuation">:</span> <span class="token string">'./js/main.js'</span><span class="token punctuation">,</span>  output<span class="token punctuation">:</span> <span class="token punctuation">{</span>    filename<span class="token punctuation">:</span> <span class="token string">'bundle.js'</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 将输出的文件都放在dist目录下</span>    path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  resolve<span class="token punctuation">:</span> <span class="token punctuation">{</span>    alias<span class="token punctuation">:</span> <span class="token punctuation">{</span>      components<span class="token punctuation">:</span> <span class="token string">'./src/components'</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如上代码配置，当我通过 import xxx from ‘components/xxx’ 导入时，实际上被alias替换成了<br>import xxx from ‘./src/components/xxx’;</p><h4 id="extensions"><a href="#extensions" class="headerlink" title="extensions"></a>extensions</h4><p>在使用 import 导入文件时，有时候没有带入文件的后缀名，webpack会自动带上后缀去访问文件是否存在，那么默认的后缀名为<br>[‘.js’, ‘.json’]; 即：<br>extensions: [‘.js’, ‘.json’]; 如果我们想自己配置.vue后缀名，防止在导入文件时候不需要加上后缀；我们可以使用webpack做如下配置:</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  entry<span class="token punctuation">:</span> <span class="token string">'./js/main.js'</span><span class="token punctuation">,</span>  output<span class="token punctuation">:</span> <span class="token punctuation">{</span>    filename<span class="token punctuation">:</span> <span class="token string">'bundle.js'</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 将输出的文件都放在dist目录下</span>    path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  resolve<span class="token punctuation">:</span> <span class="token punctuation">{</span>    alias<span class="token punctuation">:</span> <span class="token punctuation">{</span>      components<span class="token punctuation">:</span> <span class="token string">'./src/components'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    extensions<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'.js'</span><span class="token punctuation">,</span> <span class="token string">'.vue'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="Externals"><a href="#Externals" class="headerlink" title="Externals"></a>Externals</h4><p>Externals 用来告诉webpack在构建代码时使用了不处理应用的某些依赖库，依然可以在代码中通过AMD，CMD或window全局方式访问。<br>什么意思呢？就是说我们在html页面中引入了jquery源文件后，比如如下代码：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html lang<span class="token operator">=</span><span class="token string">"en"</span><span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span>  <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>  <span class="token operator">&lt;</span>title<span class="token operator">></span>Title<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>  <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"http://code.jquery.com/jquery-1.12.0.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>  <span class="token operator">&lt;</span>link href<span class="token operator">=</span><span class="token string">"dist/main.css"</span> rel<span class="token operator">=</span><span class="token string">"stylesheet"</span> type<span class="token operator">=</span><span class="token string">"text/css"</span> <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span>  <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"app"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"dist/bundle.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span></code></pre><p>但是我们想在模块化的源代码里导入和使用jquery，首先我们肯定需要安装下 jquery依赖包，npm install –save jquery, 然后我们编写如下代码进行使用：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> $ <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'jquery'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>$<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>构建打包后我们会发现输出的文件里面包含jquery的内容，这导致了jquery库引入了两次，并且导致了bundle.js文件变得更大，浪费加载流量。因此 Externals 配置项就是来解决这个问题的。<br>通过externals 可以告诉webpack在javascript运行环境中已经内置了哪些全局变量，不用将这些代码打包到代码里面去。<br>因此我们可以做如下配置：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span><span class="token keyword">export</span> <span class="token operator">=</span> <span class="token punctuation">{</span>  externals<span class="token punctuation">:</span> <span class="token punctuation">{</span>    jquery<span class="token punctuation">:</span> <span class="token string">'jQuery'</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h4 id="什么是AST？"><a href="#什么是AST？" class="headerlink" title="什么是AST？"></a>什么是AST？</h4><p>请参考：<a href="https://segmentfault.com/a/1190000016231512#comment-area" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016231512#comment-area</a></p><p>转换成AST的目的就是将我们书写的字符串文件转换成计算机更容易识别的数据结构，这样更容易提取其中的关键信息，而这棵树在计算机上的表现形式，其实就是一个单纯的Object。</p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript强制类型转换</title>
      <link href="/2019/12/20/JavaScript/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2019/12/20/JavaScript/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>在说JavaScript的强制类型转换之前，我们先了解下JavaScript中的数据类型有哪些。JavaScript中类型分为以下两种：</p><ul><li>原始数据类型：null、undefined、bool、string、number、boolean以及symbol（es6提出）</li><li>对象数据类型：Object（function、date 等属于Object的子类型）</li></ul><p>那么这两种数据类型有什么区别呢？</p><p>原始数据类型在内存中的存放地点是存放在栈中，所以在传递的过程中，是值传递。</p><p>而对象数据类型的存放方式是：真实数据存放在堆中，而在栈中存放的是指向实际数据存储的地方，即堆的指针。</p><p>这也就是值传递和引用传递。</p><h3 id="字符串、数字和布尔类型之间的转换"><a href="#字符串、数字和布尔类型之间的转换" class="headerlink" title="字符串、数字和布尔类型之间的转换"></a>字符串、数字和布尔类型之间的转换</h3><h4 id="ToString"><a href="#ToString" class="headerlink" title="ToString"></a>ToString</h4><p>它负责处理非字符串到字符串的转换。</p><p>基本类型值的转换规则是：null转换为”null”，undefined转换为”undefined”,布尔转换成对应的数字：true转换为1，false转换为0。数字直接转换为对应的字符串。</p><p>对应对象，除非对象内部定义了tostring方法，否则toString()（Object.prototype.toString()）返回其内部属性[[class]]的值。如果内部自定义了toString方法，则调用该内部方法并使用其返回值。</p><p>对象的强制类型转换为string是通过<code>Toprimitive</code>抽象操作来完成的。</p><blockquote><p>ToPrimitive(input,PreferredType?)：其中PreferredType为number或者string。</p><p>如果input是原始值，则返回该原始值对应的字符串。</p><p>如果input不是原始值，则调用valueOf()方法，如果该方法返回原始值，则使用该方法返回值。</p><p>如果valueOf()返回的不是原始值，则调用toString()方法，如果该方法返回原始值，则使用该方法返回的原始值。</p><p>否则，报错TypeError</p></blockquote><p>JSON字符串化</p><p>工具函数JSON.stringify可以将JSON对象序列化为字符串，内部也是调用了ToString。</p><p>JSON.stringify使用规则：对于基本数据类型的值，使用JSON.stringify和使用toString返回结果一样。对于所有安全的JSON值，都可以使用JSON.stringify方法，所谓的JSON安全值是指：除了undefined、symbol、function以及包含循环引用的对象。</p><p>JSON.stringify接收第二个参数：可以为字符串数组或者函数。如果是一个字符串数组，则根据数组内的元素，返回指定的对象属性和属性值。如果为函数，则为过滤函数，接收两个参数，key、value，我们可以根据自己的需要自行设定返回值。如果不需要某个属性，返回undefined即可过滤。</p><p>JSON.stringify接收第三个参数：用于指定输出字符串的输出格式。</p><p>如果对象内部有自定义的toJSON方法，则使用该方法。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>  a<span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">,</span>  b<span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// toJSON:function(){</span>  <span class="token comment" spellcheck="true">//     return 0</span>  <span class="token comment" spellcheck="true">// }</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> str <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//过滤函数</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">100</span>  <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> value  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> o <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//还原函数</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">1</span>  <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> value  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="ToNumber"><a href="#ToNumber" class="headerlink" title="ToNumber"></a>ToNumber</h4><p>用来将非数字处理成数字。转换方式遵循ToPrimitive，</p><h4 id="ToBoolean"><a href="#ToBoolean" class="headerlink" title="ToBoolean"></a>ToBoolean</h4><p>JavaScript中的值大概可以分为两类：</p><ul><li>可以被强制转换为false的值，如：undefined、null、false、+0、-0、NaN和””</li><li>其他可以被转换为true的值</li></ul><p>假值对象：封装了假值的对象。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span> <span class="token boolean">false</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span> <span class="token string">""</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span></code></pre><p>它们的值为true，但是如果对其进行强制类型转换，则结果为false。</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><h4 id="隐式强制类型转换"><a href="#隐式强制类型转换" class="headerlink" title="隐式强制类型转换"></a>隐式强制类型转换</h4><h5 id="字符串和数字的隐式强制转换"><a href="#字符串和数字的隐式强制转换" class="headerlink" title="字符串和数字的隐式强制转换"></a>字符串和数字的隐式强制转换</h5><p>运算符：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"42"</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token string">"0"</span><span class="token punctuation">;</span><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "420"</span>c <span class="token operator">+</span> d<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 42</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "1,23,4"</span></code></pre><blockquote><p>根据 ES5 规范 11.6.1 节，如果某个操作数是字符串或者能够通过以下步骤转换为字符串 的话，+ 将进行拼接操作。如果其中一个操作数是对象(包括数组)，则首先对其调用 ToPrimitive 抽象操作(规范 9.1 节)，该抽象操作再调用 [[DefaultValue]](规范 8.12.8 节)，以数字作为上下文。 </p></blockquote><h5 id="宽松相等和严格相等"><a href="#宽松相等和严格相等" class="headerlink" title="宽松相等和严格相等"></a>宽松相等和严格相等</h5><p>宽松相等(loose equals)== 和严格相等(strict equals)=== 都用来判断两个值是否“相等”，但是它们之间有一个很重要的区别，特别是在判断条件上。</p><ul><li>== 在相等比较中，允许进行类型转换</li><li>=== 不允许类型转换</li></ul><h5 id="抽象相等"><a href="#抽象相等" class="headerlink" title="抽象相等"></a>抽象相等</h5><ul><li>如果表达式两端都是null、undefined，则为true。</li><li>如果NaN在其中一端，则返回false。</li><li>如果是string、number、boolean并且类型不一致，则先使用ToNumber转换为number在比较。</li><li>如果是对象，则使用ToPrimitive，获取原始值再比较。</li></ul><h4 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a>显示类型转换</h4><h5 id="字符串和数字的显示强制转换"><a href="#字符串和数字的显示强制转换" class="headerlink" title="字符串和数字的显示强制转换"></a>字符串和数字的显示强制转换</h5><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token string">"3.14"</span><span class="token punctuation">;</span><span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span> c <span class="token punctuation">)</span><span class="token punctuation">;</span>b<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "42"</span>d<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3.14</span></code></pre><p>String(..) 遵循前面讲过的 ToString 规则，将值转换为字符串基本类型。Number(..) 遵循 前面讲过的 ToNumber 规则，将值转换为数字基本类型。 </p><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><p>字位运算符只适用于 32 位整数，运算符会强制操作数使用 32 位 格式。这是通过抽象操作 ToInt32 来实现的 </p><blockquote><p>ToInt32:先试用ToNumber转换为数字，再执行ToInt32。</p></blockquote><p>～～：~~ 中的第一个 ~ 执行 ToInt32 并反转字位。然后第二个 ~ 再进行一次字位反转，即将所有 字位反转回原值</p><p>parseInt：只支持字符串解析成数字。</p><blockquote><p>~~和parseInt的区别：</p><p>1、解析成数字允许字符串中有非数字字符，从左到右依次解析，遇到非数字字符停止解析</p><p>2、强制转换成数字，不允许存在非数字字符，否则转换失败NaN</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重排与重绘</title>
      <link href="/2019/12/17/JavaScript/repaint-reflow/"/>
      <url>/2019/12/17/JavaScript/repaint-reflow/</url>
      
        <content type="html"><![CDATA[<h1 id="重排和重绘"><a href="#重排和重绘" class="headerlink" title="重排和重绘"></a>重排和重绘</h1><h4 id="浏览器构建页面布局"><a href="#浏览器构建页面布局" class="headerlink" title="浏览器构建页面布局"></a>浏览器构建页面布局</h4><ul><li>构建DOM树（parse）：渲染引擎解析html文档，首先将标签转换成DOM树中的<code>DOM node</code>，然后生成内容树（<code>Content Tree/DOM Tree</code>）。同时，也会进行CSS解析，构建<code>CSS Rules Tree</code>。</li><li>构建渲染树（render tree）：将 <code>CSS Rules Tree</code>依附于<code>DOM Tree</code> 之上，形成<code>Render Tree</code>。</li><li>构建布局渲染树（<code>reflow/layout</code>）：从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标。</li><li>绘制渲染树（<code>paint/repaint</code>）：遍历渲染树，使用UI层来绘制每个节点。</li></ul><p><img src="http://cdn.yangkunxiao.cn/jzdh0T.png#alt=%E6%9E%84%E5%BB%BA%E5%B8%83%E5%B1%80" alt=""></p><h4 id="重绘-repaint-redraw"><a href="#重绘-repaint-redraw" class="headerlink" title="重绘(repaint / redraw)"></a>重绘(repaint / redraw)</h4><p>重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。</p><p>触发重绘的条件：改变元素外观属性。如：color，background-color等。</p><h4 id="重排-重构-回流-reflow"><a href="#重排-重构-回流-reflow" class="headerlink" title="重排(重构/回流/reflow)"></a>重排(重构/回流/reflow)</h4><p>当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(<strong>reflow</strong>)。每个页面至少需要一次回流，就是在页面第一次加载的时候。</p><p>重排发生的根本原理就是<strong>元素的几何属性</strong>发生了改变。如：</p><ul><li>添加或删除可见的DOM元素</li><li>元素位置改变</li><li>元素本身的尺寸发生改变</li><li>内容改变</li><li>页面渲染器初始化</li><li>浏览器窗口大小发生改变</li><li>读取某些元素属性：（offsetLeft/Top/Height/Width,　clientTop/Left/Width/Height,　scrollTop/Left/Width/Height,　width/height,　getComputedStyle(),　currentStyle(IE)　)</li></ul><h4 id="重排和重绘的关系"><a href="#重排和重绘的关系" class="headerlink" title="重排和重绘的关系"></a>重排和重绘的关系</h4><p>在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。</p><p>所以：重排必定会引起重绘，但是重绘不一定引起重排。</p><blockquote><p>重绘和重排的代价很高，耗时，会造成浏览器的卡顿</p></blockquote><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul><li><p>浏览器自己的优化：浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p></li><li><p>开发者自己的优化：尽量减少重绘重排的次数，合并多次的DOM修改和样式修改，减少对style样式的请求</p><ul><li>直接改变元素的className</li></ul></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">.</span>active <span class="token punctuation">{</span>    padding<span class="token punctuation">:</span> 5px<span class="token punctuation">;</span>    border<span class="token operator">-</span>left<span class="token punctuation">:</span> 1px<span class="token punctuation">;</span>    border<span class="token operator">-</span>right<span class="token punctuation">:</span> 2px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// javascript</span><span class="token keyword">var</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.el'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>el<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">'active'</span><span class="token punctuation">;</span></code></pre><ul><li>display：none；先设置元素为display：none；然后进行页面布局等操作；设置完成后将元素设置为display：block；这样的话就只引发两次重绘和重排；</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#mylist'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ul<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">'none'</span><span class="token punctuation">;</span><span class="token function">appendNode</span><span class="token punctuation">(</span>ul<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>ul<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">'block'</span><span class="token punctuation">;</span></code></pre><ul><li>减少重绘重排</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.el'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>borderLeft <span class="token operator">=</span> <span class="token string">'1px'</span><span class="token punctuation">;</span>el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>borderRight <span class="token operator">=</span> <span class="token string">'2px'</span><span class="token punctuation">;</span>el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>padding <span class="token operator">=</span> <span class="token string">'5px'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//替换为</span><span class="token keyword">var</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.el'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>cssText <span class="token operator">=</span> <span class="token string">'border-left: 1px; border-right: 2px; padding: 5px'</span><span class="token punctuation">;</span></code></pre><ul><li>如果需要创建多个DOM节点，可以使用DocumentFragment创建完后一次性的加入document；</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> fragment <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createDocumentFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> li <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>li<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'apple'</span><span class="token punctuation">;</span>fragment<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> li <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>li<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'watermelon'</span><span class="token punctuation">;</span>fragment<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'fruit'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>fragment<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>将原始元素拷贝到一个独立的节点中，操作这个节点，然后覆盖原始元素</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> old <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#mylist'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> clone <span class="token operator">=</span> old<span class="token punctuation">.</span><span class="token function">cloneNode</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">appendNode</span><span class="token punctuation">(</span>clone<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>old<span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span><span class="token function">replaceChild</span><span class="token punctuation">(</span>clone<span class="token punctuation">,</span> old<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>缓存布局信息，减少对style的多次请求</li></ul><pre class=" language-javascript"><code class="language-javascript">div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> div<span class="token punctuation">.</span>offsetLeft <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> div<span class="token punctuation">.</span>offsetTop <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//替换为</span>current <span class="token operator">=</span> div<span class="token punctuation">.</span>offsetLeft<span class="token punctuation">;</span>div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token operator">++</span>current <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token operator">++</span>current <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span></code></pre><ul><li>尽量不要使用table布局。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5拖拽事件</title>
      <link href="/2019/12/15/JavaScript/drag/"/>
      <url>/2019/12/15/JavaScript/drag/</url>
      
        <content type="html"><![CDATA[<p>在网页中，拖放是一个很常见的一个用户界面模式。简单来说，就是鼠标点击目标元素不放，移动鼠标位置，然后松开鼠标，即可将目标元素移动到另一个区域。它的实现其实很简单。以下介绍两种常见的实现方法。</p><h4 id="使用onmouse事件实现拖放"><a href="#使用onmouse事件实现拖放" class="headerlink" title="使用onmouse事件实现拖放"></a>使用onmouse事件实现拖放</h4><p>通过监听鼠标事件实现元素拖放：必须借用<code>onmousedown</code>、<code>onmousemove</code>、<code>onmouseup</code>三个事件实现，且三者的顺序不能乱。</p><ul><li>onmousedown：鼠标按下事件，一般用在拖放元素上。</li><li>onmousemove：鼠标移动事件，一般用在document或者window上。</li><li>onmouseup：鼠标抬起事件，同上。</li></ul><p>具体实现如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//获取拖放元素</span><span class="token keyword">var</span> img <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录鼠标点击位置和元素边界的距离</span><span class="token keyword">var</span> dirX <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>dirY <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//给元素添加监听事件</span>img<span class="token punctuation">.</span>onmousedown <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>  dirX <span class="token operator">=</span> e<span class="token punctuation">.</span>clientX <span class="token operator">-</span> img<span class="token punctuation">.</span>offsetLeft<span class="token punctuation">;</span>    dirY <span class="token operator">=</span> e<span class="token punctuation">.</span>clientY <span class="token operator">-</span> img<span class="token punctuation">.</span>offsetTop<span class="token punctuation">;</span>  document<span class="token punctuation">.</span>onmousemove <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//记录鼠标移动距离</span>    <span class="token keyword">let</span> moveX<span class="token punctuation">,</span> moveY<span class="token punctuation">;</span>     moveX <span class="token operator">=</span> e<span class="token punctuation">.</span>clientX <span class="token operator">-</span> dirX<span class="token punctuation">;</span>    moveY <span class="token operator">=</span> e<span class="token punctuation">.</span>clientY <span class="token operator">-</span> dirY<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//处理边界问题</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>moveX <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      moveX <span class="token operator">=</span> <span class="token number">0</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>moveX <span class="token operator">></span> window<span class="token punctuation">.</span>innerWidth <span class="token operator">-</span> img<span class="token punctuation">.</span>offsetWidth<span class="token punctuation">)</span> <span class="token punctuation">{</span>      moveX <span class="token operator">=</span> window<span class="token punctuation">.</span>innerWidth <span class="token operator">-</span> img<span class="token punctuation">.</span>offsetWidth    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>moveY <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      moveY <span class="token operator">=</span> <span class="token number">0</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>moveY <span class="token operator">></span> window<span class="token punctuation">.</span>innerHeight <span class="token operator">-</span> img<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">)</span> <span class="token punctuation">{</span>      moveY <span class="token operator">=</span> window<span class="token punctuation">.</span>innerHeight <span class="token operator">-</span> img<span class="token punctuation">.</span>offsetHeight    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//实时的改变元素位置</span>    img<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> moveX <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>    img<span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> moveY <span class="token operator">+</span> <span class="token string">'px'</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//监听鼠标抬起事件</span>  document<span class="token punctuation">.</span>onmouseup <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//事件取消</span>    document<span class="token punctuation">.</span>onmouseup <span class="token operator">=</span> document<span class="token punctuation">.</span>onmousemove <span class="token operator">=</span> <span class="token keyword">null</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="使用HTML5Drag实现拖放"><a href="#使用HTML5Drag实现拖放" class="headerlink" title="使用HTML5Drag实现拖放"></a>使用HTML5Drag实现拖放</h4><p>拖拽元素时，将依次发生以下事件：</p><ul><li>ondragstart</li><li>ondrag：拖拽期间持续触发该事件</li><li>ondragend</li></ul><p>在目标元素（放置目标元素）上将会发生以下事件：</p><ul><li>ondragenter：元素进入目标元素</li><li>ondragover：元素在目标元素之中移动</li><li>ondragleave/ondrop：元素离开目标元素/鼠标抬起</li></ul><p><strong>dataTransfer</strong> 对象：使用该对象进行数据传输</p><ul><li>setData：接收两个参数：第一个参数设置传输数据的类型：text 或者 URL，第二个参数设置值</li><li>getData：接收值，只发生在ondrop</li></ul><p><strong>dropEffect</strong>与<strong>effectAllowed</strong> ：通过<strong>dataTransfer</strong>对象还可以确定被拖拽元素以及放置目标的元素能够接受什么操作。其中<strong>dropEffect</strong>可以知道被拖拽元素可以执行那种放置行为。<strong>effectAllowed</strong>可以知道允许拖拽元素执行哪种<strong>dropEffect</strong>。</p><p><strong>effectAllowed</strong>有四种值：</p><ul><li>“none”:不能把拖动的元素放在这里。这是除文本框之外所有元素的默认值。</li><li>“move”:应该把拖动的元素移动到放置目标。</li><li>“copy”:应该把拖动的元素复制到放置目标。</li><li>“link”:表示放置目标会打开拖动的元素(但拖动的元素必须是一个链接，有 URL)。 </li></ul><blockquote><p>要使用 dropEffect 属性，必须在 ondragenter 事件处理程序中针对放置目标来设置它。 </p></blockquote><p><strong>effectAllowed</strong>的属性值如下：</p><ul><li>“uninitialized”:没有给被拖动的元素设置任何放置行为。 </li><li>“none”:被拖动的元素不能有任何行为。</li><li>“copy”:只允许值为”copy”的 dropEffect。</li><li>“link”:只允许值为”link”的 dropEffect。 </li><li>“move”:只允许值为”move”的 dropEffect。</li><li>“copyLink”:允许值为”copy”和”link”的 dropEffect。 </li><li>“copyMove”:允许值为”copy”和”move”的 dropEffect。 </li><li>“linkMove”:允许值为”link”和”move”的 dropEffect。 </li><li>“all”:允许任意 dropEffect。 </li></ul><blockquote><p>必须在 ondragstart 事件处理程序中设置 effectAllowed 属性</p></blockquote><p>使用HTML5Drag事件来实现自由拖拽，具体实现如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> EventUtil <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 绑定事件     * @param { type } = { 事件类型 }       * @param { callback }  = { 回调函数 }      * @param { bool }   = { 指定事件是否在捕获或冒泡阶段执行。true - 事件句柄在捕获阶段执行。默认，事件句柄在冒泡阶段执行 }     * */</span>    addHandler<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> type<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> bool <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>el<span class="token punctuation">.</span>addEventListener<span class="token punctuation">)</span> <span class="token punctuation">{</span>            el<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> bool<span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>el<span class="token punctuation">.</span>attachEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">attactEvent</span><span class="token punctuation">(</span><span class="token string">'on'</span> <span class="token operator">+</span> type<span class="token punctuation">,</span> callback<span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//默认使用DOM0级的事件</span>            el<span class="token punctuation">[</span><span class="token string">'on'</span> <span class="token operator">+</span> type<span class="token punctuation">]</span> <span class="token operator">=</span> callback<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> img <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录鼠标点击位置和边界的距离</span><span class="token keyword">var</span> dirX <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>dirY <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">var</span> dirX<span class="token punctuation">,</span> dirY<span class="token punctuation">;</span>EventUtil<span class="token punctuation">.</span><span class="token function">addHandler</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span> <span class="token string">'dragstart'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token string">'开始拖拽'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  dirX <span class="token operator">=</span> e<span class="token punctuation">.</span>clientX <span class="token operator">-</span> img<span class="token punctuation">.</span>offsetLeft<span class="token punctuation">;</span>  dirY <span class="token operator">=</span> e<span class="token punctuation">.</span>clientY <span class="token operator">-</span> img<span class="token punctuation">.</span>offsetTop<span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dirX<span class="token punctuation">,</span> dirY<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>EventUtil<span class="token punctuation">.</span><span class="token function">addHandler</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> <span class="token string">'dragenter'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'进入目标元素'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>EventUtil<span class="token punctuation">.</span><span class="token function">addHandler</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> <span class="token string">'dragover'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// console.log('在目标元素中移动');</span>  <span class="token comment" spellcheck="true">//计算鼠标移动距离</span>  <span class="token keyword">let</span> moveX <span class="token operator">=</span> moveY <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  moveX <span class="token operator">=</span> e<span class="token punctuation">.</span>clientX <span class="token operator">-</span> dirX<span class="token punctuation">;</span>  moveY <span class="token operator">=</span> e<span class="token punctuation">.</span>clientY <span class="token operator">-</span> dirY<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//边界处理</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>moveX <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    moveX <span class="token operator">=</span> <span class="token number">0</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>moveX <span class="token operator">></span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>innerWidth <span class="token operator">-</span> img<span class="token punctuation">.</span>offsetWidth<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    moveX <span class="token operator">=</span> window<span class="token punctuation">.</span>innerWidth <span class="token operator">-</span> img<span class="token punctuation">.</span>offsetWidth  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>moveY <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    moveY <span class="token operator">=</span> <span class="token number">0</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>moveY <span class="token operator">></span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>innerHeight <span class="token operator">-</span> img<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    moveY <span class="token operator">=</span> window<span class="token punctuation">.</span>innerHeight <span class="token operator">-</span> img<span class="token punctuation">.</span>offsetHeight  <span class="token punctuation">}</span>  img<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> moveX <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>  img<span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> moveY <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//阻止默认行为</span>  EventUtil<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>EventUtil<span class="token punctuation">.</span><span class="token function">addHandler</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> <span class="token string">'dragleave'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'离开目标元素'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>EventUtil<span class="token punctuation">.</span><span class="token function">addHandler</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> <span class="token string">'drop'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//设置磁吸效果</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>clientX <span class="token operator">></span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>innerWidth <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    img<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> window<span class="token punctuation">.</span>innerWidth <span class="token operator">-</span> img<span class="token punctuation">.</span>offsetWidth <span class="token operator">+</span> <span class="token string">'px'</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    img<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// console.log(e,'drop');</span>  <span class="token comment" spellcheck="true">// let data = e.dataTransfer.getData('text');</span>  <span class="token comment" spellcheck="true">// console.log('drop');</span>  <span class="token comment" spellcheck="true">// EventUtil.removeHandler()</span>  <span class="token comment" spellcheck="true">// e.target.appendChild(document.getElementById(data))</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="http://cdn.yangkunxiao.cn/%E6%8B%96%E6%8B%BD%E4%BA%8B%E4%BB%B6.png" alt="拖放事件流程"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈JavaScript异步编程</title>
      <link href="/2019/12/07/JavaScript/JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/12/07/JavaScript/JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>JavaScript异步编程</p><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>Promise是异步编程的一种实现方式，它比传统的解决方案更加合适、强大。所谓Promise，就是一种容器，容器里面保存着未来才会发生的事情（一般是异步操作）的结果。</p><p>Promise是一个对象，它提供一系列的API可以将异步操作的事情以同步的形式表现出来，比起”回调地狱”，它看起来更加合适、强大。它具有以下几大特点：</p><ul><li><code>Promise</code>的状态不受任何外界的影响。Promise的异步操作有三种状态：    <code>pending</code>(执行中)、<code>fulfilled</code>(已成功)、<code>rejected</code>(已失败)。只有异步操作的结果才能够决定<code>Promise</code>状态的走向。</li><li><code>Promise</code>的状态一旦改变，变不可再次变动。它的状态变化只有两种情况：<code>pending</code> =&gt; <code>fulfilled</code>、<code>pengding</code> =&gt; <code>rejected</code>。状态一旦发生变化，就不再改变，称之为 <code>resolved</code>(已定型)。</li></ul><p>Promise一旦新建之后，就会立即执行。而then指定的回调函数只有同步操作执行完之后才会执行。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//成功回调</span>  <span class="token comment" spellcheck="true">//todo</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//失败回调</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//todo</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p><p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 <code>pending</code> 变为 <code>resolved</code>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 <code>pending</code> 变为 <code>rejected</code>），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。但是一般默认不指定<code>rejected</code>状态的回调函数，而是使用<code>catch</code>。</p><p><code>finally</code>不管<code>promise</code>最终的执行结果如何，都会执行。</p><p><code>all</code>：方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><p><code>Promise.all()</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例</p><p>举个🌰：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        msg<span class="token punctuation">:</span> <span class="token string">'p1'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        msg<span class="token punctuation">:</span> <span class="token string">'p2'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> p3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        msg<span class="token punctuation">:</span> <span class="token string">'p3'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">,</span>p3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">[</span>res1<span class="token punctuation">,</span>res2<span class="token punctuation">,</span>res3<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res1<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res2<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行结果：p1 p2 p3</span></code></pre><p><code>p</code>的状态由p1,p2,p3决定：</p><ul><li><p>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p></li><li><p>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p></li></ul><p><code>race</code>：该方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>只要只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p><p><code>allSettled</code>：该方法由<code>ES2020</code>引入。<code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束。</p><p><code>any</code>：<code>Promise.any()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。该方法目前是一个第三阶段的<a href="https://github.com/tc39/proposal-promise-any" target="_blank" rel="noopener">提案</a> 。</p><p><code>resolve</code>：<code>Promise.resolve()</code>将现有对象转为 Promise 对象。</p><ul><li><p>参数是一个<code>Promise</code>实例：那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p></li><li><p>参数是一个 <code>thenable</code> 实例：<code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> thenable <span class="token operator">=</span> <span class="token punctuation">{</span>  then<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><code>Promise.resolve</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then</code>方法。</p></li><li><p>参数不是具有<code>then</code>方法的对象，或根本就不是对象：如果参数是一个原始值，或者是一个不具有<code>then</code>方法的对象，则<code>Promise.resolve</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Hello</span></code></pre></li></ul><p><code>reject</code>：<code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p><h4 id="Generator-yield"><a href="#Generator-yield" class="headerlink" title="Generator/yield"></a>Generator/yield</h4><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p><p>Generator 函数有多种理解角度。语法上，Generator 函数是一个状态机，封装了多个内部状态。</p><p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个<code>遍历器对象生成函数</code>。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p><p>形式上，Generator 函数是一个普通函数，但是有两个特征:</p><p>1、<code>function</code>关键字与函数名之间有一个星号；</p><p>2、函数体内部使用<code>yield</code>表达式，定义不同的内部状态</p><blockquote><p> Generator 函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行。</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">helloWorldGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">yield</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>  <span class="token keyword">yield</span> <span class="token string">'world'</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token string">'ending'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">let</span> hwg <span class="token operator">=</span> <span class="token function">helloWorldGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>hwg<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//{ value:hello,done:false }</span>hwg<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//{ value:world,done:false }</span>hwg<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//{ value:ending,done:true }</span>hwg<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//{ value:undefined,done:true }</span></code></pre><p>总结：调用Generator函数，会返回一个遍历器对象，它是函数内部的指针，以后每调用一次next函数，就会返回一个带有value和done属性的对象。<code>next</code>方法可以带一个参数，该参数就会被当作上一个<code>yield</code>表达式的返回值。<code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</p><p>Generator 函数返回的遍历器对象，还有一个<code>return</code>方法，可以返回给定的值，并且终结遍历 Generator 函数。</p><h4 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h4><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。它是Generator的语法糖。<code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>。</p><p><code>async</code>函数对 Generator 函数的改进，体现在以下几点。</p><ul><li><p>内置执行器。</p><p>Generator 函数的执行必须靠执行器。而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。</p></li><li><p>返回值是 Promise</p><p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p></li></ul><p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p><p><code>async</code>函数返回一个 Promise 对象。<code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。</p><p><code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</p><p>举个🌰：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">timeFn</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//Promise 新建后就会立即执行。</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        msg<span class="token punctuation">:</span><span class="token string">'hello'</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fun</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//Promise的写法</span>  <span class="token comment" spellcheck="true">// timeFn(time).then(res => {</span>  <span class="token comment" spellcheck="true">//     console.log(res);</span>  <span class="token comment" spellcheck="true">// })</span>  <span class="token comment" spellcheck="true">//async await的写法</span>  <span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">timeFn</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span></code></pre><p>程序会在3s之后打印{msg:’hello’}</p><p><code>await</code>：正常情况下，<code>await</code>命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义<code>then</code>方法的对象），那么<code>await</code>会将其等同于 Promise 对象。</p><p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 Promise 对象被<code>reject</code>。</p><p><code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</p><p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 等同于</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//spawn 自动执行器</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器中的进程、线程和Event Loop</title>
      <link href="/2019/12/01/JavaScript/EventLoop/"/>
      <url>/2019/12/01/JavaScript/EventLoop/</url>
      
        <content type="html"><![CDATA[<p>#浏览器</p><p>浏览器是多进程的。每一个Tab页就是一个独立的进程。</p><ul><li>主进程：个人理解问“管家”的角色，它控制着浏览器的各个任务，页面展示、网络请求、历史回退、前进等等</li><li>第三方插件进程：管理第三方插件</li><li>GPU线程：用于3D绘制</li><li>渲染进程：对前端来说，最重要的进程。</li></ul><h1 id="浏览器内核（渲染进程）"><a href="#浏览器内核（渲染进程）" class="headerlink" title="浏览器内核（渲染进程）"></a>浏览器内核（渲染进程）</h1><p>渲染进程是多线程的。它包含一下几大线程：</p><ul><li>GUI线程<ul><li>它负责页面的渲染、布局。</li><li>当页面发生重绘或者回流的时候，就会触发该线程</li><li>它和JS引擎线程互斥</li></ul></li><li>JS引擎线程<ul><li>负责程序的解析和执行</li></ul></li><li>事件触发线程<ul><li>它控制事件循环，管理着一个事件任务队列TaskQueue</li><li>当异步任务满足条件时，会将该异步任务的回调函数放入到JS引擎线程所在的执行栈中执行</li></ul></li><li>定时触发器线程<ul><li>setTimeOut 和 setInterval 所在的线程</li><li>定时器任务的计时不是由JS引擎计时的，而是由该线程控制</li><li>当定时任务计时完成之后，会通知事件触发线程</li></ul></li><li>异步http请求线程<ul><li>一个独立的ajax请求线程</li><li>当请求完成之后，会通知事件触发线程</li></ul></li></ul><h4 id="为什么GUI线程和JS引擎线程互斥"><a href="#为什么GUI线程和JS引擎线程互斥" class="headerlink" title="为什么GUI线程和JS引擎线程互斥"></a>为什么GUI线程和JS引擎线程互斥</h4><p>因为JS是可以操作DOM的，如果使用JS操作DOM的同时，GUI线程也在渲染DOM，那么渲染完成之后的元素可能就不是之前的元素了</p><h4 id="为什么JS引擎是单线程"><a href="#为什么JS引擎是单线程" class="headerlink" title="为什么JS引擎是单线程"></a>为什么JS引擎是单线程</h4><ul><li>创建JavaScript语言的时候，多进程多线程的架构并不流行，硬件支持度不高</li><li>多进程多线程操作需要加锁，操作成本较高，较为复杂</li><li>如果多个线程同时操作一个DOM，那么结果会是不可预料的</li></ul><h1 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h1><ul><li>JS的任务分为同步任何和异步任务的</li><li>同步任务都在JS引擎的执行栈上执行</li><li>事件触发线程管理一个任务队列，TaskQueue，当异步任务满足条件时，事件触发线程会将其放到任务队列当中，当主线程（JS引擎线程）执行完执行栈中的任务之后，会读取任务队列中的任务，如果有，就将可执行的异步任务的回调函数推入到执行栈中，开始执行。如果没有，则再次向事件触发线程发起询问，直到有为止。</li></ul><p><img src="http://cdn.yangkunxiao.cn/EventLoop.png" alt="Event Loop"></p><p>代码解释：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> timerCallback <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timerCallback'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> httpCallback <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'httpCallback'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 同步任务</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'同步任务1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 同步任务</span><span class="token comment" spellcheck="true">// 通知定时器线程 1s 后将 timerCallback 交由事件触发线程处理</span><span class="token comment" spellcheck="true">// 1s 后事件触发线程将 timerCallback 加入到事件队列中</span><span class="token function">setTimeout</span><span class="token punctuation">(</span>timerCallback<span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 同步任务</span><span class="token comment" spellcheck="true">// 通知异步http请求线程发送网络请求，请求成功后将 httpCallback 交由事件触发线程处理</span><span class="token comment" spellcheck="true">// 请求成功后事件触发线程将 httpCallback 加入到事件队列中</span>$<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'www.xxxx.com'</span><span class="token punctuation">,</span>httpCallback<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 同步任务</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'同步任务2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//...</span><span class="token comment" spellcheck="true">// 所有同步任务执行完后</span><span class="token comment" spellcheck="true">// 询问事件触发线程在事件事件队列中是否有需要执行的回调函数</span><span class="token comment" spellcheck="true">// 如果没有，一直询问，直到有为止</span><span class="token comment" spellcheck="true">// 如果有，将回调事件加入执行栈中，开始执行回调代码</span></code></pre><p>总结：</p><ul><li>JS引擎线程只执行执行栈中的事件</li><li>执行栈中的代码执行完毕，就会读取事件队列中的事件</li><li>事件队列中的回调事件，是由各自线程插入到事件队列中的</li><li>如此循环</li></ul><h4 id="宏任务、微任务"><a href="#宏任务、微任务" class="headerlink" title="宏任务、微任务"></a>宏任务、微任务</h4><p>宏任务：可以理解为浏览器级别的任务。主代码块，setTimeout，setInterval等，都属于宏任务</p><p>微任务：JS引擎级别的任务。Promise，process.nextTick等，属于<code>微任务</code>。</p><p>执行顺序：</p><ul><li>当前代码块对应的宏任务</li><li>当前宏任务结束之后，下一个宏任务开始之前，执行当前对列的微任务</li><li>GUI引擎渲染</li><li>下一个宏任务</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解JS的for循环</title>
      <link href="/2019/12/01/JavaScript/for/"/>
      <url>/2019/12/01/JavaScript/for/</url>
      
        <content type="html"><![CDATA[<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr1<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'l'</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">=</span> arr1<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> arr1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>for循环可以使用<code>break</code>和<code>continue</code></p><h4 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h4><ul><li>for-in 只能遍历“可枚举的属性”  可以使用查看是否可枚举<code>Object.getOwnPropertyDescriptor(object,property)</code></li><li>它实际上遍历的是对象的属性，而不是“索引值”， 所以for in可以遍历对象</li><li>遍历原型上的属性(可以配合 Object.hasOwnProperty())</li><li>for in遍历的顺序并不确定</li><li>性能：每次迭代操作会同时搜索实例或者原型属性， for-in 循环的每次迭代都会产生更多开销，因此要比其他循环类型慢</li></ul><pre class=" language-javascript"><code class="language-javascript">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> arr1<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`arr1[</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">] = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>arr1<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr1<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'age'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><ul><li>forEach 方法为数组中含有有效值的每一项执行一次 callback 函数</li><li>那些已删除（使用 delete 方法等情况）或者从未赋值的项将被跳过（不包括那些值为 undefined 或 null 的项）</li><li>不能使用break 和 continue</li><li>forEach 的速度不如 for</li></ul><pre class=" language-javascript"><code class="language-javascript">arr1<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr1<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span>index<span class="token punctuation">,</span>arr1<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span>index<span class="token punctuation">,</span>arr1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>看🌰：mac电脑、chrome浏览器的执行环境下</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">'for'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> <span class="token number">100000</span> <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">'for'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//耗时约8.5s</span>arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">'foreach'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span>index<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">'foreach'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//耗时约10.34s</span></code></pre><h4 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h4><ul><li><p>for of 是用来遍历可迭代对象的，js 引擎是通过判断对象是否具有 <code>Symbol.iterator</code> 来判断的，</p><ul><li>[][Symbol.iterator]</li><li>{}[Symbol.iterator]</li></ul></li><li><p>迭代器：有next()方法的对象，next()方法返回：done和value，done标示是否遍历完，value就是当前的值</p></li><li><p>跟 forEach 相比，它可以正确响应 break, continue, return。</p></li><li><p>for-of 循环不仅支持数组，还支持大多数类数组对象，例如 DOM nodelist 对象。</p></li><li><p>for-of 循环也支持字符串遍历，它将字符串视为一系列 Unicode 字符来进行遍历</p></li><li><p>for-of循环不支持普通对象，但如果你想迭代一个对象的属性，你可以用for-in 循环</p></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>item<span class="token punctuation">,</span>index<span class="token punctuation">]</span> <span class="token keyword">of</span> arr1<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span>index<span class="token punctuation">,</span><span class="token string">'===========for of'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>既然知道了<code>for of</code>的工作原理，那么我们是否可以手动实现一个功能，让对象可以被<code>for of</code>遍历呢？</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">createIterator</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">let</span> propKeys <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> propKey <span class="token keyword">of</span> propKeys<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">yield</span> <span class="token punctuation">[</span>propKey<span class="token punctuation">,</span> obj<span class="token punctuation">[</span>propKey<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span><span class="token string">'kaka'</span><span class="token punctuation">,</span>  age<span class="token punctuation">:</span><span class="token number">24</span><span class="token punctuation">}</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span>value<span class="token punctuation">]</span> <span class="token keyword">of</span> <span class="token function">createIterator</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">,</span><span class="token string">'=========forof'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tree-shaking</title>
      <link href="/2019/11/30/Webpack/03/"/>
      <url>/2019/11/30/Webpack/03/</url>
      
        <content type="html"><![CDATA[<h4 id="js：tree-shaking"><a href="#js：tree-shaking" class="headerlink" title="js：tree-shaking"></a>js：tree-shaking</h4><ul><li><p>它是指帮助开发者消除不同模块之间的一些无效代码的feature。在webpack中，也是有tree-shaking功能的，但是它的功能十分简单粗暴：只寻找<code>import</code>引入进来的变量是否出现过在模块内，非常简单粗暴。因为在开发过程中，开发者经常会犯这种错误：一些模块曾经引入了进来，但是后来却没有使用到，忘记删除了，这就会导致打包的时候，webpack自带的tree-shaking功能无法将这些无效的feature去除。</p></li><li><p>这是我们需要借助一些第三方插件去做这个事情：</p><pre class=" language-base"><code class="language-base">npm install --save-dev webpack-deep-scope-plugin//在webpack.config.js中引用const WebpackDeepScopeAnalysisPlugin = require('webpack-deep-scope-plugin').default;module.export = {    ......    plugins:[        new WebpackDeepScopeAnalysisPlugin()    ]}</code></pre><p>详情请参考：<a href="https://diverse.space/2018/05/better-tree-shaking-with-scope-analysis" target="_blank" rel="noopener">https://diverse.space/2018/05/better-tree-shaking-with-scope-analysis</a></p></li></ul><h4 id="css-tree-shaking"><a href="#css-tree-shaking" class="headerlink" title="css:tree-shaking"></a>css:tree-shaking</h4><ul><li><p>spa：<a href="https://www.npmjs.com/package/purifycss-webpack" target="_blank" rel="noopener">purifycss-webpack</a>该插件会把所有未被引用的css全部去除</p><pre class=" language-javascript"><code class="language-javascript">production：npm install <span class="token operator">--</span>save<span class="token operator">-</span>dev purifycss<span class="token operator">-</span>webpack<span class="token comment" spellcheck="true">//在webpack.config.js中引用</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//查找文件</span><span class="token keyword">const</span> glob <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'glob'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> PurifyCSSPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'purifycss-webpack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span><span class="token keyword">export</span> <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token operator">...</span>    plugins<span class="token punctuation">:</span><span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">PurifyCSSPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// Give paths to parse for rules. These should be absolute!</span>      paths<span class="token punctuation">:</span> glob<span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'./dist/*.html'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre></li><li><p>mpa：<a href="https://www.npmjs.com/package/mini-css-extract-plugin" target="_blank" rel="noopener">mini-css-extract-plugin</a>将css从js中抽离出来</p><blockquote><p>注意：它和style-loader 互斥， 不能同时开启，且HMR(热更新的时候也不支持) ， 只用于开发环境。</p></blockquote><pre class=" language-javascript"><code class="language-javascript">npm install <span class="token operator">--</span>save<span class="token operator">-</span>dev mini<span class="token operator">-</span>css<span class="token operator">-</span>extract<span class="token operator">-</span>plugin<span class="token punctuation">;</span><span class="token keyword">const</span> MiniCssExtractPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'mini-css-extract-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span><span class="token keyword">export</span> <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token operator">...</span><span class="token operator">...</span>  rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      test<span class="token punctuation">:</span> <span class="token regex">/\.css$/i</span><span class="token punctuation">,</span>      use<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token comment" spellcheck="true">// 'style-loader',</span>        <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//和style-loader 互斥 不能同时开启 HMR(热更新的时候也不支持)  只用于开发环境</span>          loader<span class="token punctuation">:</span> MiniCssExtractPlugin<span class="token punctuation">.</span>loader<span class="token punctuation">,</span>          options<span class="token punctuation">:</span> <span class="token punctuation">{</span>            publicPath<span class="token punctuation">:</span> <span class="token string">'../'</span><span class="token punctuation">,</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        loader<span class="token punctuation">:</span> <span class="token string">'css-loader'</span>        <span class="token punctuation">}</span>      <span class="token punctuation">]</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单元测试</title>
      <link href="/2019/11/30/Mocha/index/"/>
      <url>/2019/11/30/Mocha/index/</url>
      
        <content type="html"><![CDATA[<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>单元测试是指对软件中最小可测试单元进行检查验证，也称作模块测试。在nodeJs中通常是指对某个函数或者API进行正确验证，以保证代码的可用性。</p><p>单元测试有很多种，常见的有：行为驱动开发（BDD）和 测试驱动开发（TDD）。</p><ul><li>行为驱动开发（BDD）：行为驱动开发关注的是整个系统的最终实现是否和用户期望一致。</li><li>测试驱动开发（TDD）：测试驱动开发的目的是取得快速反馈，使所有功能都是可用的。</li></ul><h4 id="Mocha"><a href="#Mocha" class="headerlink" title="Mocha"></a>Mocha</h4><p>Mocha是现在最流行的一种单元测试框架。Mocha功能比较丰富，支持BDD、TDD</p><p>风格的测试，而且支持异步、同步的测试。</p><p>安装：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g mochaor<span class="token function">npm</span> <span class="token function">install</span> -S mocha</code></pre><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><p>创建一个demo01.js文件，文件中包含一个求和函数：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">...</span>rest<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> rest<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a <span class="token operator">+</span> b    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    add<span class="token punctuation">}</span></code></pre><p>再创建一个test的文件夹，进行测试：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> lib <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'../demo01.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> assert <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'assert'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> should <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'should'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">'Math'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">'#add'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">'add(0,0) should return 0'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//使用assert断言库</span>            <span class="token comment" spellcheck="true">// assert.strictEqual(0,lib.add(0,0));</span>            <span class="token comment" spellcheck="true">//使用should.js断言库进行测试</span>            lib<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>should<span class="token punctuation">.</span>be<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">'add(1,-1) should return 0'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// assert.strictEqual(0,lib.add(1,-1))</span>            lib<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>should<span class="token punctuation">.</span>be<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">'add(1,1) should return 2'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// assert.strictEqual(2,lib.add(1,1))</span>            lib<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>should<span class="token punctuation">.</span>be<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>describe(moduleName,testDetail):描述将要测试的模块。</p><p>it(info,function()):测试语句放在回调函数中：</p><ul><li>info 是正确输出时的简单语句描述</li><li>一个it对应一个实际的可能情况</li></ul><p>关于assets的更多的API，可参考<a href="https://nodejs.org/dist/latest/docs/api/assert.html#assert_assert" target="_blank" rel="noopener">node.js官网</a></p><p>关于should.js的更多的API，可参考<a href="https://shouldjs.github.io/" target="_blank" rel="noopener">should.js官网</a></p><p>然后，在package.json中写一下命令：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token string">"scripts"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>  <span class="token string">"test"</span><span class="token punctuation">:</span> <span class="token string">"mocha"</span><span class="token punctuation">}</span></code></pre><p>执行命令，mocha即可自动执行test文件夹下所有的测试脚本。</p><h4 id="异步测试"><a href="#异步测试" class="headerlink" title="异步测试"></a>异步测试</h4><p>使用Mocha进行异步测试，只需要在测试完成之后回调一个回调函数即可，例如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//异步测试</span><span class="token keyword">function</span> <span class="token function">asyncFn</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        callback <span class="token operator">&amp;&amp;</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    asyncFn<span class="token punctuation">}</span></code></pre><p>测试：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> lib <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'../demo03.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">'async.js'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">'async'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">'should wait 1000ms'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>done<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            lib<span class="token punctuation">.</span><span class="token function">asyncFn</span><span class="token punctuation">(</span>done<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h4 id="路由测试"><a href="#路由测试" class="headerlink" title="路由测试"></a>路由测试</h4><p>需要借用<code>supertest</code>库对后端的API接口进行测试.</p><p>安装：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev supertest</code></pre><p>supertest支持各种框架。本例以Express为例：</p><pre><code>//测试路由const express = require(&#39;express&#39;);const app = express();app.get(&#39;/user&#39;,(req,res) =&gt; {    res.status(200).json({        name:&#39;ykx&#39;,        age:24    })});module.exports = app;</code></pre><p>express设置了一个返回json格式的/user路由，通过get请求，返回用户名和年龄。</p><p>测试：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> request <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'supertest'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'../demo04.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">'GET /user'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">'should an name with age'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>done<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">request</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/user'</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span><span class="token string">'application/json;charset=utf-8'</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token punctuation">{</span>            name<span class="token punctuation">:</span><span class="token string">'ykx'</span><span class="token punctuation">,</span>            age<span class="token punctuation">:</span><span class="token number">24</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>done<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h4 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h4><p>测试覆盖率一般包含四个维度：</p><ul><li>行覆盖率：是否每一行都执行了</li><li>函数覆盖率：是否每一个函数都执行了</li><li>分支覆盖率：是否每个if代码块都执行了</li><li>语句覆盖率。是否每个语句都执行了</li></ul><p>在NodeJs中可以使用<code>Istanbul</code>代码覆盖率工具。</p><p>安装：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g istanbul</code></pre><p>然后在package.json中去配置命令：</p><pre class=" language-bash"><code class="language-bash"><span class="token string">"scripts"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>  <span class="token string">"test"</span><span class="token keyword">:</span> <span class="token string">"mocha"</span>,  <span class="token string">"cover"</span><span class="token keyword">:</span><span class="token string">"istanbul cover node_modules/mocha/bin/_mocha test/"</span><span class="token punctuation">}</span></code></pre><p>执行<code>npm run cover</code>命令，会在根目录下生成coverage文件夹，里面包含所有的测试数据。</p>]]></content>
      
      
      <categories>
          
          <category> Mocha </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mocha </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL自然连接查询</title>
      <link href="/2019/11/24/Mysql/naturalJoin/"/>
      <url>/2019/11/24/Mysql/naturalJoin/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是自然连接？"><a href="#什么是自然连接？" class="headerlink" title="什么是自然连接？"></a>什么是自然连接？</h4><p>通过mysql自己判断完成连接过程,不需要指定连接条件，mysql会根据多个表内的相同字段作为连接条件。</p><h4 id="自然连接的分类"><a href="#自然连接的分类" class="headerlink" title="自然连接的分类"></a>自然连接的分类</h4><p>自然连接分为：<strong><em>内自然连接</em></strong>（inner natural join）和 <strong><em>外自然连接</em></strong>。其中<strong><em>外自然连接</em></strong>又可分为<strong><em>左外自然连接</em></strong>（left natural join ）和 <strong><em>右外自然连接</em></strong>（right natural join）。</p><p>注意：自然连接没有判断语句！！！</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>假如存在两张表：tab1和tab2</p><ul><li><p>内自然连接</p><pre class=" language-javascript"><code class="language-javascript">select <span class="token operator">*</span> <span class="token keyword">from</span> tab1 natural join tab2<span class="token punctuation">;</span></code></pre><p>内自然连接相当于<strong>using为判断语句的内连接：</strong>即：</p><pre class=" language-javascript"><code class="language-javascript">select <span class="token operator">*</span> <span class="token keyword">from</span> tbl_name1 inner join tbl_name2 using<span class="token punctuation">;</span></code></pre></li><li><p>左外自然连接</p><pre class=" language-javascript"><code class="language-javascript">select <span class="token operator">*</span> <span class="token keyword">from</span> tab1 natural left join tab2<span class="token punctuation">;</span></code></pre><p>相当于using为判断语句的左外连接：</p><pre class=" language-javascript"><code class="language-javascript">select <span class="token operator">*</span> <span class="token keyword">from</span> tab1 left outer join tab2 using<span class="token punctuation">;</span></code></pre></li><li><p>右外自然连接</p><pre class=" language-javascript"><code class="language-javascript">select <span class="token operator">*</span> <span class="token keyword">from</span> tab1 natural right join tab2<span class="token punctuation">;</span></code></pre><p>相当于using为判断语句的右外连接：</p><pre class=" language-javascript"><code class="language-javascript">select <span class="token operator">*</span> <span class="token keyword">from</span> tab1 natural right join tab2<span class="token punctuation">;</span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 8.0+重置密码</title>
      <link href="/2019/11/24/Mysql/resetPassWord/"/>
      <url>/2019/11/24/Mysql/resetPassWord/</url>
      
        <content type="html"><![CDATA[<h4 id="关闭数据库"><a href="#关闭数据库" class="headerlink" title="关闭数据库"></a>关闭数据库</h4><p>1、在终端中输入：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> /usr/local/mysql/support-files mysql.server stop</code></pre><p>2、在访达中找到安装好的mysql，关闭mysql运行。</p><h4 id="跳过验证"><a href="#跳过验证" class="headerlink" title="跳过验证"></a>跳过验证</h4><pre class=" language-bash"><code class="language-bash">// 进入数据库指令文件<span class="token function">cd</span> /usr/local/mysql/bin// 跳过权限认证<span class="token function">sudo</span> ./mysqld_safe --skip-grant-tables</code></pre><h4 id="免密码进入数据库"><a href="#免密码进入数据库" class="headerlink" title="免密码进入数据库"></a>免密码进入数据库</h4><p>在上述指令运行后，新开一个终端，同时保持原来那个终端也开着，在新的终端输入指令如下：</p><pre class=" language-bash"><code class="language-bash">//  执行mysql指令/usr/local/mysql/bin/mysql// 进入名为<span class="token operator">&lt;</span>mysql<span class="token operator">></span>的数据库use mysql<span class="token punctuation">;</span>把之前密码清空：update user <span class="token keyword">set</span> authentication_string<span class="token operator">=</span><span class="token string">''</span>  where user<span class="token operator">=</span><span class="token string">'root'</span><span class="token punctuation">;</span>// 刷新权限flush privileges<span class="token punctuation">;</span>// 修改密码 但不适用于8.0+的版本// <span class="token keyword">set</span> password <span class="token keyword">for</span> <span class="token string">'root'</span>@<span class="token string">'localhost'</span> <span class="token operator">=</span> password<span class="token punctuation">(</span><span class="token string">'新的密码'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>// 8.0+版本修改密码ALTER user <span class="token string">'root'</span>@<span class="token string">'localhost'</span> indentified by <span class="token string">'新密码'</span><span class="token punctuation">;</span>//刷新一下flush privileges<span class="token punctuation">;</span>// 退出mysql<span class="token keyword">exit</span></code></pre><p>mysql常用命令：</p><pre class=" language-bash"><code class="language-bash">1、进入本地数据库：/usr/local/mysql/bin/mysql -u root -p 根据提示输入密码2、进入远程数据库：假设远程主机的IP为：23.106.134.88，用户名为root,密码为123456：mysql -h23.106.134.88 -u root -p 根据提示输入密码。3、启动mysql服务：<span class="token function">sudo</span> /usr/local/mysql/support-files/mysql.server start<span class="token punctuation">;</span>4、终止mysql服务：<span class="token function">sudo</span> /usr/local/mysql/support-files/mysql.server stop<span class="token punctuation">;</span>5、重启mysql服务：<span class="token function">sudo</span> /usr/local/mysql/support-files/mysql.server restart<span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESC服务器Linux下安装mysql</title>
      <link href="/2019/11/24/Linux/mysql/"/>
      <url>/2019/11/24/Linux/mysql/</url>
      
        <content type="html"><![CDATA[<p>1、重启服务器：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@sir-xiao server<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># reboot</span></code></pre><p>2、检查是否已经安装mysql服务：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@sir-xiao server<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># yum list installed | grep mysql</span></code></pre><p>如果显示一下内容，则表示没有安装：-bash: gerp: command not found<br>3、下载mysql安装包：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@sir-xiao server<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># rpm -ivh http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm</span></code></pre><p>4、安装mysql：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@sir-xiao server<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># yum install -y mysql-server</span>或者<span class="token punctuation">[</span>root@sir-xiao server<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># yum install mysql-community-server</span></code></pre><p>5、设置开机启动：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@sir-xiao server<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl enable mysqld.service</span></code></pre><p>6、查看服务是否加入开机自动启动：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@sir-xiao server<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl list-unit-files | grep mysqld</span></code></pre><p>7、查看mysql的默认临时密码：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@sir-xiao server<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl list-unit-files | grep mysqld</span></code></pre><p>8、root用户登录mysql数据库：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@sir-xiao server<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mysql -u root -p </span>Enter password: 根据提示 输入密码</code></pre><p>9、修改root用户密码：</p><pre class=" language-bash"><code class="language-bash">mysql<span class="token operator">></span> use  mysql；----切换到mysql dbmysql<span class="token operator">></span> UPDATE user SET authentication_string <span class="token operator">=</span> PASSWORD<span class="token punctuation">(</span><span class="token string">'newpass'</span><span class="token punctuation">)</span> WHERE user <span class="token operator">=</span> <span class="token string">'root'</span><span class="token punctuation">;</span>---新版本mysql执行mysql<span class="token operator">></span> UPDATE user SET Password <span class="token operator">=</span> PASSWORD<span class="token punctuation">(</span><span class="token string">'newpass'</span><span class="token punctuation">)</span> WHERE user <span class="token operator">=</span> <span class="token string">'root'</span><span class="token punctuation">;</span>---老版本mysql执行mysql<span class="token operator">></span> flush privileges<span class="token punctuation">;</span>---命令立即执行生效</code></pre><p>10、忘记密码重置密码：</p><pre class=" language-bash"><code class="language-bash">1、查找mysql的启动文件：<span class="token punctuation">[</span>root@sir-xiao etc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># whereis  my</span>2、vim /etc/my.cnf修改my.cnf启动参数，在文件的最后增加，mysql启动参数—— --skip-grant-tables。启动mysql时不启动授权表 grant-tables<span class="token punctuation">[</span>root@sir-xiao etc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># vi /etc/my.cnf skip-grant-tables</span><span class="token punctuation">[</span>root@sir-xiao etc<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># :wq</span>vi模式Enter进入，按“i”键，编辑文件，按“esc”键，输入:wq写入保存退出，:q 不保存退出3、重启mysql服务4、修改密码：同上5、密码修改成功后需要进入vi模式下重新编辑/etc/my.cnf去掉增加的skip-grant-tables 重启mysql服务，就可以用密码登录了</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx同域名下配置多项目</title>
      <link href="/2019/11/23/Nginx/multiProject/"/>
      <url>/2019/11/23/Nginx/multiProject/</url>
      
        <content type="html"><![CDATA[<h4 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h4><pre class=" language-bash"><code class="language-bash">build: <span class="token punctuation">{</span>    index: path.resolve<span class="token punctuation">(</span>__dirname, <span class="token string">'../dist/index.html'</span><span class="token punctuation">)</span>,    // Paths    assetsRoot: path.resolve<span class="token punctuation">(</span>__dirname, <span class="token string">'../dist'</span><span class="token punctuation">)</span>,    assetsSubDirectory: <span class="token string">'static'</span>,    assetsPublicPath: <span class="token string">'/admin/'</span>,    productionSourceMap: true,    devtool: <span class="token string">'#source-map'</span>,    productionGzip: true,    productionGzipExtensions: <span class="token punctuation">[</span><span class="token string">'js'</span>, <span class="token string">'css'</span><span class="token punctuation">]</span>,    bundleAnalyzerReport: process.env.npm_config_report  <span class="token punctuation">}</span></code></pre><p>把 assetsPublicPath修改为你在nginx配置的路径。</p><h4 id="router-js"><a href="#router-js" class="headerlink" title="router.js"></a>router.js</h4><pre class=" language-bash"><code class="language-bash">//base要和上面配置的assetsPublicPath配置的一样 mode:<span class="token string">'history'</span>, base: <span class="token string">'/admin/'</span>,</code></pre><h4 id="配置nginx："><a href="#配置nginx：" class="headerlink" title="配置nginx："></a>配置nginx：</h4><pre class=" language-bash"><code class="language-bash">keepalive_timeout  65<span class="token punctuation">;</span><span class="token function">gzip</span>  on<span class="token punctuation">;</span>//开启Gzip压缩gzip_disable <span class="token string">'msie6'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">#不使用gzip IE6</span>gzip_min_length 100k<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">#gzip压缩最小文件大小，超出进行压缩（自行调节）</span>gzip_buffers 4 16k<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">#buffer 不用修改</span>gzip_comp_level 3<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">#压缩级别:1-10，数字越大压缩的越好，时间也越长</span>server <span class="token punctuation">{</span>    listen 80<span class="token punctuation">;</span>    server_name www.xxx.cn<span class="token punctuation">;</span>//配置你的域名    location /<span class="token punctuation">{</span>//配置默认的项目         root /data/www/web<span class="token punctuation">;</span>         try_files <span class="token variable">$uri</span> <span class="token variable">$uri</span>/ /index.html<span class="token punctuation">;</span>         index index.html index.htm<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">#proxy_pass http://127.0.0.1:8080;</span>     <span class="token punctuation">}</span>     location ^~/admin<span class="token punctuation">{</span>//配置 域名/admin 对应的项目         <span class="token function">alias</span> /data/www/admin/<span class="token punctuation">;</span>//别名 配置项目文件路径         try_files <span class="token variable">$uri</span> <span class="token variable">$uri</span>/ /index.html<span class="token punctuation">;</span>         index index.html index.htm<span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>-e <span class="token variable">$request_filename</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>//防止二级路由下页面reload空白页面             rewrite ^/<span class="token punctuation">(</span>.*<span class="token punctuation">)</span> /admin/index.html last<span class="token punctuation">;</span>             <span class="token keyword">break</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">#proxy_pass http://127.0.0.1:8080;</span>     <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx下配置Vue项目</title>
      <link href="/2019/11/23/Nginx/vue/"/>
      <url>/2019/11/23/Nginx/vue/</url>
      
        <content type="html"><![CDATA[<p>1、配置选择：</p><ul><li>Linux系统：Centos 6.5 x64</li><li>Nginx版本：1.7.8</li></ul><p>2、安装nginx：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local//下载nginx<span class="token function">wget</span> http://nginx.org/download/nginx-1.7.8.tar.gz<span class="token function">cd</span> nginx-1.7.8<span class="token function">make</span><span class="token function">make</span> <span class="token function">install</span></code></pre><p>3、开启nginx服务：</p><pre class=" language-bash"><code class="language-bash">/usr/local/nginx-1.7.8/sbin/nginx重启或关闭进程：/usr/local/nginx-1.7.8/sbin/nginx -s reload/usr/local/nginx-1.7.8/sbin/nginx -s stop</code></pre><p>4、关闭防火墙：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">service</span> iptables stop</code></pre><p>5、修改配置文件：</p><pre class=" language-bash"><code class="language-bash">usr/local/nginx-1.7.8/conf/nginx.confserver <span class="token punctuation">{</span>    listen 80<span class="token punctuation">;</span>//监听80端口    server_name www.yangkunxiao.cn<span class="token punctuation">;</span>   //项目对应域名    location /<span class="token punctuation">{</span>     root /data/www/dist<span class="token punctuation">;</span>     //项目存放路径     try_files <span class="token variable">$uri</span> <span class="token variable">$uri</span>/ /index.html<span class="token punctuation">;</span>    //vue项目配置history模式     index index.html index.htm<span class="token punctuation">;</span>    //项目首页名称     <span class="token comment" spellcheck="true">#proxy_pass http://127.0.0.1:8080;   //域名对应URL，这个URL对应的就是http://m.horace.space，可通过域名直接访问</span>    <span class="token punctuation">}</span>    location /assets/<span class="token punctuation">{</span>//配置资源文件夹        root /usr/<span class="token punctuation">;</span>//资源文件夹路径        autoindex on<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>7、多个项目配置多个service即可<br>6、重启即可</p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx下配置静态资源</title>
      <link href="/2019/11/23/Nginx/staticSource/"/>
      <url>/2019/11/23/Nginx/staticSource/</url>
      
        <content type="html"><![CDATA[<p>1、查看nginx安装路径：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">whereis</span> nginx</code></pre><p>2、新建静态资源存储文件夹：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> assets</code></pre><p>3、进入nginx目录中，修改nginx.conf文件：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> nginx: /usr/local/nginx/confvim nginx.conf具体配置如下：server <span class="token punctuation">{</span>    listen 80<span class="token punctuation">;</span>    server_name www.yangkunxiao.cn<span class="token punctuation">;</span>    location /<span class="token punctuation">{</span>     root /data/www/dist<span class="token punctuation">;</span>     try_files <span class="token variable">$uri</span> <span class="token variable">$uri</span>/ /index.html<span class="token punctuation">;</span>     index index.html index.htm<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">#proxy_pass http://127.0.0.1:8080;</span>    <span class="token punctuation">}</span>    location /assets/<span class="token punctuation">{</span>        root /usr/<span class="token punctuation">;</span>        autoindex on<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>4、保存并重启nginx</p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php和mySql</title>
      <link href="/2019/11/22/Php/mysql/"/>
      <url>/2019/11/22/Php/mysql/</url>
      
        <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>通过PHP，开发者可以和数据库相连。<br>在PHP5.0版本以后，官方推荐一下两种方式进行PHP和数据库的连接：</p><ul><li>MySQLi extension (“i” 意为 improved)：MySQLi 只针对 MySQL 数据库</li><li>PDO (PHP Data Objects)：PDO 应用在 12 种不同数据库中<br>因为我这里只安装了mySql，所以本文栗子均以第一种方式进行操作。</li></ul><h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><p>在访问数据库之前，我们需要进行数据库的连接</p><pre class=" language-bash"><code class="language-bash"><span class="token variable">$serverName</span> <span class="token operator">=</span> <span class="token string">'localhost'</span><span class="token punctuation">;</span>//数据库地址<span class="token variable">$serverRoot</span> <span class="token operator">=</span> <span class="token string">'root'</span><span class="token punctuation">;</span>//数据库登录名称<span class="token variable">$passWord</span> <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>//数据库密码<span class="token variable">$dbName</span> <span class="token operator">=</span> <span class="token string">"myDB"</span><span class="token punctuation">;</span><span class="token variable">$conn</span> <span class="token operator">=</span> new mysqli<span class="token punctuation">(</span><span class="token variable">$serverName</span>,<span class="token variable">$userName</span>,<span class="token variable">$userPassword</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//连接失败if<span class="token punctuation">(</span><span class="token variable">$conn</span>-<span class="token operator">></span>connect_error<span class="token punctuation">)</span><span class="token punctuation">{</span>    die<span class="token punctuation">(</span><span class="token string">"数据库连接失败："</span><span class="token keyword">.</span><span class="token variable">$conn</span>-<span class="token operator">></span>connect_error<span class="token punctuation">)</span><span class="token punctuation">}</span>mysqli_set_charset<span class="token punctuation">(</span><span class="token variable">$this</span>-<span class="token operator">></span>conn, <span class="token string">"utf8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//设置字符编码为utf8格式 否则汉字可能出现乱码的情况//数据库操作完成之后 一定记得关闭数据库的连接<span class="token variable">$conn</span>-<span class="token operator">></span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h4><p>1、创建数据库：<code>$sql = &quot;CREATE DATABASE IF NOT EXISTS dbname&quot;</code><br>2、创建表：上面的连接语句要修改下，加个参数，用来选择数据库：</p><pre class=" language-bash"><code class="language-bash"><span class="token variable">$conn</span> <span class="token operator">=</span> new mysqli<span class="token punctuation">(</span><span class="token variable">$serverName</span>,<span class="token variable">$userName</span>,<span class="token variable">$userPassword</span>,<span class="token variable">$dbName</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$sql</span> <span class="token operator">=</span> <span class="token string">"CREATE TABLE MyGuests (id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY, firstname VARCHAR(30) NOT NULL,lastname VARCHAR(30) NOT NULL,email VARCHAR(50),reg_date TIMESTAMP)"</span><span class="token punctuation">;</span></code></pre><p>属性说明：</p><ul><li>NOT NULL - 每一行都必须含有值（不能为空），null 值是不允许的。</li><li>DEFAULT value - 设置默认值</li><li>UNSIGNED - 使用无符号数值类型，0 及正数</li><li>AUTO INCREMENT - 设置 MySQL 字段的值在新增记录时每次自动增长 1</li><li>PRIMARY KEY - 设置数据表中每条记录的唯一标识。 通常列的 PRIMARY KEY 设置为 ID 数值，与 AUTO_INCREMENT 一起使用。<br>每个表都应该有一个主键(本列为 “id” 列)，主键必须包含唯一的值</li></ul><p>3、插入数据：<code>$sql=&#39;INSERT INTO table_name (column1, column2, column3,...)VALUES (value1, value2, value3,...)&#39;</code><br>4、插入多条数据：</p><pre class=" language-bash"><code class="language-bash"><span class="token variable">$sql</span> <span class="token operator">=</span> <span class="token string">"INSERT INTO student (column1, column2, column3,...)VALUES (value1, value2, value3,...);"</span><span class="token punctuation">;</span><span class="token variable">$sql</span>.<span class="token operator">=</span><span class="token string">"INSERT INTO student (column1, column2, column3,...)VALUES (value1, value2, value3,...);"</span><span class="token punctuation">;</span><span class="token variable">$sql</span>.<span class="token operator">=</span><span class="token string">"INSERT INTO student (column1, column2, column3,...)VALUES (value1, value2, value3,...);"</span><span class="token punctuation">;</span></code></pre><p>注意：sql语句之间用;隔开</p><p>5、查询数据：<code>$sql = &#39;SELECT * FROM  myDB;&#39;</code><br>6、更新数据：<br><code>UPDATE table_nameSET column1=value, column2=value2,...WHERE some_column=some_value</code><br>7、删除数据：<code>DELETE FROM table_nameWHERE some_column = some_value</code></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
          <category> mySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> mySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php基础</title>
      <link href="/2019/11/22/Php/base/"/>
      <url>/2019/11/22/Php/base/</url>
      
        <content type="html"><![CDATA[<h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><p>（全称：PHP：Hypertext Preprocessor，即”PHP：超文本预处理器”）是一种通用开源脚本语言。</p><h4 id="PHP的作用"><a href="#PHP的作用" class="headerlink" title="PHP的作用"></a>PHP的作用</h4><ul><li>PHP 可以生成动态页面内容</li><li>PHP 可以创建、打开、读取、写入、关闭服务器上的文件<ul><li>PHP 可以收集表单数据</li><li>PHP 可以发送和接收 cookies</li><li>PHP 可以添加、删除、修改您的数据库中的数据</li><li>PHP 可以限制用户访问您的网站上的一些页面</li><li>PHP 可以加密数据</li></ul></li></ul><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><pre><code>&lt;?php    $x=5;    $y=6;    $z=$x+$y;    echo $z;?&gt;</code></pre><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p>PHP有四种不同的变量作用域：</p><ul><li>local：局部作用域。在 PHP 函数内部声明的变量是局部变量，仅能在函数内部访问</li><li>global：全局作用域。在所有函数外部定义的变量，拥有全局作用域。除了函数外，全局变量可以被脚本中的任何部分访问，要在一个函数中访问一个全局变量，需要使用 global 关键字。</li><li>static：当一个函数完成时，它的所有变量通常都会被删除。然而，有时候我们希望某个局部变量不要被删除，可以使用static</li><li>parameter：参数作用域。参数是通过调用代码将值传递给函数的局部变量。参数是在参数列表中声明的，作为函数声明的一部分</li></ul><h4 id="局部和全局作用域"><a href="#局部和全局作用域" class="headerlink" title="局部和全局作用域"></a>局部和全局作用域</h4><pre><code>$x = 5;//全局变量function test(){    global $x;//使用global关键字 使用全局变量    static $n = 0;//局部变量    $y = 10;//局部变量    $n++;    echo &#39;x: &#39;.$x.&#39;&lt;br/&gt;&#39;;    echo &#39;y: &#39;.$y.&#39;&lt;br/&gt;&#39;;    echo $n.&#39;&lt;br /&gt;&#39;;};test();test();test();</code></pre><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>常量值被定义后，在脚本的其他任何地方都不能被改变。常量是一个简单值的标识符。该值在脚本中不能改变。<br>一个常量由英文字母、下划线、和数字组成,但数字不能作为首字母出现。 (常量名不需要加 $ 修饰符)。<br>设置常量，使用 define() 函数，函数语法如下：</p><blockquote><p>bool define ( string $name , mixed $value [, bool $case_insensitive = false ] )<br>该函数有三个参数:</p></blockquote><ul><li>name：必选参数，常量名称，即标志符</li><li>value：必选参数，常量的值</li><li>case_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的</li></ul><pre><code>&lt;?phpdefine(&quot;GREETING&quot;, &quot;欢迎访问 Runoob.com&quot;);echo GREETING;    // 输出 &quot;欢迎访问 Runoob.com&quot;echo &#39;&lt;br&gt;&#39;;echo greeting;   // 输出 &quot;greeting&quot;?&gt;</code></pre><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li>字符串</li><li>整型：整数是一个没有小数的数字</li><li>浮点型：浮点数是带小数部分的数字，或是指数形式。</li><li>布尔型</li><li>数组</li><li>对象：在 PHP 中，对象必须声明。首先，你必须使用class关键字声明类对象。类是可以包含属性和方法的结构。然后我们在类中定义数据类型，然后在实例化的类中使用数据类型</li><li>NULL</li></ul>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建</title>
      <link href="/2019/11/22/Hexo/index/"/>
      <url>/2019/11/22/Hexo/index/</url>
      
        <content type="html"><![CDATA[<h4 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h4><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul><li><p>Node（本文不做多余叙述）</p></li><li><p>Git（本文不做多余叙述）</p></li><li><p>Hexo<br><code>$ npm install -g hexo-cli</code><br>安装完成后，到一个新的文件夹下，打开Git Bash，执行一下命令：</p><pre><code>$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install</code></pre><p>新建完成之后，打开新建的项目，查看项目目录：</p></li><li><p>public：执行hexo generate命令，生成的HTML静态文件</p></li><li><p>scaffolds：模版文件夹</p></li><li><p>source：资源文件夹，文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里</p><ul><li>_data：你的数据文件夹，例如：<ul><li>friends.json：存放友情链接的数据</li><li>musics.json：存放音乐播放器的数据</li></ul></li><li>_posts：文章存放文件夹</li><li>categories：分类</li><li>tags：标签<ul><li>thems：主题文件夹，Hexo 会根据主题来生成静态页面。以我当前使用的metery主题为例</li><li>langauages：存放语言相关设置的yml文件</li><li>layout：存放文章的ejs模版，可以在里面修改相关的HTML、CSS、JS等</li><li>source：该主题下使用的资源文件夹</li><li>_config.yml：该主题的配置文件</li></ul></li></ul></li></ul><ul><li>_config.yml：该项目的配置文件</li><li>db.json：source解析所得到的</li><li>package.json：项目所需模块项目的配置信息</li></ul><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><ul><li>GitHub上新建一个项目</li><li>本地Git Bash上配置github账户信息<ul><li><code>git config --global user.name &#39;yourName&#39;</code></li><li><code>git config --global user.email &#39;yourEmail&#39;</code><ul><li>创建SSH</li><li>在gitbash中输入：</li><li><code>ssh-keygen -t rsa -C &quot;youremail@example.com</code>，生成ssh。</li><li><code>cd ~/.ssh</code> 找到id_rsa.pub</li><li><code>cat id_rsa.pub</code>复制其中的内容到github上，创建一个新的 SSH KEY</li></ul></li></ul></li></ul><ul><li>修改_config.yml<pre><code>deploy:type: gitrepo: https://github.com/YourgithubName/YourgithubName.github.io.gitbranch: master</code></pre></li><li>回到Git Bash<pre><code>npm i hexo-serverhexo cleanhexo generatehexo server</code></pre></li><li>上传到GitHub<pre><code>npm install hexo-deployer-git --savehexo cleanhexo generatehexo deploy</code></pre>注意deploy的过程中要输入你的username及passward。<br>然后在浏览器中输入 <a href="http://yourgithubname.github.io" target="_blank" rel="noopener">http://yourgithubname.github.io</a> 就可以看到你的个人博客。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作用域和作用域链</title>
      <link href="/2019/11/21/JavaScript/ScopeChain/"/>
      <url>/2019/11/21/JavaScript/ScopeChain/</url>
      
        <content type="html"><![CDATA[<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>在JavaScript中的作用域有<strong><em>全局作用域</em></strong>、<strong><em>局部作用域</em></strong>（在JavaScript中局部作用域即是<strong><em>函数作用域</em></strong>）以及<strong><em>块级作用域</em></strong>。</p><ul><li><p>全局作用域：在最外层函数定义的变量即拥有全局作用域，对于任意函数来说，都可以访问到。例如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1</span>  <span class="token punctuation">}</span>  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><ul><li><p>局部作用域：和全局作用域相反，局部作用域的变量即是在特定代码块中才能过访问，对于外部是不能够访问的。注意：在函数内部定义变量的时候，如果不用var，那么你声明的就是全局变量了。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//1</span>  <span class="token punctuation">}</span>  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//b is not defined</span><span class="token punctuation">}</span></code></pre></li><li><p>块级作用域：在代码块中使用<strong><em>let</em></strong>定义的变量，只能在当前代码块中进行访问。块级作用域可以形成暂时性死区。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1-9</span>  <span class="token punctuation">}</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//undefined</span><span class="token punctuation">}</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></li></ul><h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p>个人理解，作用域就是在函数内部可以访问外部变量的机制，使用链式查找哪些变量可以被函数内部访问。说起作用域链，那么不得不说<strong><em>执行环境</em></strong>了。</p><h4 id="执行环境（Execution-Context）"><a href="#执行环境（Execution-Context）" class="headerlink" title="执行环境（Execution Context）"></a>执行环境（Execution Context）</h4><p>EC是JavaScript中一个最为重要的概念。EC定义了变量和函数有权访问的其他数据。JavaScript中，函数在运行时都会产生一个执行环境，并且JS引擎还会产生一个与当前EC相关联的<strong><em>变量对象</em></strong>（Variable Object，即VO）。EC中所有定义的变量和方法都包含在VO中。全局执行环境是最外围的执行环境，它是一个“兜底”的执行环境。</p><p>JS引擎在进入一段可执行的代码时，需要完成以下三个初始化工作：</p><p>首先，创建一个<strong><em>全局对象</em></strong>(Global Object，即GO)，将Math、String、Data等常用的js对象作为其属性，但是这个GO在全局是不可见的，不可直接访问的。因此它还有另外一个属性window，并将window指向了自身，这样就可以在全局通过访问window，来访问GO的属性和方法了。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> globalObject <span class="token operator">=</span> <span class="token punctuation">{</span>  Math<span class="token punctuation">,</span>  String<span class="token punctuation">,</span>  Data<span class="token punctuation">,</span>  Function<span class="token punctuation">,</span>  <span class="token operator">...</span>  window<span class="token punctuation">:</span><span class="token keyword">this</span><span class="token punctuation">}</span></code></pre><p>其次，JS引擎会创建一个<strong><em>执行环境栈</em></strong>（Execution Context Stack 即ECS），与此同时还会创建一个全局环境EC。当JS的执行流执行到一个函数时，JS引擎就会把该函数的EC推到ECS中，当函数执行完之后，再把EC从ECS中弹出，将执行流的控制权交还给上一层的EC。ECMAScript的执行流就是由这种机制控制着。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> ecStack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行到函数fn</span>ecStock<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>EC<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行完fn</span>ecStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span>EC<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>最后，JS引擎会创造一个和EC相关连的变量对象VO。如果这个环境是一个函数，则将其<strong><em>活动对象</em></strong>（Action Object，即AO）作为其变量对象。初始时AO只包含一个变量，即arguments。作用域链的下一个变量对象来自于外部包含环境，而下一个变量对象来自下一个包含环境，这样一直延伸到全局环境。全局变量对象（GO）始终都是作用域链的最后一个对象。</p><p>每一个函数在定义的时候，都会创建一个与之关联的<strong><em>[[scopes]]</em></strong>属性，该scope总是指向定义函数时的执行环境EC。举个🌰：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="http://cdn.yangkunxiao.cn/xv64Ki.png" alt="scopes"></p><p>如上图所示，函数fn的[[scopes]][0]即是它的执行环境，GO。</p><p>再看：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> t <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span></code></pre><p><img src="http://cdn.yangkunxiao.cn/KL9FAg.png" alt="scopes"></p><p>fn中始终都没有定义变量a，那么JS引擎就会沿着Scope Chain一直向上寻找a，最终在GO中找到了a。</p><h4 id="作用域链-1"><a href="#作用域链-1" class="headerlink" title="作用域链"></a>作用域链</h4><p>当JavaScript的代码块在运行时，就会创建与之相关的作用域链。</p><blockquote><p>作用域链的作用就是保证当前环境对其有权访问的变量和方法进行有序的访问 ——JavaScript高级程序设计</p></blockquote><p>作用域链的前端（也就是开头）就是当前执行环境EC的变量对象，它的变量对象来自于它的外部包含环境，再下一个变量对象同时也来自再下一个外部包含环境，这样一直延伸到全局执行环境，同时，GO也是作用域链的最后一个对象。</p><h4 id="标识符解析"><a href="#标识符解析" class="headerlink" title="标识符解析"></a>标识符解析</h4><p>当在某个环境中为了读取或写入从而引入一个标识符时，必须通过搜索来确定该标识符代表了什么。搜索过程从当期作用域链的前端开始，向上逐级搜索，如果在局部环境中查找到了该标识符的定义，则停止搜索‘否则将一直沿着作用域链向上查找，直到找到GO上。如果找不到，则会报错。</p><h4 id="延长作用域"><a href="#延长作用域" class="headerlink" title="延长作用域"></a>延长作用域</h4><p>虽然作用域只有两种：全局和局部（函数），但是还是有其他办法可以用来延长作用域链。其主要思路就是：有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象在代码执行后就被销毁。</p><p>1、try-catch语句的catch块</p><p>2、with语句</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>什么是闭包？个人理解就是由于函数的嵌套，并且对外提供访问接口就会产生闭包。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> b  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> t <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2</span></code></pre><p>在上面的代码中，正常情况下，函数fn执行完之后，应该<strong><em>JS的垃圾回收机制</em></strong>被标记“等待清除”，等待下一次垃圾回收机制执行的时候被清除，但是由于返回函数中引用了fn中的变量b，所以函数fn并不会被清除，而是一直保存着内存中，直到没有任何引用，才会被清除。</p><p>从上面的🌰我们可以得出，闭包有什么作用呢？</p><ul><li>闭包可以使得程序在函数外部可以访问到函数内部的变量</li><li>闭包可以在内存中维持一个变量</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> i    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>    <span class="token keyword">return</span> array<span class="token punctuation">}</span><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//10</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//10</span></code></pre><p>正常情况下，我们期待的结果就是返回0和1,但是结果出人意料。为什么呢？</p><p>其实我们可以先看下arr[0]执行时，它的scope chain：</p><p><img src="http://cdn.yangkunxiao.cn/r0f77m.png" alt="scopes"></p><p>我们可以清楚的看到，此时arr[0]中并没有i的定义，它会沿着作用域链向上找i，那么就会找到fn中的i，但是此时，i已经变成10了。</p><p>从此我们也可以得出一个结论：</p><blockquote><p>JS的函数中的变量的值不是在编译的时候确定的，而是在运行时再去寻找的。</p></blockquote><p>如果我们想让上面的🌰按照我们预期的执行，那么考虑使用立即执行函数。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//函数参数的传递是按值传递，会创建i的副本，而不是直接使用变量i</span>      <span class="token keyword">return</span> num    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> array<span class="token punctuation">}</span><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用原生JavaScript实现call、apply和bind</title>
      <link href="/2019/11/21/JavaScript/change-this/"/>
      <url>/2019/11/21/JavaScript/change-this/</url>
      
        <content type="html"><![CDATA[<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>在JavaScript中this的指向问题中提到，作为对象方法的调用。函数还可以作为某个对象的方法调用，这时this就指这个上级对象。也就是我们平时说的，谁调用，this就指向谁。</p><blockquote><p>实现方法：在传入的参数中传入一个方法，然后执行这个方法，最后删除该方法（为了保持对象的前后一致性）。</p></blockquote><h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><pre class=" language-bash"><code class="language-bash">var obj <span class="token operator">=</span> <span class="token punctuation">{</span>    age <span class="token punctuation">;</span> 10<span class="token punctuation">}</span>var fn <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    this.value <span class="token operator">=</span> 100<span class="token punctuation">;</span><span class="token punctuation">}</span>/**将newCall绑定在Function的原型上 context:上下文 即this<span class="token punctuation">..</span>.rest ES6语法糖 用来取代arguments*/Function.prototype.newCall <span class="token operator">=</span> function<span class="token punctuation">(</span>context,<span class="token punctuation">..</span>.rest<span class="token punctuation">)</span><span class="token punctuation">{</span>    if<span class="token punctuation">(</span> context instanceof Object <span class="token punctuation">)</span><span class="token punctuation">{</span>        context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>    <span class="token punctuation">}</span>else<span class="token punctuation">{</span>        context <span class="token operator">=</span> Object.create<span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    //使用symbal 避免原来的context上有函数fn    const fn <span class="token operator">=</span> Symbal<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> this<span class="token punctuation">;</span>//此时this 谁调用 指向谁    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">..</span>.rest<span class="token punctuation">)</span><span class="token punctuation">;</span>//context 调用fn,改变this指向    delete context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span>//删除fn属性 保持原对象的统一<span class="token punctuation">}</span>var fun <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console.log<span class="token punctuation">(</span>this.age<span class="token punctuation">)</span><span class="token punctuation">;</span>//10    // fn.newCall<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>    //console.log<span class="token punctuation">(</span>this.value<span class="token punctuation">)</span><span class="token punctuation">;</span> 100<span class="token punctuation">}</span>fun.newCall<span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p>和call类似，只是传参的不同，不多说 ，直接上代码： </p><pre class=" language-bash"><code class="language-bash">Function.prototype.newCall <span class="token operator">=</span> function<span class="token punctuation">(</span>context,parames<span class="token punctuation">)</span><span class="token punctuation">{</span>    if<span class="token punctuation">(</span> context instanceof Object <span class="token punctuation">)</span><span class="token punctuation">{</span>        context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>    <span class="token punctuation">}</span>else<span class="token punctuation">{</span>        context <span class="token operator">=</span> Object.create<span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    //使用symbal 避免原来的context上有函数fn    const fn <span class="token operator">=</span> Symbal<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> this<span class="token punctuation">;</span>//此时this 谁调用 指向谁    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span>parames<span class="token punctuation">)</span><span class="token punctuation">;</span>//context 调用fn,改变this指向    delete context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span>//删除fn属性 保持原对象的统一<span class="token punctuation">}</span></code></pre><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>bind和call、apply的区别，这里不再多做赘述。直接上代码：</p><pre class=" language-bash"><code class="language-bash">Function.prototype.bind <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>context,<span class="token punctuation">..</span>.innerArgs<span class="token punctuation">)</span> <span class="token punctuation">{</span>  var self <span class="token operator">=</span> this  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">..</span>.finnalyArgs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> self.call<span class="token punctuation">(</span>context,<span class="token punctuation">..</span>.innerArgs,<span class="token punctuation">..</span>.finnalyArgs<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript原型、原型链和继承</title>
      <link href="/2019/11/21/JavaScript/prototype/"/>
      <url>/2019/11/21/JavaScript/prototype/</url>
      
        <content type="html"><![CDATA[<h4 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h4><p>无论我们什么时候创建一个函数，它都会有一个属性prototype，该属性是一个指针，它指向函数的原型对象，该原型对象所拥有的属性和方法都可被函数的实例所共享。举个🌰：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>fn<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span>fn<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>todo <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'todo'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> newFn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//查看fn所有的属性和方法</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newFn<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//'a'</span>newFn<span class="token punctuation">.</span><span class="token function">todo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>所有的原型对象都会自动拥有一个属性constructor(构造函数)，这个属性包含一个指向构造函数的指针。即：</p><pre class=" language-javascript"><code class="language-javascript">fn<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> fn<span class="token punctuation">;</span></code></pre><blockquote><p>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262第5版中管这个指针叫[[Prototype]]。虽然在脚本中没有标准的方式访问[[Prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性__proto__；而在其他实现中，这个属性对脚本则是完全不可见的。——JavaScript高级程序设计</p></blockquote><p><img src="http://cdn.yangkunxiao.cn/prototype.png" alt=""></p><p>该属性是实例和构造函数的原型对象之间的联系，和构造函数并无直接关联，其实实例之所以可以调用构造函数的原型对象上面的属性和方法，也是通过该属性实现的。</p><p>小结：</p><ul><li>所有的引用类型都可以自由的扩展其属性（除null）</li><li>所有的引用类型都有_proto_属性（除null）</li><li>所有的对象都有prototype属性</li><li>所有的引用类型的_proto_都指向它们的构造函数的prototype</li><li>当寻找一个引用类型的属性时，如果在当前对象找不到该属性的定义，就会沿着_proro_一直向上寻找，直到找到为止或者找到Object.prototype(即null)为止。</li></ul><p>注意：大家可能已经注意到，函数既有prototype属性，也有_proto_属性。下面就针对函数做一个解释：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> Fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Fn<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span><span class="token string">'yellow'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>Fn<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>todo <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'todo'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> fn1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>fn1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//Fn.prototype</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>fn1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//Object.prototye</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>fn1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//null</span></code></pre><blockquote><p>请记住：一切引用类型都有一个隐式原型Object.prototype。</p></blockquote><p><img src="http://cdn.yangkunxiao.cn/scopeChain.jpeg" alt="原型链"></p><h4 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h4><p>原型对象最大的问题就是因其共享性所导致的。看个🌰：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//原型</span><span class="token keyword">var</span> Fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Fn<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span><span class="token string">'yellow'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>Fn<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>todo <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'todo'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> fn1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fn1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> fn2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ["red", "yellow", "blue"]</span></code></pre><h4 id="为什么要使用原型对象"><a href="#为什么要使用原型对象" class="headerlink" title="为什么要使用原型对象"></a>为什么要使用原型对象</h4><p>首先，看一段代码：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//新建一个构造函数 </span><span class="token keyword">var</span> Person <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">drink</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'drink'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>eat <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'eat'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>person<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在这段代码中，我们分别在Person和Person.prototye上挂载了 eat 和 drink 函数，然后使用 new 关键字对构造函数 Person 进行了实例化。</p><p>对于 drink 函数：每进行一次实例化，都要重新在内存中占用一些资源。</p><p>对于 eat 函数：我们将 eat 函数挂载在 Person 的原型上，Person 的实例每次只需要调用原型上的方法即可，节约了内存占用。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>ECMAScript中实现继承的主要就是依靠原型链来实现的。</p><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><p>最为ECMAScript最主要的继承方法，其基本思想就是让一个引用类型继承另一个引用类型的属性和方法。在上面我们说过，每一个构造函数都有一个原型对象，原型对象都有一个指向构造函数的指针constructor，每一个构造函数都可以生成一个实例，每一个实例都有一个指向原型对象的内部指针_proto_。简单来说就是：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> Fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> Test <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Fn<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Fn<span class="token punctuation">;</span>fn<span class="token punctuation">.</span>_proto_ <span class="token operator">=</span><span class="token operator">></span> Fn<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span></code></pre><p>如果此时我们让一个Fn的原型对象指向另一个类型的实例呢？</p><pre><code>Fn.prototype = new Test();</code></pre><p>那么此时，原型对象就会有一个指向另一个原型的指针，另一个原型也会包含一个指向另一个构造函数的指针。如此层层递进，即构成了原型链。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">,</span> <span class="token string">"green"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>SuperType<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>Fun <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//继承了SuperType</span>SubType<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"black"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//"red,blue,green,black"</span><span class="token keyword">var</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//"red,blue,green,black"</span></code></pre><blockquote><p>优点：可以通过 instanceOf 和 isPrototypeOf 检测</p><p>缺点：</p><p>1、父类型中的私有属性会变为子类型中的公有属性</p><p>2、创建子类型的时候，不能像父类型的构造函数中传递参数。</p></blockquote><h4 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h4><blockquote><p>JavaScript规定，每一个构造函数都有一个prototype属性，它指向一个对象，这个对象中的所有的属性和方法都会被构造函数的实例所继承。</p></blockquote><p>构造函数的继承是通过new关键字，生成实例完成的。使用new关键字生成实例的过程中，就会把this绑定到实例上，具体过程如下：</p><ol><li><p>在内存中先生成一个object的实例对象，</p></li><li><p>将实例对象的_proto_指向构造函数的prototype（即构造函数的原型），</p></li><li><p>运行构造函数，</p></li><li><p>检查返回值，如果返回值为基本数据类型，则无视该返回值，而将生成的对象返回。如果为引用类型，则将该返回值返回。</p></li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">,</span> <span class="token string">"green"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>SuperType<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">'ykx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'yellow'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Subtype</span><span class="token punctuation">(</span><span class="token string">'lhd'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span></code></pre><blockquote><p>优点：</p><p>1、实例化子类型的时候可以传参</p><p>2、父类型中的属性不会变为公共的属性</p><p>缺点：虽然构造函数实现继承的方式比较好用，但是并不推荐这种方式。构造函数继承存在内存浪费的情况，每生成一个实例，都会占用一些内存。</p></blockquote><h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><p>寄生式继承有点类似与工厂模式，即仅创建一个封装继承过程的函数，该函数在函数内部使用某种方式增强对象，最后再返回一个对象。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">inhertprototype</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> child <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">creata</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span>child<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">return</span> child<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> Person <span class="token operator">=</span> <span class="token punctuation">{</span>age<span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token keyword">var</span> boy <span class="token operator">=</span> <span class="token function">inhertprototype</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span><span class="token punctuation">;</span>boy<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>使用寄生式继承来为对象添加函数，不能够使函数得到更多的复用，降低了效率，类似于构造函数。</p><h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Man</span><span class="token punctuation">(</span>age<span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>eat <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>something<span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">+</span> <span class="token string">'岁的'</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">'正在吃: '</span> <span class="token operator">+</span> something<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span>Man<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>drink <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>something<span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">'正在喝:'</span> <span class="token operator">+</span> something<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Boy</span><span class="token punctuation">(</span>age<span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>Man<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>age<span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//组合继承</span><span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**不推荐使用 Boy.prototype = new Man();//组合继承因为在JavaScript中没有显式的constructor，所以使用new关键字实例化的时候 该函数会被调用一次*/</span><span class="token keyword">function</span> inhertprototype <span class="token punctuation">(</span>child<span class="token punctuation">,</span>parent<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> child<span class="token punctuation">;</span>child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Boy.prototype = Object.create(Man.prototype);</span><span class="token comment" spellcheck="true">//Boy.prototype.constructor = Boy;//避免原型错乱</span><span class="token function">inhertprototype</span><span class="token punctuation">(</span>Boy<span class="token punctuation">,</span>Man<span class="token punctuation">)</span><span class="token keyword">var</span> boy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boy</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token string">'ykx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>boy<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>boy<span class="token punctuation">.</span><span class="token function">drink</span><span class="token punctuation">(</span><span class="token string">'water'</span><span class="token punctuation">)</span></code></pre><p>原型错乱：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>SuperType<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span>Sub<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>SuperType<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>Sub<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>结果如下：</p><p><img src="https://img-blog.csdnimg.cn/20191113175800937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MTM0NzIx,size_16,color_FFFFFF,t_70" alt="原型错乱"></p><p>正确的继承结果应该如下：</p><p><img src="https://img-blog.csdnimg.cn/20191113175921976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MTM0NzIx,size_16,color_FFFFFF,t_70" alt="原型正常"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript数据类型</title>
      <link href="/2019/11/21/JavaScript/dataType/"/>
      <url>/2019/11/21/JavaScript/dataType/</url>
      
        <content type="html"><![CDATA[<p>JavaScript中有一下七种数据类型：Number、String、Null、Undefined、Bool、Object以及Symbal。</p><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>Number、String、Null、Undefined、Bool。<br>JavaScript的基本数据类型的访问是按值访问的，因为基本数据类型的值是保存在栈中的。</p><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>Object、Function、Array等。<br>JavaScript的引用数据类型的访问是按引用访问的，引用数据类型的值是存放在栈和堆中的：指针存放在栈中，值存放在堆中。栈区内存保存变量标识符和指向堆内存中该对象的指针，也可以说是该对象在堆内存的地址。</p><h4 id="数据类型的区分"><a href="#数据类型的区分" class="headerlink" title="数据类型的区分"></a>数据类型的区分</h4><ol><li>typeof 检查</li></ol><pre class=" language-bash"><code class="language-bash">typeof   123　　 //Numbertypeof   <span class="token string">'abc'</span>　　//Stringtypeof    <span class="token boolean">true</span>       //Booleantypeof    undefined   //Undefinedtypeof    null        //Object     typeof    <span class="token punctuation">{</span> <span class="token punctuation">}</span>           //Objecttypeof    <span class="token punctuation">[</span> <span class="token punctuation">]</span>           //Objecttypeof    console.log<span class="token punctuation">(</span><span class="token punctuation">)</span>       //Function</code></pre><p>可以看出 typeof 是检查不出来 null、{} 、[] 的。<br>推荐使用一下方法：</p><pre class=" language-bash"><code class="language-bash">判断基本类型：Object.prototype.toString.call<span class="token punctuation">(</span>null<span class="token punctuation">)</span> //<span class="token string">"[object Null]"</span>Object.prototype.toString.call<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> //<span class="token string">"[object Array]"</span>Object.prototype.toString.call<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> //<span class="token string">"[object Object]"</span>Object.prototype.toString.call<span class="token punctuation">(</span>123<span class="token punctuation">)</span> //<span class="token string">"[object Number]"</span>Object.prototype.toString.call<span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span> //<span class="token string">"[object String]"</span>Object.prototype.toString.call<span class="token punctuation">(</span>undefined<span class="token punctuation">)</span> //<span class="token string">"[object Undefined]"</span>Object.prototype.toString.call<span class="token punctuation">(</span>true<span class="token punctuation">)</span> //<span class="token string">"[object Boolean]"</span>判断引用类型：Function fn<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console.log<span class="token punctuation">(</span>“test”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Object.prototype.toString.call<span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>//<span class="token string">"[object Function]"</span>var <span class="token function">date</span> <span class="token operator">=</span> new Date<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Object.prototype.toString.call<span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>//<span class="token string">"[object Date]"</span>var reg <span class="token operator">=</span> /<span class="token punctuation">[</span>hbc<span class="token punctuation">]</span>at/gi<span class="token punctuation">;</span>Object.prototype.toString.call<span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>//<span class="token string">"[object RegExp]"</span></code></pre><h4 id="数据包装类型"><a href="#数据包装类型" class="headerlink" title="数据包装类型"></a>数据包装类型</h4><p>数据包装类型包含：Number、String、Boolean。数据包装类型是特殊的引用类型，每当创建一个基本数据类型的时候，就会在后台创建一个对应的数据包装类型对象，用来使基本数据类型可以访问对象上的方法和属性。<br>举个🌰：</p><pre class=" language-bash"><code class="language-bash">var str <span class="token operator">=</span> <span class="token string">'123'</span><span class="token punctuation">;</span>str.split<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//后台创建对应的数据包装类型var str <span class="token operator">=</span> new String<span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span>//创建str对象str.split<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//执行方法str <span class="token operator">=</span> null//销毁str</code></pre><p>而且，通过构造函数和对象字面量创建的对象是不一样的：</p><pre class=" language-bash"><code class="language-bash">var str <span class="token operator">=</span> <span class="token string">'123'</span><span class="token punctuation">;</span>typeof str // stringvar str1 <span class="token operator">=</span> new String<span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>typeof str1 // object</code></pre><p>其他的 Boolean 和 Number 也和 String 类似。</p><h4 id="为什么使用Object-prototype-toString-call"><a href="#为什么使用Object-prototype-toString-call" class="headerlink" title="为什么使用Object.prototype.toString.call()?"></a>为什么使用Object.prototype.toString.call()?</h4><p>因为toString方法是Object原型上的方法，而Array、function等类型作为Object的实例，都重写了toString方法。不同的对象的调用toString方法的时候，调用的都是重写的toString方法，而不是Object原型链上的方法。所以如果要得到对象的具体的类型，需要调用Object原型上的toString方法，即使用call将toString的this指向改变。</p><pre class=" language-bash"><code class="language-bash">var fun <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    alert<span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>fun.toString<span class="token punctuation">(</span><span class="token punctuation">))</span>//返回的是 函数的字符串形式delete Function.prototype.toString<span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>fun.toString<span class="token punctuation">(</span><span class="token punctuation">))</span>// 返回的是<span class="token punctuation">[</span>object Function<span class="token punctuation">]</span></code></pre><p>因为删除了Function.prototype上的toString方法之后，根据原型链，它会沿着原型链查找到Object.prototype.toString方法</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决多图片压缩上传和iOS端图片上传选择90度的问题</title>
      <link href="/2019/11/20/JavaScript/multiImageUpload/"/>
      <url>/2019/11/20/JavaScript/multiImageUpload/</url>
      
        <content type="html"><![CDATA[<p>逻辑思路：<br>1、监听input文件值的change事件<br>2、获取文件列表<br>3、使用FileReader()函数读取图片信息，并转为base64格式<br>4、根据预设的阀值，判断是否压缩<br>5、如果不压缩，将图片转为blob格式，使用FormData()函数，上传图片<br>6、如果压缩图片，使用canvas重新绘制图片，根据需要，选择是否使用瓦片canvas<br>7、使用Exif.js，获取图片方向信息，确定是否需要使用canvas的rotate()函数进行旋转图片<br>8、上传图片</p><h4 id="自定义图片上传组件："><a href="#自定义图片上传组件：" class="headerlink" title="自定义图片上传组件："></a>自定义图片上传组件：</h4><pre class=" language-bash"><code class="language-bash">//推荐<span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">'file'</span> id<span class="token operator">=</span><span class="token string">'upload'</span> accept<span class="token operator">=</span><span class="token string">'image/gif,image/jpeg,image/png,image/jpg'</span> @change<span class="token operator">=</span><span class="token string">'upload'</span> <span class="token operator">></span>//不推荐使用下面这种方法，该形式在Chrome浏览器中，选择文件弹框会滞留一段时间才弹出<span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">'file'</span> name<span class="token operator">=</span><span class="token string">'file'</span> class<span class="token operator">=</span><span class="token string">'element'</span> accept<span class="token operator">=</span><span class="token string">'image/*'</span><span class="token operator">></span></code></pre><h4 id="引入exif-js"><a href="#引入exif-js" class="headerlink" title="引入exif.js"></a>引入exif.js</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> Exif from <span class="token string">'exif-js'</span></code></pre><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><pre class=" language-bash"><code class="language-bash">upload<span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> files <span class="token operator">=</span> e.target.files <span class="token operator">||</span> e.dataTransfer.files<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>files.length<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    this.picValue <span class="token operator">=</span> files<span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token punctuation">;</span>    this.imgPreview<span class="token punctuation">(</span>this.picValue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>,//图片预览、处理、上传imgPreview<span class="token punctuation">(</span>file<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> self <span class="token operator">=</span> this<span class="token punctuation">;</span>    <span class="token keyword">let</span> Orientation<span class="token punctuation">;</span>    //去获取拍照时的信息，解决拍出来的照片旋转问题    Exif.getData<span class="token punctuation">(</span>file, function<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Orientation <span class="token operator">=</span> Exif.getTag<span class="token punctuation">(</span>this, <span class="token string">'Orientation'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    // alert<span class="token punctuation">(</span>Orientation,<span class="token string">'console.log(Orientation)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    debugger    // 看支持不支持FileReader    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>file <span class="token operator">||</span> <span class="token operator">!</span>window.FileReader<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    // alert<span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>    // 创建一个reader    <span class="token keyword">let</span> reader <span class="token operator">=</span> new FileReader<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    // 将图片2将转成 base64 格式    reader.readAsDataURL<span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>    // 读取成功后的回调    reader.onloadend <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> result <span class="token operator">=</span> this.result<span class="token punctuation">;</span>        <span class="token keyword">let</span> img <span class="token operator">=</span> new Image<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        img.onload <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> data <span class="token operator">=</span> self.compress<span class="token punctuation">(</span>img, Orientation<span class="token punctuation">)</span><span class="token punctuation">;</span>            /*self.headerImage <span class="token operator">=</span> data<span class="token punctuation">;</span>  */            var blob <span class="token operator">=</span> self.dataURItoBlob<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>            var fd <span class="token operator">=</span> new FormData<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            fd.append<span class="token punctuation">(</span><span class="token string">"file"</span>, blob, <span class="token string">'image.png'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            fd.fileName <span class="token operator">=</span> blob<span class="token punctuation">;</span>            console.log<span class="token punctuation">(</span>fd, <span class="token string">'fd'</span><span class="token punctuation">)</span>            axios.post<span class="token punctuation">(</span><span class="token string">'/sunrise-gateway/oss/ossUpload'</span>, fd<span class="token punctuation">)</span>.then<span class="token punctuation">((</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> res            <span class="token punctuation">}</span><span class="token punctuation">)</span>.then<span class="token punctuation">((</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                console.log<span class="token punctuation">(</span>res, <span class="token string">'res'</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>res.data.code <span class="token operator">==</span> <span class="token string">'000000'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    self.list.push<span class="token punctuation">(</span><span class="token punctuation">..</span>.res.data.data<span class="token punctuation">)</span><span class="token punctuation">;</span>                    self.objUrl <span class="token operator">=</span> res.data.data<span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token punctuation">;</span>                    self.picNum++<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    MessageBox.alert<span class="token punctuation">(</span><span class="token string">'上传失败0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                Indicator.close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>.catch<span class="token punctuation">((</span>err<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                Indicator.close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                MessageBox.alert<span class="token punctuation">(</span><span class="token string">'上传失败1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>            // alert<span class="token punctuation">(</span>blob<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        img.src <span class="token operator">=</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>,//base64转blobdataURItoBlob<span class="token punctuation">(</span>base64Data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    var byteString<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>base64Data.split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">[</span>0<span class="token punctuation">]</span>.indexOf<span class="token punctuation">(</span><span class="token string">'base64'</span><span class="token punctuation">)</span> <span class="token operator">>=</span> 0<span class="token punctuation">)</span> <span class="token punctuation">{</span>        byteString <span class="token operator">=</span> atob<span class="token punctuation">(</span>base64Data.split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        byteString <span class="token operator">=</span> unescape<span class="token punctuation">(</span>base64Data.split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    var mimeString <span class="token operator">=</span> base64Data.split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">[</span>0<span class="token punctuation">]</span>.split<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">)</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>.split<span class="token punctuation">(</span><span class="token string">';'</span><span class="token punctuation">)</span><span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token punctuation">;</span>    var ia <span class="token operator">=</span> new Uint8Array<span class="token punctuation">(</span>byteString.length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>var i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> byteString.length<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ia<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> byteString.charCodeAt<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> new Blob<span class="token punctuation">(</span><span class="token punctuation">[</span>ia<span class="token punctuation">]</span>, <span class="token punctuation">{</span>        type: mimeString    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>,//图片旋转rotateImg<span class="token punctuation">(</span>img, direction, canvas<span class="token punctuation">)</span> <span class="token punctuation">{</span>    //最小与最大旋转方向，图片旋转4次后回到原方向    const min_step <span class="token operator">=</span> 0<span class="token punctuation">;</span>    const max_step <span class="token operator">=</span> 3<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>img <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    //img的高度和宽度不能在img元素隐藏后获取，否则会出错    <span class="token keyword">let</span> height <span class="token operator">=</span> img.height<span class="token punctuation">;</span>    <span class="token keyword">let</span> width <span class="token operator">=</span> img.width<span class="token punctuation">;</span>    <span class="token keyword">let</span> step <span class="token operator">=</span> 2<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>step <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        step <span class="token operator">=</span> min_step<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>direction <span class="token operator">==</span> <span class="token string">'right'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        step++<span class="token punctuation">;</span>        //旋转到原位置，即超过最大值        step <span class="token operator">></span> max_step <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>step <span class="token operator">=</span> min_step<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        step--<span class="token punctuation">;</span>        step <span class="token operator">&lt;</span> min_step <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>step <span class="token operator">=</span> max_step<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    //旋转角度以弧度值为参数    <span class="token keyword">let</span> degree <span class="token operator">=</span> step * 90 * Math.PI / 180<span class="token punctuation">;</span>    <span class="token keyword">let</span> ctx <span class="token operator">=</span> canvas.getContext<span class="token punctuation">(</span><span class="token string">'2d'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    switch <span class="token punctuation">(</span>step<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> 0:            canvas.width <span class="token operator">=</span> width<span class="token punctuation">;</span>            canvas.height <span class="token operator">=</span> height<span class="token punctuation">;</span>            ctx.drawImage<span class="token punctuation">(</span>img, 0, 0<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> 1:            canvas.width <span class="token operator">=</span> height<span class="token punctuation">;</span>            canvas.height <span class="token operator">=</span> width<span class="token punctuation">;</span>            ctx.rotate<span class="token punctuation">(</span>degree<span class="token punctuation">)</span><span class="token punctuation">;</span>            ctx.drawImage<span class="token punctuation">(</span>img, 0, -height<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> 2:            canvas.width <span class="token operator">=</span> width<span class="token punctuation">;</span>            canvas.height <span class="token operator">=</span> height<span class="token punctuation">;</span>            ctx.rotate<span class="token punctuation">(</span>degree<span class="token punctuation">)</span><span class="token punctuation">;</span>            ctx.drawImage<span class="token punctuation">(</span>img, -width, -height<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> 3:            canvas.width <span class="token operator">=</span> height<span class="token punctuation">;</span>            canvas.height <span class="token operator">=</span> width<span class="token punctuation">;</span>            ctx.rotate<span class="token punctuation">(</span>degree<span class="token punctuation">)</span><span class="token punctuation">;</span>            ctx.drawImage<span class="token punctuation">(</span>img, -width, 0<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>,//图片压缩compress<span class="token punctuation">(</span>img, Orientation<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> canvas <span class="token operator">=</span> document.createElement<span class="token punctuation">(</span><span class="token string">'canvas'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> ctx <span class="token operator">=</span> canvas.getContext<span class="token punctuation">(</span><span class="token string">'2d'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    //瓦片canvas    <span class="token keyword">let</span> tCanvas <span class="token operator">=</span> document.createElement<span class="token punctuation">(</span><span class="token string">'canvas'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> tctx <span class="token operator">=</span> tCanvas.getContext<span class="token punctuation">(</span><span class="token string">'2d'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> initSize <span class="token operator">=</span> img.src.length<span class="token punctuation">;</span>    <span class="token keyword">let</span> width <span class="token operator">=</span> img.width<span class="token punctuation">;</span>    <span class="token keyword">let</span> height <span class="token operator">=</span> img.height<span class="token punctuation">;</span>    //如果图片大于四百万像素，计算压缩比并将大小压至400万以下    <span class="token keyword">let</span> ratio<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">((</span>ratio <span class="token operator">=</span> width * height / 4000000<span class="token punctuation">)</span> <span class="token operator">></span> 1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        // console.log<span class="token punctuation">(</span><span class="token string">'大于400万像素'</span><span class="token punctuation">)</span>        ratio <span class="token operator">=</span> Math.sqrt<span class="token punctuation">(</span>ratio<span class="token punctuation">)</span><span class="token punctuation">;</span>        width /<span class="token operator">=</span> ratio<span class="token punctuation">;</span>        height /<span class="token operator">=</span> ratio<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        ratio <span class="token operator">=</span> 1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    canvas.width <span class="token operator">=</span> width<span class="token punctuation">;</span>    canvas.height <span class="token operator">=</span> height<span class="token punctuation">;</span>    //铺底色    ctx.fillStyle <span class="token operator">=</span> <span class="token string">'#fff'</span><span class="token punctuation">;</span>    ctx.fillRect<span class="token punctuation">(</span>0, 0, canvas.width, canvas.height<span class="token punctuation">)</span><span class="token punctuation">;</span>    //如果图片像素大于100万则使用瓦片绘制    <span class="token keyword">let</span> count<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">((</span>count <span class="token operator">=</span> width * height / 1000000<span class="token punctuation">)</span> <span class="token operator">></span> 1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        // console.log<span class="token punctuation">(</span><span class="token string">'超过100W像素'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        count <span class="token operator">=</span> ~~<span class="token punctuation">(</span>Math.sqrt<span class="token punctuation">(</span>count<span class="token punctuation">)</span> + 1<span class="token punctuation">)</span><span class="token punctuation">;</span> //计算要分成多少块瓦片        //计算每块瓦片的宽和高        <span class="token keyword">let</span> nw <span class="token operator">=</span> ~~<span class="token punctuation">(</span>width / count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> nh <span class="token operator">=</span> ~~<span class="token punctuation">(</span>height / count<span class="token punctuation">)</span><span class="token punctuation">;</span>        tCanvas.width <span class="token operator">=</span> nw<span class="token punctuation">;</span>        tCanvas.height <span class="token operator">=</span> nh<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>let i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>let j <span class="token operator">=</span> 0<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> j++<span class="token punctuation">)</span> <span class="token punctuation">{</span>                tctx.drawImage<span class="token punctuation">(</span>img, i * nw * ratio, j * nh * ratio, nw * ratio, nh * ratio, 0, 0, nw, nh<span class="token punctuation">)</span><span class="token punctuation">;</span>                ctx.drawImage<span class="token punctuation">(</span>tCanvas, i * nw, j * nh, nw, nh<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        ctx.drawImage<span class="token punctuation">(</span>img, 0, 0, width, height<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    //修复ios上传图片的时候 被旋转的问题    <span class="token keyword">if</span> <span class="token punctuation">(</span>Orientation <span class="token operator">!=</span> <span class="token string">''</span> <span class="token operator">&amp;&amp;</span> Orientation <span class="token operator">!=</span> 1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        switch <span class="token punctuation">(</span>Orientation<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> 6: //需要顺时针（向左）90度旋转                this.rotateImg<span class="token punctuation">(</span>img, <span class="token string">'left'</span>, canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> 8: //需要逆时针（向右）90度旋转                this.rotateImg<span class="token punctuation">(</span>img, <span class="token string">'right'</span>, canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> 3: //需要180度旋转                this.rotateImg<span class="token punctuation">(</span>img, <span class="token string">'right'</span>, canvas<span class="token punctuation">)</span><span class="token punctuation">;</span> //转两次                this.rotateImg<span class="token punctuation">(</span>img, <span class="token string">'right'</span>, canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    //进行最小压缩        <span class="token keyword">let</span> ndata <span class="token operator">=</span> canvas.toDataURL<span class="token punctuation">(</span><span class="token string">'image/jpeg'</span>, 0.1<span class="token punctuation">)</span><span class="token punctuation">;</span>    tCanvas.width <span class="token operator">=</span> tCanvas.height <span class="token operator">=</span> canvas.width <span class="token operator">=</span> canvas.height <span class="token operator">=</span> 0<span class="token punctuation">;</span>    <span class="token keyword">return</span> ndata<span class="token punctuation">;</span><span class="token punctuation">}</span>,</code></pre><p>备注：<br>canvas.toDataURL() 方法返回一个包含图片展示的 data URI 。可以使用 type 参数其类型，默认为 image/png 格式。图片的分辨率为96dpi。</p><p>在指定图片格式为 image/jpeg 或 image/webp的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92。其他参数会被忽略。</p><p>返回值：包含dataURI的DOMString。</p><p> DataURI格式：data:[<mediatype>][;base64],<data>。其中mediatype声明了文件类型，遵循MIME规则，如“image/png”、“text/plain”；之后是编码类型，这里我们只涉及 base64；紧接着就是文件编码后的内容了。</p><p>URI（Uniform Resource Identifier）:统一资源标识符,服务器资源名被称为统一资源标识符.如：<code>img src=&#39;images/image.png&#39;</code></p><p>URL（Uniform Resource Locator）:统一资源定位符，描述了一台特定服务器上某资源的特定位置。如:</p><pre><code>img src=&#39;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAWCAYAAAArdgcFAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAACXBIWXMAAAsTAAALEwEAmpwYAAABSUlEQVQ4Ee1VPUsDQRB9s3dBRCRNQvCjkDQW/hJ/gb9AOwWDoIXFgYXYXGP+hYW1/gIr7WzsE8VGxZBcwt04dznCJWw2twtWutXMmzdvlrd7t4SZVbvi1ZihZuCFqT9A/B7Qd5FI44RpPcQpE1oC1IsEq5jRBeGyc0zXaV8mvhbyOREurIRMZMZhp0VthYB9mXBi4jrUztIev1bNbKg6CMxvIWwg5GWVDOHNZ7lX6l/wrG+Fzbh/ca1bf9QWBhKtHznobgtjKF92ZBL3TUWpRbK7LhiVCY8kY3xK/iTiexNcEywSXxKBrfHvrdBN2JRsp4BoQ3dbtHLT4K+JqxWw8vr4YDaf+vR+SmXRWw99lT9N96VaypIYtwgoyWyJRtiX3T+X7TXxROcxGeAo5chlyNcBVxrb2JVpTUHsz4IQi/DL6wPucENxqvoDx69PXP8OKn4AAAAASUVORK5CYII=&#39;/</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac开启本地服务器</title>
      <link href="/2019/11/20/Other/server/"/>
      <url>/2019/11/20/Other/server/</url>
      
        <content type="html"><![CDATA[<h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>是一个高性能的HTTP和反向代理服务器，同时也是一个 IMAP/POP3/SMTP 代理服务器。</p><pre class=" language-bash"><code class="language-bash">安装：搜索软件：brew search nginx安装软件：brew <span class="token function">install</span> nginx卸载软件：brew uninstall nginx升级brew：sudo brew update查看安装信息：sudo brew info nginx查看已经安装的软件：brew list</code></pre><p>nginx常用命令：</p><pre class=" language-bash"><code class="language-bash">nginx -v //查看下安装好的nginx版本<span class="token function">sudo</span> nginx  // 启动nginx<span class="token function">sudo</span> nginx              //启动nginx<span class="token function">sudo</span> nginx -s reload    //修改配置后重新加载生效<span class="token comment" spellcheck="true">#简单解释下，上面这种方法重启，nginx在重启的时候不会中断服务，因为  nginx在启动后，会有一个master进程和多个worker进程，重启是会先生成新的worker进程去接受reload命令，等老的worker进程执行完毕，master进程在关闭他们，所以服务器不会中断。</span><span class="token function">sudo</span> nginx -s  reopen   //重新打开日志文件<span class="token function">sudo</span> nginx -s stop  //快速停止nginx<span class="token function">sudo</span> nginx -s quit  //完整有序的停止nginx<span class="token function">sudo</span> nginx -t     //测试当前配置文件是否正确</code></pre><p>nginx常见目录：</p><pre class=" language-bash"><code class="language-bash">/usr/local/Cellar/  <span class="token comment" spellcheck="true">#nginx默认安装的目录,所有使用brew安装的软件默认都在这里</span>/usr/local/Cellar/nginx/1.8.0/html  ＃默认的访问目录，就是我们说的网站根目录/usr/local/etc/nginx/     <span class="token comment" spellcheck="true"># nginx.conf所在的目录</span>修改默认路径从nginx/html改成你自己放置代码的路径vim /usr/local/etc/nginx/nginx.conf</code></pre><p>接下来的任务就很明确了，把listen 80下面的两个 root html中的路径，改成我们自己放代码的文件夹。例如在桌面下面新建一个home的文件夹，再在目录下新建一个www的文件夹，那么路径就是：桌面:homewww，把task1.html放进去，然后修改配置修改完成后，点击Esc键<code>·shift+: 输入：wq</code>，保存修改。</p><h4 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h4><p>打开终端，开启Apache:</p><pre class=" language-bash"><code class="language-bash">//开启apache:  <span class="token function">sudo</span> apachectl start//重启apache:  <span class="token function">sudo</span> apachectl restart//关闭apache:  <span class="token function">sudo</span> apachectl stop//查看apache版本 <span class="token function">sudo</span> apachectl -v</code></pre><p>回车会提示输入密码，也就是你电脑的密码，<a href="http://127.0.0.1/测试一下。" target="_blank" rel="noopener">http://127.0.0.1/测试一下。</a><br>点击Finder,然后Command+Shift+G,前往Apache服务器的文件路径(/Library/WebServer/Documents)，在步骤1中只输入一个<a href="http://127.0.0.1其实默认打开的是index.html.en(html是一个网页文件)，该文件的内容就是在步骤1中测试时浏览器所显示的内容" target="_blank" rel="noopener">http://127.0.0.1其实默认打开的是index.html.en(html是一个网页文件)，该文件的内容就是在步骤1中测试时浏览器所显示的内容</a></p>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue使用webpack优化构建流程</title>
      <link href="/2019/11/20/Vue/webpack%E6%9E%84%E5%BB%BA/"/>
      <url>/2019/11/20/Vue/webpack%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>初衷：如果我们的 Vue 项目比较大．或者说项目中引入了许多第三方库，那么在执行 npm run build 构建项目的时候会极其的慢．比如我现在的项目就每次打包就要 83s。<br>下面提供一些方法用来提供优化打包速度：</p><h4 id="resolve-modules"><a href="#resolve-modules" class="headerlink" title="resolve.modules"></a>resolve.modules</h4><p>思路：webpack 的 resolve.modules 是用来配置模块库（即 node_modules）所在的位置。当 js 里出现 import ‘vue’ 这样不是相对、也不是绝对路径的写法时，它便会到 node_modules 目录下去找。在默认配置下，webpack 会采用向上递归搜索的方式去寻找。但通常项目目录里只有一个 node_modules，且是在项目根目录。为了减少搜索范围，可我们以直接写明 node_modules 的全路径。</p><pre><code>打开 build/webpack.base.conf.js 文件，添加如下配置：module.exports = {  resolve: {    extensions: [&#39;.js&#39;, &#39;.vue&#39;, &#39;.json&#39;],    modules: [      resolve(&#39;src&#39;),      resolve(&#39;node_modules&#39;)    ],    alias: {      &#39;vue$&#39;: &#39;vue/dist/vue.esm.js&#39;,      &#39;@&#39;: resolve(&#39;src&#39;),    }  },</code></pre><h4 id="webpack-parallel-uglify-plugin"><a href="#webpack-parallel-uglify-plugin" class="headerlink" title="webpack-parallel-uglify-plugin"></a>webpack-parallel-uglify-plugin</h4><p>原理：webpack默认提供了UglifyJS插件来压缩JS代码，但是它使用的是单线程压缩代码，也就是说多个js文件需要被压缩，它需要一个个文件进行压缩。所以说在正式环境打包压缩代码速度非常慢(因为压缩JS代码需要先把代码解析成用Object抽象表示的AST语法树，再去应用各种规则分析和处理AST，导致这个过程耗时非常大)。源码：</p><pre><code>module.exports = {  plugins: [    new webpack.optimize.UglifyJsPlugin({      sourceMap: true,      compress: {        warnings: false      }    }),  ]}</code></pre><p>我们可以改用 webpack-parallel-uglify-plugin 插件，它可以并行运行 UglifyJS 插件，从而更加充分、合理的使用 CPU 资源，从而大大减少构建时间。<br>当webpack有多个JS文件需要输出和压缩时候，原来会使用UglifyJS去一个个压缩并且输出，但是ParallelUglifyPlugin插件则会开启多个子进程，把对多个文件压缩的工作分别给多个子进程去完成，但是每个子进程还是通过UglifyJS去压缩代码。无非就是变成了并行处理该压缩了，并行处理多个子任务，效率会更高。</p><pre><code>安装：npm i webpack-parallel-uglify-plugin打开 build/webpack.prod.conf.js 文件，并作如下修改：const ParallelUglifyPlugin = require(&#39;webpack-parallel-uglify-plugin&#39;);// 删掉webpack提供的UglifyJS插件    //new UglifyJsPlugin({    //  uglifyOptions: {    //    compress: {    //      warnings: false    //    }    //  },    //  sourceMap: config.build.productionSourceMap,    //  parallel: true    //}),    // 增加 webpack-parallel-uglify-plugin来替换    new ParallelUglifyPlugin({      cacheDir: &#39;.cache/&#39;,      uglifyJS:{        output: {          comments: false        },        compress: {          warnings: false,          drop_debugger: true,          drop_console: true        }      }    }),</code></pre><h4 id="HappyPack"><a href="#HappyPack" class="headerlink" title="HappyPack"></a>HappyPack</h4><p>原理：由于运行在 Node.js 之上的 Webpack 是单线程模型的，所以 Webpack 需要处理的事情只能一件一件地做，不能多件事一起做。而 HappyPack 的处理思路是：将原有的 webpack 对 loader 的执行过程，从单一进程的形式扩展多进程模式，从而加速代码构建。</p><pre><code>安装：npm i happypack打开 build/webpack.base.conf.js 文件，并作如下修改：const HappyPack = require(&#39;happypack&#39;);const os = require(&#39;os&#39;);const happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length });module.exports = {  module: {    rules: [      {        test: /.js$/,        //把对.js 的文件处理交给id为happyBabel 的HappyPack 的实例执行        loader: &#39;happypack/loader?id=happyBabel&#39;,        include: [resolve(&#39;src&#39;)],        //排除node_modules 目录下的文件        exclude: /node_modules/      },    ]  },  plugins: [    new HappyPack({        //用id来标识 happypack处理那里类文件      id: &#39;happyBabel&#39;,      //如何处理  用法和loader 的配置一样      loaders: [{        loader: &#39;babel-loader?cacheDirectory=true&#39;,      }],      //共享进程池      threadPool: happyThreadPool,      //允许 HappyPack 输出日志      verbose: true,    })  ]}</code></pre><h4 id="DllPlugin-和-DllReferencePlugin"><a href="#DllPlugin-和-DllReferencePlugin" class="headerlink" title="DllPlugin 和 DllReferencePlugin"></a>DllPlugin 和 DllReferencePlugin</h4><p>原理：我们的项目依赖中通常会引用大量的 npm 包，而这些包在正常的开发过程中并不会进行修改，但是在每一次构建过程中却需要反复的将其解析，而下面介绍的两个插件就是用来规避此类损耗的：<br>DllPlugin 插件：作用是预先编译一些模块。<br>DllReferencePlugin 插件：它的所用则是把这些预先编译好的模块引用起来。<br>注意：DllPlugin 必须要在 DllReferencePlugin 执行前先执行一次。</p><pre><code>1、在 build 文件夹中新建 webpack.dll.conf.js 文件，内容如下（主要是配置下需要提前编译打包的库）：const path = require(&#39;path&#39;);const webpack = require(&#39;webpack&#39;);module.exports = {  entry: {    vendor: [&#39;vue/dist/vue.common.js&#39;,            &#39;vue-router&#39;,            &#39;axios&#39;,            &#39;vuex&#39;,            &#39;element-ui&#39;]  },  output: {    path: path.join(__dirname, &#39;../static/js&#39;),    filename: &#39;[name].dll.js&#39;,    library: &#39;[name]_library&#39;       // vendor.dll.js中暴露出的全局变量名  },  plugins: [    new webpack.DllPlugin({      path: path.join(__dirname, &#39;.&#39;, &#39;[name]-manifest.json&#39;),      name: &#39;[name]_library&#39;    }),    new webpack.optimize.UglifyJsPlugin({      compress: {        warnings: false      }    })  ]};2、编辑 package.json 文件，添加一条编译命令：    dll: webpack --config webpack.dll.conf.js接着执行 npm run dll 命令来生成 vendor.dll.js。注意：如果之后这些需要预编译的库又有变动，则需再次执行 npm run dll 命令来重新生成 vendor.dll.js3、index.html 这边将 vendor.dll.js 引入进来：&lt;script src=‘./static/js/vendor.dll.js’&gt;&lt;/script&gt;4、打开 build/webpack.base.conf.js 文件，编辑添加如下高亮配置，作用是通过 DLLReferencePlugin 来使用 DllPlugin 生成的 DLL Bundle。const webpack = require(&#39;webpack&#39;);module.exports = {  context: path.resolve(__dirname, &#39;../&#39;),  entry: {    app: &#39;./src/main.js&#39;  },  //.....  plugins: [     // 添加DllReferencePlugin插件     new webpack.DllReferencePlugin({       context: path.resolve(__dirname, &#39;..&#39;),       manifest: require(&#39;./vendor-manifest.json&#39;)     }),  ]}</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
