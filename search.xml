<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>javascript数据类型</title>
      <link href="/2019/11/19/javascript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/11/19/javascript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>JavaScript中有一下七种数据类型：Number、String、Null、Undefined、Bool、Object以及Symbal。</p><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>Number、String、Null、Undefined、Bool。<br>JavaScript的基本数据类型的访问是按值访问的，因为基本数据类型的值是保存在栈中的。</p><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>Object、Function、Array等。<br>JavaScript的引用数据类型的访问是按引用访问的，引用数据类型的值是存放在栈和堆中的：指针存放在栈中，值存放在堆中。栈区内存保存变量标识符和指向堆内存中该对象的指针，也可以说是该对象在堆内存的地址。</p><h4 id="数据类型的区分"><a href="#数据类型的区分" class="headerlink" title="数据类型的区分"></a>数据类型的区分</h4><ol><li>typeof 检查</li></ol><pre class=" language-bash"><code class="language-bash">typeof   123　　 //Numbertypeof   <span class="token string">'abc'</span>　　//Stringtypeof    <span class="token boolean">true</span>       //Booleantypeof    undefined   //Undefinedtypeof    null        //Object     typeof    <span class="token punctuation">{</span> <span class="token punctuation">}</span>           //Objecttypeof    <span class="token punctuation">[</span> <span class="token punctuation">]</span>           //Objecttypeof    console.log<span class="token punctuation">(</span><span class="token punctuation">)</span>       //Function</code></pre><p>可以看出 typeof 是检查不出来 null、{} 、[] 的。<br>推荐使用一下方法：</p><pre class=" language-bash"><code class="language-bash">判断基本类型：Object.prototype.toString.call<span class="token punctuation">(</span>null<span class="token punctuation">)</span> //<span class="token string">"[object Null]"</span>Object.prototype.toString.call<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> //<span class="token string">"[object Array]"</span>Object.prototype.toString.call<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> //<span class="token string">"[object Object]"</span>Object.prototype.toString.call<span class="token punctuation">(</span>123<span class="token punctuation">)</span> //<span class="token string">"[object Number]"</span>Object.prototype.toString.call<span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span> //<span class="token string">"[object String]"</span>Object.prototype.toString.call<span class="token punctuation">(</span>undefined<span class="token punctuation">)</span> //<span class="token string">"[object Undefined]"</span>Object.prototype.toString.call<span class="token punctuation">(</span>true<span class="token punctuation">)</span> //<span class="token string">"[object Boolean]"</span>判断引用类型：Function fn<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console.log<span class="token punctuation">(</span>“test”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Object.prototype.toString.call<span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>//<span class="token string">"[object Function]"</span>var <span class="token function">date</span> <span class="token operator">=</span> new Date<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Object.prototype.toString.call<span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>//<span class="token string">"[object Date]"</span>var reg <span class="token operator">=</span> /<span class="token punctuation">[</span>hbc<span class="token punctuation">]</span>at/gi<span class="token punctuation">;</span>Object.prototype.toString.call<span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>//<span class="token string">"[object RegExp]"</span></code></pre><h4 id="数据包装类型"><a href="#数据包装类型" class="headerlink" title="数据包装类型"></a>数据包装类型</h4><p>数据包装类型包含：Number、String、Boolean。数据包装类型是特殊的引用类型，每当创建一个基本数据类型的时候，就会在后台创建一个对应的数据包装类型对象，用来使基本数据类型可以访问对象上的方法和属性。<br>举个🌰：</p><pre class=" language-bash"><code class="language-bash">var str <span class="token operator">=</span> <span class="token string">'123'</span><span class="token punctuation">;</span>str.split<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//后台创建对应的数据包装类型var str <span class="token operator">=</span> new String<span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span>//创建str对象str.split<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//执行方法str <span class="token operator">=</span> null//销毁str</code></pre><p>而且，通过构造函数和对象字面量创建的对象是不一样的：</p><pre class=" language-bash"><code class="language-bash">var str <span class="token operator">=</span> <span class="token string">'123'</span><span class="token punctuation">;</span>typeof str // stringvar str1 <span class="token operator">=</span> new String<span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>typeof str1 // object</code></pre><p>其他的 Boolean 和 Number 也和 String 类似。</p><h4 id="为什么使用Object-prototype-toString-call"><a href="#为什么使用Object-prototype-toString-call" class="headerlink" title="为什么使用Object.prototype.toString.call()?"></a>为什么使用Object.prototype.toString.call()?</h4><p>因为toString方法是Object原型上的方法，而Array、function等类型作为Object的实例，都重写了toString方法。不同的对象的调用toString方法的时候，调用的都是重写的toString方法，而不是Object原型链上的方法。所以如果要得到对象的具体的类型，需要调用Object原型上的toString方法，即使用call将toString的this指向改变。</p><pre class=" language-bash"><code class="language-bash">var fun <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    alert<span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>fun.toString<span class="token punctuation">(</span><span class="token punctuation">))</span>//返回的是 函数的字符串形式delete Function.prototype.toString<span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>fun.toString<span class="token punctuation">(</span><span class="token punctuation">))</span>// 返回的是<span class="token punctuation">[</span>object Function<span class="token punctuation">]</span></code></pre><p>因为删除了Function.prototype上的toString方法之后，根据原型链，它会沿着原型链查找到Object.prototype.toString方法</p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>执行环境（execution context）,简称EC，它是JavaScript最为重要的一个概念</title>
      <link href="/2019/11/18/javascript/EC%20and%20Scope/"/>
      <url>/2019/11/18/javascript/EC%20and%20Scope/</url>
      
        <content type="html"><![CDATA[<h4 id="执行环境EC"><a href="#执行环境EC" class="headerlink" title="执行环境EC"></a>执行环境EC</h4><p><strong>执行环境</strong>(Execution Context，即EC)是JavaScript中最为重要的一个概念。<br>执行环境定义链变量及函数有权访问的其他数据，决定了它们各自的行为。<br>全局执行环境是一个“兜底”的执行环境，它是最外围的执行环境。</p><h4 id="全局对象GO"><a href="#全局对象GO" class="headerlink" title="全局对象GO"></a>全局对象GO</h4><p>它在全局只存在一份，它的属性可以在任何地方都可以访问到，它的存在是伴随着整个程序的生命周期的。</p><p>JS引擎在进入一段可执行的代码时，需要完成以下三个初始化工作：</p><p>1、首先，创建一个全局对象(Global Object，即GO)，将Math、String、Data等常用的js对象作为其属性，但是这个GO在全局是不可见的，不可直接访问的。因此它还有另外一个属性window，并将window指向了自身，这样就可以在全局通过访问window，来访问GO的属性了。</p><pre class=" language-bash"><code class="language-bash">//创建一个全局对象var globalObject <span class="token operator">=</span> <span class="token punctuation">{</span>    Math:<span class="token punctuation">{</span><span class="token punctuation">}</span>,    String:<span class="token punctuation">{</span><span class="token punctuation">}</span>,    Date:<span class="token punctuation">{</span><span class="token punctuation">}</span>,    document:<span class="token punctuation">{</span><span class="token punctuation">}</span>, //DOM操作    <span class="token punctuation">..</span>.    window:this //让window属性指向了自身<span class="token punctuation">}</span></code></pre><h4 id="环境执行栈ECS"><a href="#环境执行栈ECS" class="headerlink" title="环境执行栈ECS"></a>环境执行栈ECS</h4><p>然后JS引擎会创建一个环境执行栈(Execution Context Stack，即ECS)，与此同时，还会建立一个全局的执行环境(Execution Context，即EC)。当执行流进入到一个函数时，函数的执行环境就会被推到ECS中，而在函数执行完毕之后，ECS就会将其环境弹出，并且将程序的控制权交给之前的EC。ECMAScript程序的执行流就是由这种机制控制着。</p><pre class=" language-bash"><code class="language-bash">var ECStack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> //定义一个执行环境栈，类似于数组var EC <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   //创建一个执行空间，//ECMA-262规范并没有对EC的数据结构做明确的定义，你可以理解为在内存中分配的一块空间ECStack.push<span class="token punctuation">(</span>EC<span class="token punctuation">)</span><span class="token punctuation">;</span> //进入函数，压入执行环境ECStack.pop<span class="token punctuation">(</span>EC<span class="token punctuation">)</span><span class="token punctuation">;</span>  //函数返回后，删除执行环境</code></pre><h4 id="变量对象VO"><a href="#变量对象VO" class="headerlink" title="变量对象VO"></a>变量对象VO</h4><p>最后，JS引擎会创建一个与EC相关联的对象，<strong>变量对象</strong>（Variable Object，即VO），每个执行环境都有与之关联的VO，并把VO指向全局对象，VO中不仅仅包含了全局对象的属性，还包含了环境中定义的所有的变量和函数。<br>每个函数在定义的时候，都会创建一个与之关联的<strong>scope</strong>属性，scope总是指向定义函数时所在的环境。</p><h4 id="作用域链Scope-Chain"><a href="#作用域链Scope-Chain" class="headerlink" title="作用域链Scope Chain"></a>作用域链Scope Chain</h4><p>当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行环境的代码所在的变量对象。如果这个环境是函数，则将其<strong>活动对象</strong>（Activation Object，即AO）作为变量对象，初始时AO只包含一个变量，即arguments。作用域链的下一个变量对象来自于外部包含环境，而下一个变量对象来自下一个包含环境，这样一直延伸到全局环境。全局变量对象（GO）始终都是作用域链的最后一个对象。</p><h4 id="标识符解析"><a href="#标识符解析" class="headerlink" title="标识符解析"></a>标识符解析</h4><p>当在某个环境中为了读取或写入从而引入一个标识符时，必须通过搜索来确定该标识符代表了什么。搜索过程从当期作用域链的前端开始，向上逐级搜索，如果在局部环境中查找到了该标识符的定义，则停止搜索‘否则将一直沿着作用域链向上查找，直到找到GO上。如果找不到，则会报错</p><h4 id="延长作用域"><a href="#延长作用域" class="headerlink" title="延长作用域"></a>延长作用域</h4><p>虽然作用域只有两种：全局和局部（函数），但是还是有其他办法可以用来延长作用域链。其主要思路就是：有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象在代码执行后就被销毁。<br>1、try-catch语句的catch块<br>2、with语句</p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用原生JavaScript实现call、apply和bind</title>
      <link href="/2019/11/18/javascript/this/"/>
      <url>/2019/11/18/javascript/this/</url>
      
        <content type="html"><![CDATA[<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>在JavaScript中this的指向问题中提到，作为对象方法的调用。函数还可以作为某个对象的方法调用，这时this就指这个上级对象。也就是我们平时说的，谁调用，this就指向谁。</p><blockquote><p>实现方法：在传入的参数中传入一个方法，然后执行这个方法，最后删除该方法（为了保持对象的前后一致性）。</p></blockquote><h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><pre class=" language-bash"><code class="language-bash">var obj <span class="token operator">=</span> <span class="token punctuation">{</span>    age <span class="token punctuation">;</span> 10<span class="token punctuation">}</span>var fn <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    this.value <span class="token operator">=</span> 100<span class="token punctuation">;</span><span class="token punctuation">}</span>/**将newCall绑定在Function的原型上 context:上下文 即this<span class="token punctuation">..</span>.rest ES6语法糖 用来取代arguments*/Function.prototype.newCall <span class="token operator">=</span> function<span class="token punctuation">(</span>context,<span class="token punctuation">..</span>.rest<span class="token punctuation">)</span><span class="token punctuation">{</span>    if<span class="token punctuation">(</span> context instanceof Object <span class="token punctuation">)</span><span class="token punctuation">{</span>        context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>    <span class="token punctuation">}</span>else<span class="token punctuation">{</span>        context <span class="token operator">=</span> Object.create<span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    //使用symbal 避免原来的context上有函数fn    const fn <span class="token operator">=</span> Symbal<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> this<span class="token punctuation">;</span>//此时this 谁调用 指向谁    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">..</span>.rest<span class="token punctuation">)</span><span class="token punctuation">;</span>//context 调用fn,改变this指向    delete context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span>//删除fn属性 保持原对象的统一<span class="token punctuation">}</span>var fun <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console.log<span class="token punctuation">(</span>this.age<span class="token punctuation">)</span><span class="token punctuation">;</span>//10    // fn.newCall<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>    //console.log<span class="token punctuation">(</span>this.value<span class="token punctuation">)</span><span class="token punctuation">;</span> 100<span class="token punctuation">}</span>fun.newCall<span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p>和call类似，只是传参的不同，不多说 ，直接上代码：</p><pre class=" language-bash"><code class="language-bash">Function.prototype.newCall <span class="token operator">=</span> function<span class="token punctuation">(</span>context,parames<span class="token punctuation">)</span><span class="token punctuation">{</span>    if<span class="token punctuation">(</span> context instanceof Object <span class="token punctuation">)</span><span class="token punctuation">{</span>        context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>    <span class="token punctuation">}</span>else<span class="token punctuation">{</span>        context <span class="token operator">=</span> Object.create<span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    //使用symbal 避免原来的context上有函数fn    const fn <span class="token operator">=</span> Symbal<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> this<span class="token punctuation">;</span>//此时this 谁调用 指向谁    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span>parames<span class="token punctuation">)</span><span class="token punctuation">;</span>//context 调用fn,改变this指向    delete context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span>//删除fn属性 保持原对象的统一<span class="token punctuation">}</span></code></pre><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>bind和call、apply的区别，这里不再多做赘述。直接上代码：</p><pre class=" language-bash"><code class="language-bash">Function.prototype.bind <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>context,<span class="token punctuation">..</span>.innerArgs<span class="token punctuation">)</span> <span class="token punctuation">{</span>  var self <span class="token operator">=</span> this  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">..</span>.finnalyArgs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> self.call<span class="token punctuation">(</span>context,<span class="token punctuation">..</span>.innerArgs,<span class="token punctuation">..</span>.finnalyArgs<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript原型和原型链</title>
      <link href="/2019/11/13/javascript/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2019/11/13/javascript/%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h4 id="为什么要使用原型prototype"><a href="#为什么要使用原型prototype" class="headerlink" title="为什么要使用原型prototype"></a>为什么要使用原型prototype</h4><p>首先，让我们看一段代码：</p><pre class=" language-bash"><code class="language-bash">//新建一个构造函数var Person <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    drink<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console.log<span class="token punctuation">(</span><span class="token string">'drink'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Person.prototype.eat <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console.log<span class="token punctuation">(</span><span class="token string">'eat'</span><span class="token punctuation">)</span><span class="token punctuation">}</span>var person <span class="token operator">=</span> new Person<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>person.eat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在这段代码中，我们分别在Person和Person.prototye上挂载了 eat 和 drink 函数，然后使用 new 关键字对构造函数 Person 进行了实例化。</p><p>对于 drink 函数：每进行一次实例化，都要重新在内存中占用一些资源；</p><p>对于 eat 函数：我们将 eat 函数挂载在 Person 的原型上，Person 的实例每次只需要调用原型伤的方法即可。不仅节约了资源，而且是的代码更加优雅、美观。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ol><li><p>所有的引用类型（数组、函数、对象）可以自由扩展属性（除null以外）</p></li><li><p>所有引用类型（数组、函数、对象）都有_proto_属性（这是它的隐式原型，除null外）</p></li><li><p>所有构造函数都有prototype属性（这是它的显示原型）</p></li><li><p>所有引用类型的_proto_都指向它们的构造函数的 prototype </p></li><li><p>当寻找一个属性时，如果在当前对象本身找不到该属性，就会沿着_proto_向上进行寻找，直到找到为止或者指向 null 为止。（这就是原型链）</p><p><img src="http://q0sal13sb.bkt.clouddn.com/yuanxinglian.jpeg" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Javascript继承</title>
      <link href="/2019/11/13/javascript/%E7%BB%A7%E6%89%BF/"/>
      <url>/2019/11/13/javascript/%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p>在JavaScript中有很多继承的方式，接下来让我们一起来总结下各种继承的方法以及它们的不同点。</p><h4 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h4><blockquote><p>JavaScript规定，每一个构造函数都有一个prototype属性，它指向一个对象，这个对象中的所有的属性和方法都会被构造函数的实例所继承。</p></blockquote><p>构造函数的继承是通过new关键字，生成实例完成的。使用new关键字生成实例的过程中，就会把this绑定到实例上，具体过程如下：</p><ol><li>在内存中先生成一个object的实例对象，</li><li>将实例对象的_proto_指向构造函数的prototype（即构造函数的原型），</li><li>运行构造函数，</li><li>检查返回值，如果返回值为基本数据类型，则无视该返回值，而将生成的对象返回。如果为引用类型，则将该返回值返回。</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token keyword">function</span> SuperType<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    this.colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"red"</span>, <span class="token string">"blue"</span>, <span class="token string">"green"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> SubType<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>    SuperType.call<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">}</span>var s <span class="token operator">=</span> new SubType<span class="token punctuation">(</span><span class="token string">'ykx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s.colors.push<span class="token punctuation">(</span><span class="token string">'yellow'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>s.colors<span class="token punctuation">)</span><span class="token punctuation">;</span>var s2 <span class="token operator">=</span> new Subtype<span class="token punctuation">(</span><span class="token string">'lhd'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console.log<span class="token punctuation">(</span>s2.colors<span class="token punctuation">)</span></code></pre><blockquote><p>优点：<br>1、实例化子类型的时候可以传参<br>2、父类型中的属性不会变为公共的属性</p></blockquote><blockquote><p>缺点：虽然构造函数实现继承的方式比较好用，但是并不推荐这种方式。构造函数继承存在内存浪费的情况，每生成一个实例，都会占用一些内存。</p></blockquote><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><pre class=" language-bash"><code class="language-bash"><span class="token keyword">function</span> SuperType<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    this.colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"red"</span>, <span class="token string">"blue"</span>, <span class="token string">"green"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>SuperType.prototype.Fun <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> SubType<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>//继承了SuperTypeSubType.prototype <span class="token operator">=</span> new SuperType<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>var instance1 <span class="token operator">=</span> new SubType<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>instance1.colors.push<span class="token punctuation">(</span><span class="token string">"black"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>alert<span class="token punctuation">(</span>instance1.colors<span class="token punctuation">)</span><span class="token punctuation">;</span> //<span class="token string">"red,blue,green,black"</span>var instance2 <span class="token operator">=</span> new SubType<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>alert<span class="token punctuation">(</span>instance2.colors<span class="token punctuation">)</span><span class="token punctuation">;</span> //<span class="token string">"red,blue,green,black"</span></code></pre><blockquote><p>优点：可以通过 instanceOf 和 isPrototypeOf 检测<br>instanceOf：a.instanceOf B ,左操作数是一个对象，右操作数标识对象的类。如果左侧对象是右侧类的实例，则表达式返回为true，否则返回false。<br>isPrototypeOf：检测一个对象是否是另一个对象的原型。或者说一个对象是否被包含在另一个对象的原型链中。</p></blockquote><blockquote><p>缺点：<br>1、父类型中的私有属性会变为子类型中的公有属性<br>2、创建子类型的时候，不能像父类型的构造函数中传递参数。</p></blockquote><h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><pre class=" language-bash"><code class="language-bash"><span class="token keyword">function</span> Man<span class="token punctuation">(</span>age,name<span class="token punctuation">)</span><span class="token punctuation">{</span>    this.eat <span class="token operator">=</span> function<span class="token punctuation">(</span>something<span class="token punctuation">)</span><span class="token punctuation">{</span>        console.log<span class="token punctuation">(</span>this.age + <span class="token string">'岁的'</span> + this.name + <span class="token string">'正在吃: '</span> + something<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>Man.prototype.drink <span class="token operator">=</span> function<span class="token punctuation">(</span>something<span class="token punctuation">)</span><span class="token punctuation">{</span>    console.log<span class="token punctuation">(</span>this.name + <span class="token string">'正在喝:'</span> + something<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">function</span> Boy<span class="token punctuation">(</span>age,name<span class="token punctuation">)</span><span class="token punctuation">{</span>    this.age <span class="token operator">=</span> age<span class="token punctuation">;</span>    this.name <span class="token operator">=</span> name<span class="token punctuation">;</span>    Man.call<span class="token punctuation">(</span>this,age,name<span class="token punctuation">)</span><span class="token punctuation">}</span>/**不推荐使用 Boy.prototype <span class="token operator">=</span> new Man<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>因为在JavaScript中没有显式的constructor，所以使用new关键字实例化的时候 该函数会被调用一次*/Boy.prototype <span class="token operator">=</span> Object.create<span class="token punctuation">(</span>Man.prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>Boy.prototype.constructor <span class="token operator">=</span> Boy<span class="token punctuation">;</span>//避免原型错乱var boy <span class="token operator">=</span> new Boy<span class="token punctuation">(</span>12,<span class="token string">'ykx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>boy.eat<span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>boy.drink<span class="token punctuation">(</span><span class="token string">'water'</span><span class="token punctuation">)</span></code></pre><p>原型错乱：</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">function</span> SuperType<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">function</span> Sub<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    SuperType.call<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">}</span>Sub.prototype <span class="token operator">=</span> Object.create<span class="token punctuation">(</span>SuperType.prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>console.dir<span class="token punctuation">(</span>Sub<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>结果如下：<br><img src="https://img-blog.csdnimg.cn/20191113175800937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MTM0NzIx,size_16,color_FFFFFF,t_70" alt="原型错乱"><br>正确的继承结果应该如下：<br><img src="https://img-blog.csdnimg.cn/20191113175921976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MTM0NzIx,size_16,color_FFFFFF,t_70" alt="原型正常"></p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php和mySql</title>
      <link href="/2019/11/12/php/mysql/"/>
      <url>/2019/11/12/php/mysql/</url>
      
        <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>通过PHP，开发者可以和数据库相连。<br>在PHP5.0版本以后，官方推荐一下两种方式进行PHP和数据库的连接：</p><ul><li>MySQLi extension (“i” 意为 improved)：MySQLi 只针对 MySQL 数据库</li><li>PDO (PHP Data Objects)：PDO 应用在 12 种不同数据库中<br>因为我这里只安装了mySql，所以本文栗子均以第一种方式进行操作。</li></ul><h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><p>在访问数据库之前，我们需要进行数据库的连接</p><pre class=" language-bash"><code class="language-bash"><span class="token variable">$serverName</span> <span class="token operator">=</span> <span class="token string">'localhost'</span><span class="token punctuation">;</span>//数据库地址<span class="token variable">$serverRoot</span> <span class="token operator">=</span> <span class="token string">'root'</span><span class="token punctuation">;</span>//数据库登录名称<span class="token variable">$passWord</span> <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>//数据库密码<span class="token variable">$dbName</span> <span class="token operator">=</span> <span class="token string">"myDB"</span><span class="token punctuation">;</span><span class="token variable">$conn</span> <span class="token operator">=</span> new mysqli<span class="token punctuation">(</span><span class="token variable">$serverName</span>,<span class="token variable">$userName</span>,<span class="token variable">$userPassword</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//连接失败if<span class="token punctuation">(</span><span class="token variable">$conn</span>-<span class="token operator">></span>connect_error<span class="token punctuation">)</span><span class="token punctuation">{</span>    die<span class="token punctuation">(</span><span class="token string">"数据库连接失败："</span><span class="token keyword">.</span><span class="token variable">$conn</span>-<span class="token operator">></span>connect_error<span class="token punctuation">)</span><span class="token punctuation">}</span>mysqli_set_charset<span class="token punctuation">(</span><span class="token variable">$this</span>-<span class="token operator">></span>conn, <span class="token string">"utf8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//设置字符编码为utf8格式 否则汉字可能出现乱码的情况//数据库操作完成之后 一定记得关闭数据库的连接<span class="token variable">$conn</span>-<span class="token operator">></span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h4><p>1、创建数据库：<code>$sql = &quot;CREATE DATABASE IF NOT EXISTS dbname&quot;</code><br>2、创建表：上面的连接语句要修改下，加个参数，用来选择数据库：</p><pre class=" language-bash"><code class="language-bash"><span class="token variable">$conn</span> <span class="token operator">=</span> new mysqli<span class="token punctuation">(</span><span class="token variable">$serverName</span>,<span class="token variable">$userName</span>,<span class="token variable">$userPassword</span>,<span class="token variable">$dbName</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$sql</span> <span class="token operator">=</span> <span class="token string">"CREATE TABLE MyGuests (id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY, firstname VARCHAR(30) NOT NULL,lastname VARCHAR(30) NOT NULL,email VARCHAR(50),reg_date TIMESTAMP)"</span><span class="token punctuation">;</span></code></pre><p>属性说明：</p><ul><li>NOT NULL - 每一行都必须含有值（不能为空），null 值是不允许的。</li><li>DEFAULT value - 设置默认值</li><li>UNSIGNED - 使用无符号数值类型，0 及正数</li><li>AUTO INCREMENT - 设置 MySQL 字段的值在新增记录时每次自动增长 1</li><li>PRIMARY KEY - 设置数据表中每条记录的唯一标识。 通常列的 PRIMARY KEY 设置为 ID 数值，与 AUTO_INCREMENT 一起使用。<br>每个表都应该有一个主键(本列为 “id” 列)，主键必须包含唯一的值</li></ul><p>3、插入数据：<code>$sql=&#39;INSERT INTO table_name (column1, column2, column3,...)VALUES (value1, value2, value3,...)&#39;</code><br>4、插入多条数据：</p><pre class=" language-bash"><code class="language-bash"><span class="token variable">$sql</span> <span class="token operator">=</span> <span class="token string">"INSERT INTO student (column1, column2, column3,...)VALUES (value1, value2, value3,...);"</span><span class="token punctuation">;</span><span class="token variable">$sql</span>.<span class="token operator">=</span><span class="token string">"INSERT INTO student (column1, column2, column3,...)VALUES (value1, value2, value3,...);"</span><span class="token punctuation">;</span><span class="token variable">$sql</span>.<span class="token operator">=</span><span class="token string">"INSERT INTO student (column1, column2, column3,...)VALUES (value1, value2, value3,...);"</span><span class="token punctuation">;</span></code></pre><p>注意：sql语句之间用;隔开</p><p>5、查询数据：<code>$sql = &#39;SELECT * FROM  myDB;&#39;</code><br>6、更新数据：<br><code>UPDATE table_nameSET column1=value, column2=value2,...WHERE some_column=some_value</code><br>7、删除数据：<code>DELETE FROM table_nameWHERE some_column = some_value</code></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
          <category> mySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> mySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建</title>
      <link href="/2019/11/11/hexo/index/"/>
      <url>/2019/11/11/hexo/index/</url>
      
        <content type="html"><![CDATA[<h4 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h4><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul><li><p>Node（本文不做多余叙述）</p></li><li><p>Git（本文不做多余叙述）</p></li><li><p>Hexo<br><code>$ npm install -g hexo-cli</code><br>安装完成后，到一个新的文件夹下，打开Git Bash，执行一下命令：</p><pre><code>$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install</code></pre><p>新建完成之后，打开新建的项目，查看项目目录：</p></li><li><p>public：执行hexo generate命令，生成的HTML静态文件</p></li><li><p>scaffolds：模版文件夹</p></li><li><p>source：资源文件夹，文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里</p><ul><li>_data：你的数据文件夹，例如：<ul><li>friends.json：存放友情链接的数据</li><li>musics.json：存放音乐播放器的数据</li></ul></li><li>_posts：文章存放文件夹</li><li>categories：分类</li><li>tags：标签<ul><li>thems：主题文件夹，Hexo 会根据主题来生成静态页面。以我当前使用的metery主题为例</li><li>langauages：存放语言相关设置的yml文件</li><li>layout：存放文章的ejs模版，可以在里面修改相关的HTML、CSS、JS等</li><li>source：该主题下使用的资源文件夹</li><li>_config.yml：该主题的配置文件</li></ul></li></ul></li></ul><ul><li>_config.yml：该项目的配置文件</li><li>db.json：source解析所得到的</li><li>package.json：项目所需模块项目的配置信息</li></ul><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><ul><li>GitHub上新建一个项目</li><li>本地Git Bash上配置github账户信息<ul><li><code>git config --global user.name &#39;yourName&#39;</code></li><li><code>git config --global user.email &#39;yourEmail&#39;</code><ul><li>创建SSH</li><li>在gitbash中输入：</li><li><code>ssh-keygen -t rsa -C &quot;youremail@example.com</code>，生成ssh。</li><li><code>cd ~/.ssh</code> 找到id_rsa.pub</li><li><code>cat id_rsa.pub</code>复制其中的内容到github上，创建一个新的 SSH KEY</li></ul></li></ul></li></ul><ul><li>修改_config.yml<pre><code>deploy:type: gitrepo: https://github.com/YourgithubName/YourgithubName.github.io.gitbranch: master</code></pre></li><li>回到Git Bash<pre><code>npm i hexo-serverhexo cleanhexo generatehexo server</code></pre></li><li>上传到GitHub<pre><code>npm install hexo-deployer-git --savehexo cleanhexo generatehexo deploy</code></pre>注意deploy的过程中要输入你的username及passward。<br>然后在浏览器中输入 <a href="http://yourgithubname.github.io" target="_blank" rel="noopener">http://yourgithubname.github.io</a> 就可以看到你的个人博客。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php基础</title>
      <link href="/2019/11/11/php/base/"/>
      <url>/2019/11/11/php/base/</url>
      
        <content type="html"><![CDATA[<h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><p>（全称：PHP：Hypertext Preprocessor，即”PHP：超文本预处理器”）是一种通用开源脚本语言。</p><h4 id="PHP的作用"><a href="#PHP的作用" class="headerlink" title="PHP的作用"></a>PHP的作用</h4><ul><li>PHP 可以生成动态页面内容</li><li>PHP 可以创建、打开、读取、写入、关闭服务器上的文件<ul><li>PHP 可以收集表单数据</li><li>PHP 可以发送和接收 cookies</li><li>PHP 可以添加、删除、修改您的数据库中的数据</li><li>PHP 可以限制用户访问您的网站上的一些页面</li><li>PHP 可以加密数据</li></ul></li></ul><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><pre><code>&lt;?php    $x=5;    $y=6;    $z=$x+$y;    echo $z;?&gt;</code></pre><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p>PHP有四种不同的变量作用域：</p><ul><li>local：局部作用域。在 PHP 函数内部声明的变量是局部变量，仅能在函数内部访问</li><li>global：全局作用域。在所有函数外部定义的变量，拥有全局作用域。除了函数外，全局变量可以被脚本中的任何部分访问，要在一个函数中访问一个全局变量，需要使用 global 关键字。</li><li>static：当一个函数完成时，它的所有变量通常都会被删除。然而，有时候我们希望某个局部变量不要被删除，可以使用static</li><li>parameter：参数作用域。参数是通过调用代码将值传递给函数的局部变量。参数是在参数列表中声明的，作为函数声明的一部分</li></ul><h4 id="局部和全局作用域"><a href="#局部和全局作用域" class="headerlink" title="局部和全局作用域"></a>局部和全局作用域</h4><pre><code>$x = 5;//全局变量function test(){    global $x;//使用global关键字 使用全局变量    static $n = 0;//局部变量    $y = 10;//局部变量    $n++;    echo &#39;x: &#39;.$x.&#39;&lt;br/&gt;&#39;;    echo &#39;y: &#39;.$y.&#39;&lt;br/&gt;&#39;;    echo $n.&#39;&lt;br /&gt;&#39;;};test();test();test();</code></pre><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>常量值被定义后，在脚本的其他任何地方都不能被改变。常量是一个简单值的标识符。该值在脚本中不能改变。<br>一个常量由英文字母、下划线、和数字组成,但数字不能作为首字母出现。 (常量名不需要加 $ 修饰符)。<br>设置常量，使用 define() 函数，函数语法如下：</p><blockquote><p>bool define ( string $name , mixed $value [, bool $case_insensitive = false ] )<br>该函数有三个参数:</p></blockquote><ul><li>name：必选参数，常量名称，即标志符</li><li>value：必选参数，常量的值</li><li>case_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的</li></ul><pre><code>&lt;?phpdefine(&quot;GREETING&quot;, &quot;欢迎访问 Runoob.com&quot;);echo GREETING;    // 输出 &quot;欢迎访问 Runoob.com&quot;echo &#39;&lt;br&gt;&#39;;echo greeting;   // 输出 &quot;greeting&quot;?&gt;</code></pre><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li>字符串</li><li>整型：整数是一个没有小数的数字</li><li>浮点型：浮点数是带小数部分的数字，或是指数形式。</li><li>布尔型</li><li>数组</li><li>对象：在 PHP 中，对象必须声明。首先，你必须使用class关键字声明类对象。类是可以包含属性和方法的结构。然后我们在类中定义数据类型，然后在实例化的类中使用数据类型</li><li>NULL</li></ul>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
